{"text":"Q: Why are `getTaskSetting` and `getTaskPropertyConfig` called immediately in the initialization effect? A: These API calls fetch configuration data (like reminder defaults and dynamic form field settings) needed to render the form correctly before any user interaction."}
{"text":"Q: What is the purpose of `getTaskDetail(id)` in edit modes? A: It retrieves the existing task’s details (fields, schedule, reminders) so the form can be populated for editing rather than creating a new task."}
{"text":"Q: Why does the component call `getTenantsTaskDetail()` when `isControlOffice` is true? A: Control office users need access to all tenants’ data, so this API fetches tenant information for selection in the form."}
{"text":"Q: How does `getEmployeesByTenant({ keyword, page, tenantId, isCO })` optimize employee loading? A: It performs a paginated, filtered API request to only load relevant employees for the chosen tenant, reducing initial load and supporting search."}
{"text":"Q: Why use `getUsersInTeamByTenants({ teamIds, tenantId, teamCoIds })` in `handleTeamChange`? A: This API fetches the assignees belonging to the selected teams (including control office teams), keeping the assignee list in sync with team selection."}
{"text":"Q: What does `getTeamsForTaskDetail({ tenantId, isCO })` do differently from `getTeamsByUsers`? A: It retrieves all teams available for the given tenant context (rather than just teams assigned to the current user), which is necessary when toggling between team-first and assignee-first workflows."}
{"text":"Q: Why is `getFileByReferenceId({ referenceId, tenantId })` invoked in `getInitialValuesForUpdate`? A: It loads attachments linked to the existing task or series, ensuring file picker displays current files for editing."}
{"text":"Q: How does the component decide between `addTask` and `updateTask` when saving? A: It checks `isAddNew` or `isAddNewSubTask` flags to call `addTask` for new entries and `updateTask` for editing existing ones, matching the correct API endpoint."}
{"text":"Q: Why is `transformParams` used before calling `addTask` or `updateTask`? A: It converts the form’s nested values (like user objects and reminder settings) into a flat payload of IDs and primitives that the backend API expects."}
{"text":"Q: What role does `removeUnnecessaryProperties` play in preparing the API payload? A: It strips out any form fields not required by the API (such as UI-only flags), reducing payload size and preventing backend validation errors."}
{"text":"Q: How does `askOverrideSchedule` integrate with API calls for recurring tasks? A: It prompts the user before calling the API to update a series, ensuring they acknowledge that editing will apply to all occurrences via the API call."}
{"text":"Q: Why wrap the API call in `askOverrideSchedule` callback? A: To defer execution of `updateTask` until the user confirms, preventing unintended overwrites of a task series in the backend."}
{"text":"Q: What error condition is checked before submitting a daily recurrence? A: The code calculates the date range and shows an error toast if it exceeds 90 days, preventing an invalid payload from reaching the API."}
{"text":"Q: How does `setUpApprovals(payload)` differ from a regular update API call? A: It sends pending changes and approval metadata to a dedicated approvals API, triggering a workflow rather than immediately updating the task."}
{"text":"Q: Why is `DeviceEventEmitter.emit('ReloadTM')` called after successful API calls? A: To notify other components (like task lists) to refresh their data from the API, ensuring UI consistency after a change."}
{"text":"Q: Why does the component use `useEffect(() => { initialize(); ... }, []);` with an empty dependency array? A: To perform one-time setup on mount—fetching task settings, property configs, and task details if editing—and to register a cleanup that resets the task detail on unmount, preventing stale data."}
{"text":"Q: What does the `initialize` function inside the first `useEffect` do? A: It calls `getTaskSetting()` and `getTaskPropertyConfig()` to load form configuration, and conditionally calls `getTaskDetail(id)` when in edit mode to populate the form with existing task data."}
{"text":"Q: Why is `getTenantsTaskDetail()` called inside the same `useEffect` only if `isControlOffice` is true? A: Control-office users need access to all tenant records, so that API fetch is triggered once on mount for those users to populate the tenant dropdown."}
{"text":"Q: Why does the second `useEffect` depend on `[isPublic]` and call `onChangeTenantId(tenant)`? A: Whenever the public/site toggle changes, it must re-fetch teams or assignees for the current tenant, so this effect listens to `isPublic` and updates the tenant selection accordingly."}
{"text":"Q: What is the purpose of the `useEffect` watching `[taskDetail]` and calling `formMethods.reset(getInitialValuesForUpdate())`? A: When the API returns new `taskDetail` (e.g., after `getTaskDetail`), this effect resets the form to the fetched values, ensuring the form fields reflect the latest data from the server."}
{"text":"Q: How does the `useEffect` that watches `[reminder?.isActive, assignees]` manage API-driven state? A: It syncs the reminder settings with assignee selection—when reminders are activated or assignees change, it rebuilds the reminder users list and updates the form value, ensuring API payloads include the correct user IDs."}
{"text":"Q: Why is there a `useEffect` listening to `[taskSetting]` that sets initial reminder values? A: After fetching `taskSetting` from the API (which contains default reminder config), this effect initializes the form’s reminder fields—only on create mode—so the UI shows correct defaults."}
{"text":"Q: What does the `useEffect` monitoring `[_.size(files)]` do with API data? A: It watches the number of attached files and, when files change (e.g., after upload or deletion), sets the form’s `files` field to the latest `files` array from the API, keeping attachments in sync."}
{"text":"Q: Why is the form wrapped in <FormProvider {...formMethods}>? A: Wrapping in FormProvider makes the React Hook Form context available to all nested form components so they can register fields, access form state, and trigger validation without prop drilling."}
{"text":"Q: What role does useCompatibleForm({ resolver, defaultValues }) play compared to useForm? A: useCompatibleForm is a custom wrapper around useForm that applies the Yup validation resolver, sets default values, and handles any library compatibility quirks, simplifying setup across components."}
{"text":"Q: How does the Yup resolver integrate with React Hook Form in this code? A: The useYupValidationResolver(validationSchema) hook creates a function that React Hook Form calls to synchronously validate field values against the Yup schema, returning formatted error objects for rendering."}
{"text":"Q: Why are watch(['teamIds','assignees',...]) and array destructuring used? A: watch subscribes to specified fields and returns their current values; destructuring lets you capture multiple watched values in one line and trigger effects when any of them change."}
{"text":"Q: When and why is setValue('reminder', {...}) used? A: setValue is called imperatively inside effects to update complex nested fields (like reminder.users and reminder.userIds) when assignees or reminder activation change, ensuring the form state stays in sync with business logic."}
{"text":"Q: What happens when formMethods.reset(getInitialValuesForUpdate()) is called inside a useEffect? A: Invoking reset replaces all current form values with the object returned by getInitialValuesForUpdate(), reinitializing the form whenever the fetched taskDetail changes (e.g., after loading data in edit mode)."}
{"text":"Q: How does <FieldPrefixProvider prefix=\"TM_FFC_\"> affect form field names? A: FieldPrefixProvider prepends the given prefix to every nested field name, preventing name collisions and allowing dynamic generation of unique field identifiers in configurable forms."}
{"text":"Q: Why use both FormLazyDropdown and FormDropdown components? A: FormLazyDropdown fetches options on demand (useful for large lists like tenants or employees), while FormDropdown uses a preloaded options array; both integrate with React Hook Form via name and internal registration hooks."}
{"text":"Q: What does handleChangeAssignee(value, fromOnChange) do in form handling? A: It maps selected assignees to the internal taskAssigns array, updates reminder users and userIds fields, and optionally marks that reminders should be set up based on the fromOnChange flag."}
{"text":"Q: How does handleTeamChange(selectedTeams, selectedTenant) affect form values? A: It clears current assignees, fetches new users via getUsersInTeamByTenants for the selected teams, and updates the form's teams and users dropdowns based on the API response."}
{"text":"Q: Why wrap the save logic with formMethods.handleSubmit(handleSave)? A: handleSubmit performs validation according to the Yup schema and prevents calling handleSave unless the form data is valid, ensuring the payload meets required constraints."}
{"text":"Q: What is the role of FormDisabledProvider around the form? A: It disables all nested form inputs when isReadOnly is true, preventing edits by users without update permission and visually indicating non-editable state."}
{"text":"Q: How does the Submit button trigger form submission? A: The button’s onPress calls attemptSave, which runs the HOC’s approval logic before invoking formMethods.handleSubmit(handleSave) to perform validation and API submission."}
{"text":"Q: What does submitRecurrence(recurrence, isInit) do in RecurrenceSetting? A: It sets the form’s recurrence value and the isCurrentSchedule flag based on whether it’s the initial load or a user change, enabling the schedule UI and controlling override behavior on save."}
{"text":"Q: What does removeRecurrence() do? A: It sets isRemoveRecurrence to true and clears the recurrence value, marking the form to remove any existing schedule when saving."}
{"text":"Q: How do Reminder’s onActivateReminder and onChange callbacks work? A: onActivateReminder flips the allowSetUpReminder flag causing the reminder effect to sync users, while onChange(reminderData) updates the form’s nested reminder fields directly based on user input."}
{"text":"Q: Why are setTimeStart(startDate) and setTimeEnd(endDate) used before saving? A: They normalize dates to the start and end of day respectively, ensuring the schedule payload covers full-day ranges for recurring tasks."}
{"text":"Q: How does attemptSave integrate with ApprovalModal? A: attemptSave wraps handleSubmit(handleSave) and, if approvals are required, triggers the ApprovalModal flow before final submission, ensuring change requests go through the approval process."}
{"text":"Q: What happens in handleApprove(userApprovals)? A: handleApprove builds an approvals payload with levels and pending changes, calls setUpApprovals, resets the form changes, and re-submits the save with approved values."}
{"text":"Q: How does askOverrideSchedule(callback) affect saving recurring tasks? A: It shows a confirmation alert to the user and only invokes the provided callback if the user confirms, preventing unintentional overwriting of all occurrences in a series."}
{"text":"Q: What is handlerMap.date(v) used for? A: It formats a date value using formatDate and the fullDateTimeFormat locale, or returns v unchanged if falsy."}
{"text":"Q: How does handlerMap.ids(values, options, labelField) format multiple IDs? A: It maps each ID to its corresponding labelField in options, filters out missing labels, and joins them with commas, falling back to joining raw values if needed."}
{"text":"Q: What does handlerMap.dropdown(v) handle? A: It joins an array of dropdown items’ displayName properties into a comma-separated string or returns the value if it’s not an array."}
{"text":"Q: What does the approvalFields array represent? A: It lists the fieldNames from config that have isAllowApprove=true, indicating which form fields require approval on change."}
{"text":"Q: Why use useMemo for pendingMap? A: To efficiently compute a map of pending changes only when detailInfo or fieldsChange change, avoiding unnecessary recalculations on every render."}
{"text":"Q: How are oldValue and newValue determined in pendingMap? A: For each changed field, the code retrieves raw values from detailInfo or fieldsChange, applies the handler if available, and stores both the original and formatted values."}
{"text":"Q: What does the useEffect with watch subscription do? A: It listens to form field changes for approvalFields and updates fieldsChange state whenever a tracked field changes, so pendingMap can detect these changes."}
{"text":"Q: How does attemptSave decide between opening the approval modal and submitting? A: It checks if any changed fieldNames require approval by comparing fieldsChange keys against config, then shows the modal if needed or calls submit() directly."}
{"text":"Q: What does setApprovalModalVisible control? A: It toggles the visibility of the ApprovalModal, allowing the UI to display or hide the modal when approvals are needed."}
{"text":"Q: What is the purpose of FormFieldConfigurable? A: It wraps form fields to inject config-based props (required, disabled, editable) and displays pending changes inline by matching config keys to child components."}
{"text":"Q: How does FormFieldConfigurable determine which fields to configure? A: It uses each child’s fieldKey prop (or label) to look up a matching config item by key, then applies isMandatory and isEditable flags accordingly."}
{"text":"Q: What does updateFieldNameConfig(match) do? A: It records the field’s metadata (including its fieldName) in an external map so other logic (like approval handling) knows which fields to watch."}
{"text":"Q: How are pendingMap entries rendered? A: If pendingMap contains an entry for a child’s name, the component clones the child with its oldValue and renders the pending newValue in red underneath."}
{"text":"Q: How does disableApprovals affect field behavior? A: When disableApprovals is true, any config items with isAllowApprove=true get forced disabled, preventing edits until approvals are cleared."}
{"text":"Q: Why use React.cloneElement and React.Children.map? A: cloneElement lets you apply new props to a child element, while Children.map ensures nested children are processed recursively for deep configurations."}
{"text":"Q: What Role do PropTypes play here? A: They enforce at runtime that config is an array of properly shaped objects and that the component receives valid children and flags, helping catch misuses early."}
{"text":"Q: Why does Reminder use useCompatibleForm with defaultValues? A: It initializes the React Hook Form with both the incoming initialValues and default placeholders (newReminderBefore/After), ensuring controlled inputs have proper starting state."}
{"text":"Q: How does the empty-deps useEffect fetching employees work? A: The effect with `[]` dependencies calls `getEmployees({page:1})` once on mount to load the user list for the dropdown."}
{"text":"Q: What does the useEffect watching [initialValues] do? A: When `initialValues` prop changes (e.g. editing existing reminders), it resets all form fields to those values via `formMethods.reset`."}
{"text":"Q: How does the timeUnitSuffix effect update labels? A: It listens to `configure.timeUnit` and sets `timeUnitSuffix` to the correct localized string (days, hours, or minutes) whenever that prop changes."}
{"text":"Q: What do convertToMinutes(value) and convertMinutesToUnit(minutes) do? A: They convert between the configured unit (days/hours/minutes) and raw minutes for storage, allowing the UI to show human-friendly units but keep a consistent minute-based payload."}
{"text":"Q: How does addReminder(type) manage new reminder entries? A: It reads the raw input, converts it to minutes, prevents duplicates with an error, then appends and sorts the reminders array before clearing the input field."}
{"text":"Q: How are emails validated and added? A: onCheckEmail runs `validateEmail`, shows an error toast if invalid, otherwise calls addEmailAndResetInput to push the new address into the emails array and clear the input."}
{"text":"Q: How does the watch-subscription effect notify the parent? A: A useEffect subscribes to all form value changes via `watch`, and on each change it calls `onChange(value)` so the parent always has the latest reminder state."}
{"text":"Q: Why wrap everything in <FormProvider {...formMethods}>? A: To supply the RHF context (methods, state, watch, setValue) to all nested form components (inputs, dropdowns, switches) without prop drilling."}
{"text":"Q: How are removeEmail and handleRemove(type, index) implemented? A: removeEmail filters out a single address from `emails`, while handleRemove filters out a selected minute value from either the before or after reminders list."}
{"text":"Q: What is the purpose of FieldPrefixProvider? A: It automatically prefixes form field labels and placeholders based on a given prefix, reducing manual prop management for internationalization or naming conventions."}
{"text":"Q: How does FieldPrefixProvider determine which fields to prefix? A: It uses each child’s fieldKey prop or its original label string to compute the base key, skipping any keys listed in the excludeKeys array."}
{"text":"Q: When does FieldPrefixProvider skip prefixing? A: If the baseKey is missing, if it’s included in excludeKeys, or if the label already starts with the prefix, the provider leaves props unchanged."}
{"text":"Q: How are placeholders handled when prefixing? A: If a child’s original placeholder matches its label, the provider mirrors the new prefixed label as the placeholder; otherwise, it preserves any custom placeholder."}
{"text":"Q: Why use React.cloneElement and recursion? A: cloneElement lets the provider inject new props into each element, and recursion via React.Children.map ensures nested children also receive prefixing where appropriate."}
{"text":"Q: What is the role of RecurrenceSetting? A: It displays the current recurrence summary via InfoText and toggles the visibility of ConfigRecurrenceModal when the user taps it."}
{"text":"Q: How does RecurrenceSetting read the current recurrence value? A: It uses useCommonFormController('recurrence') to subscribe to the RHF form context and extract the 'recurrence' field’s current value."}
{"text":"Q: Why does RecurrenceSetting compute color from value? A: It uses Colors.text if a recurrence exists or Colors.placeholder if not, visually indicating to the user whether a selection has been made."}
{"text":"Q: What props does RecurrenceSetting pass to ConfigRecurrenceModal? A: It forwards schedule, onSubmitForm, onRemove, showDuration, and visible/onClose handlers to control modal behavior."}
{"text":"Q: Why does ConfigRecurrenceModal build frequencyOptions and related arrays? A: To provide dropdown choices for daily, weekly, monthly, and yearly frequencies, as well as sub-options like days-of-week and ordinal positions."}
{"text":"Q: What default form state does ConfigRecurrenceModal initialize? A: It sets a defaultValues object including frequency=daily, every='1', empty dayOfWeeks, onType=first daily type, startTime=9 AM, durations=30, today’s date as startDate, undefined endDate, and isNearestWeekday=false."}
{"text":"Q: How does transformFromCronExpression work? A: It splits the cronExpression string, extracts fields (dayOfMonth, month, dayOfWeek), determines the recurrence frequency, and maps those pieces into the form schema object."}
{"text":"Q: Why use useEffect(() => {...}, [schedule]) with isInitial? A: When schedule prop first arrives and isInitial is false, it transforms and resets the form to the existing schedule, calls onSubmit for initial load, then sets isInitial=true to avoid re-running."}
{"text":"Q: What does handleRemove do in ConfigRecurrenceModal? A: It displays a confirmation Alert; if the user confirms, it calls onRemove(), resets the form to initialValues, and closes the modal."}
{"text":"Q: How is transformToCronExpression implemented? A: It reconstructs a cron expression string from form inputs (frequency, onDay, every, dayOfWeeks, startTime, isNearestWeekday) to send back to the server."}
{"text":"Q: What helper functions support cron transformation? A: checkCronValueBlank checks for '*' or '0'; parseZeroTime converts '00' to '0'; term and sanitizeInput strip trailing punctuation from numeric inputs."}
{"text":"Q: How does onChangeDay(text, key, nestedKey) update nested form values? A: It sanitizes the input text, then either sets a top-level field or updates a nested property (like onDay.name) using RHF’s setFieldValue."}
{"text":"Q: How is the Accept button enabled or disabled? A: disabledBtn is true if endDate is missing, required onDay or dayOfWeeks aren’t selected based on frequency, or durations is missing when showDuration=true, preventing invalid submissions."}
{"text":"Q: Why wrap form fields in <FormProvider>? A: To supply formMethods (including watch, setFieldValue, handleSubmit) to nested FormInput, FormDropdown, FormDate, and FormCheckBox components without prop drilling."}
{"text":"Q: How does ConfigRecurrenceModal handle submission? A: The primary button calls handleSubmit(onSubmit), which transforms form params to cronExpression, resets the form, closes the modal, and calls onSubmitForm(params, isInit)."}  
{"text":"Q: What is the purpose of ApprovalSection? A: It renders Approve/Reject buttons for the current user when they have a pending approval entry and all earlier approval levels are completed."}
{"text":"Q: How does ApprovalSection determine the current user’s approval entry? A: It finds the entry in jrDetail.workOrderApprovalMatrixs where approverUserId matches the logged-in user’s ID."}
{"text":"Q: What does prevLevelsApproved check? A: It verifies that every matrix entry with a lower level than the current user’s entry has isApproved=true, ensuring approvals happen in order."}
{"text":"Q: Why does ApprovalSection return null in some cases? A: It hides the section if the user has no entry (myEntry), previous levels aren’t all approved, or the user’s entry is already approved (myEntry.isApproved)."}
{"text":"Q: What does handleDecision(isApprove) do? A: It shows a confirmation Alert; on confirm it builds a payload (including optional rejectionReason), calls approveChange or rejectChange, emits a reload event, and navigates back."}
{"text":"Q: Why use Alert.alert before calling approveChange/rejectChange? A: To prompt the user for confirmation and prevent accidental approvals or rejections."}
{"text":"Q: What is DeviceEventEmitter.emit('UpdateListWorkOrder') for? A: It notifies other parts of the app (such as a job request list) to refresh their data after an approval decision."}
{"text":"Q: How does NavigationService.goBack() integrate here? A: After the approval API call and event emission, it navigates back to the previous screen, closing the current detail view."}
{"text":"Q: Why wrap buttons in styled components ApproverRow and ApproverButton? A: To apply consistent layout, spacing, and alignment via styled-components, keeping presentation concerns separate from logic."}
{"text":"Q: How are RejectLabel and ApproveLabel styled? A: They use Text components with colors set to Colors.red and Colors.success respectively, visually indicating the action type."}
