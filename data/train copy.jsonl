{"text":"Q: Why are `getTaskSetting` and `getTaskPropertyConfig` called immediately in the initialization effect? A: These API calls fetch configuration data (like reminder defaults and dynamic form field settings) needed to render the form correctly before any user interaction."}
{"text":"Q: What is the purpose of `getTaskDetail(id)` in edit modes? A: It retrieves the existing task’s details (fields, schedule, reminders) so the form can be populated for editing rather than creating a new task."}
{"text":"Q: Why does the component call `getTenantsTaskDetail()` when `isControlOffice` is true? A: Control office users need access to all tenants’ data, so this API fetches tenant information for selection in the form."}
{"text":"Q: How does `getEmployeesByTenant({ keyword, page, tenantId, isCO })` optimize employee loading? A: It performs a paginated, filtered API request to only load relevant employees for the chosen tenant, reducing initial load and supporting search."}
{"text":"Q: Why use `getUsersInTeamByTenants({ teamIds, tenantId, teamCoIds })` in `handleTeamChange`? A: This API fetches the assignees belonging to the selected teams (including control office teams), keeping the assignee list in sync with team selection."}
{"text":"Q: What does `getTeamsForTaskDetail({ tenantId, isCO })` do differently from `getTeamsByUsers`? A: It retrieves all teams available for the given tenant context (rather than just teams assigned to the current user), which is necessary when toggling between team-first and assignee-first workflows."}
{"text":"Q: Why is `getFileByReferenceId({ referenceId, tenantId })` invoked in `getInitialValuesForUpdate`? A: It loads attachments linked to the existing task or series, ensuring file picker displays current files for editing."}
{"text":"Q: How does the component decide between `addTask` and `updateTask` when saving? A: It checks `isAddNew` or `isAddNewSubTask` flags to call `addTask` for new entries and `updateTask` for editing existing ones, matching the correct API endpoint."}
{"text":"Q: Why is `transformParams` used before calling `addTask` or `updateTask`? A: It converts the form’s nested values (like user objects and reminder settings) into a flat payload of IDs and primitives that the backend API expects."}
{"text":"Q: What role does `removeUnnecessaryProperties` play in preparing the API payload? A: It strips out any form fields not required by the API (such as UI-only flags), reducing payload size and preventing backend validation errors."}
{"text":"Q: How does `askOverrideSchedule` integrate with API calls for recurring tasks? A: It prompts the user before calling the API to update a series, ensuring they acknowledge that editing will apply to all occurrences via the API call."}
{"text":"Q: Why wrap the API call in `askOverrideSchedule` callback? A: To defer execution of `updateTask` until the user confirms, preventing unintended overwrites of a task series in the backend."}
{"text":"Q: What error condition is checked before submitting a daily recurrence? A: The code calculates the date range and shows an error toast if it exceeds 90 days, preventing an invalid payload from reaching the API."}
{"text":"Q: How does `setUpApprovals(payload)` differ from a regular update API call? A: It sends pending changes and approval metadata to a dedicated approvals API, triggering a workflow rather than immediately updating the task."}
{"text":"Q: Why is `DeviceEventEmitter.emit('ReloadTM')` called after successful API calls? A: To notify other components (like task lists) to refresh their data from the API, ensuring UI consistency after a change."}
{"text":"Q: Why does the component use `useEffect(() => { initialize(); ... }, []);` with an empty dependency array? A: To perform one-time setup on mount—fetching task settings, property configs, and task details if editing—and to register a cleanup that resets the task detail on unmount, preventing stale data."}
{"text":"Q: What does the `initialize` function inside the first `useEffect` do? A: It calls `getTaskSetting()` and `getTaskPropertyConfig()` to load form configuration, and conditionally calls `getTaskDetail(id)` when in edit mode to populate the form with existing task data."}
{"text":"Q: Why is `getTenantsTaskDetail()` called inside the same `useEffect` only if `isControlOffice` is true? A: Control-office users need access to all tenant records, so that API fetch is triggered once on mount for those users to populate the tenant dropdown."}
{"text":"Q: Why does the second `useEffect` depend on `[isPublic]` and call `onChangeTenantId(tenant)`? A: Whenever the public/site toggle changes, it must re-fetch teams or assignees for the current tenant, so this effect listens to `isPublic` and updates the tenant selection accordingly."}
{"text":"Q: What is the purpose of the `useEffect` watching `[taskDetail]` and calling `formMethods.reset(getInitialValuesForUpdate())`? A: When the API returns new `taskDetail` (e.g., after `getTaskDetail`), this effect resets the form to the fetched values, ensuring the form fields reflect the latest data from the server."}
{"text":"Q: How does the `useEffect` that watches `[reminder?.isActive, assignees]` manage API-driven state? A: It syncs the reminder settings with assignee selection—when reminders are activated or assignees change, it rebuilds the reminder users list and updates the form value, ensuring API payloads include the correct user IDs."}
{"text":"Q: Why is there a `useEffect` listening to `[taskSetting]` that sets initial reminder values? A: After fetching `taskSetting` from the API (which contains default reminder config), this effect initializes the form’s reminder fields—only on create mode—so the UI shows correct defaults."}
{"text":"Q: What does the `useEffect` monitoring `[_.size(files)]` do with API data? A: It watches the number of attached files and, when files change (e.g., after upload or deletion), sets the form’s `files` field to the latest `files` array from the API, keeping attachments in sync."}
{"text":"Q: Why is the form wrapped in <FormProvider {...formMethods}>? A: Wrapping in FormProvider makes the React Hook Form context available to all nested form components so they can register fields, access form state, and trigger validation without prop drilling."}
{"text":"Q: What role does useCompatibleForm({ resolver, defaultValues }) play compared to useForm? A: useCompatibleForm is a custom wrapper around useForm that applies the Yup validation resolver, sets default values, and handles any library compatibility quirks, simplifying setup across components."}
{"text":"Q: How does the Yup resolver integrate with React Hook Form in this code? A: The useYupValidationResolver(validationSchema) hook creates a function that React Hook Form calls to synchronously validate field values against the Yup schema, returning formatted error objects for rendering."}
{"text":"Q: Why are watch(['teamIds','assignees',...]) and array destructuring used? A: watch subscribes to specified fields and returns their current values; destructuring lets you capture multiple watched values in one line and trigger effects when any of them change."}
{"text":"Q: When and why is setValue('reminder', {...}) used? A: setValue is called imperatively inside effects to update complex nested fields (like reminder.users and reminder.userIds) when assignees or reminder activation change, ensuring the form state stays in sync with business logic."}
{"text":"Q: What happens when formMethods.reset(getInitialValuesForUpdate()) is called inside a useEffect? A: Invoking reset replaces all current form values with the object returned by getInitialValuesForUpdate(), reinitializing the form whenever the fetched taskDetail changes (e.g., after loading data in edit mode)."}
{"text":"Q: How does <FieldPrefixProvider prefix=\"TM_FFC_\"> affect form field names? A: FieldPrefixProvider prepends the given prefix to every nested field name, preventing name collisions and allowing dynamic generation of unique field identifiers in configurable forms."}
{"text":"Q: Why use both FormLazyDropdown and FormDropdown components? A: FormLazyDropdown fetches options on demand (useful for large lists like tenants or employees), while FormDropdown uses a preloaded options array; both integrate with React Hook Form via name and internal registration hooks."}
{"text":"Q: What does handleChangeAssignee(value, fromOnChange) do in form handling? A: It maps selected assignees to the internal taskAssigns array, updates reminder users and userIds fields, and optionally marks that reminders should be set up based on the fromOnChange flag."}
{"text":"Q: How does handleTeamChange(selectedTeams, selectedTenant) affect form values? A: It clears current assignees, fetches new users via getUsersInTeamByTenants for the selected teams, and updates the form's teams and users dropdowns based on the API response."}
{"text":"Q: Why wrap the save logic with formMethods.handleSubmit(handleSave)? A: handleSubmit performs validation according to the Yup schema and prevents calling handleSave unless the form data is valid, ensuring the payload meets required constraints."}
{"text":"Q: What is the role of FormDisabledProvider around the form? A: It disables all nested form inputs when isReadOnly is true, preventing edits by users without update permission and visually indicating non-editable state."}
{"text":"Q: How does the Submit button trigger form submission? A: The button’s onPress calls attemptSave, which runs the HOC’s approval logic before invoking formMethods.handleSubmit(handleSave) to perform validation and API submission."}
{"text":"Q: What does submitRecurrence(recurrence, isInit) do in RecurrenceSetting? A: It sets the form’s recurrence value and the isCurrentSchedule flag based on whether it’s the initial load or a user change, enabling the schedule UI and controlling override behavior on save."}
{"text":"Q: What does removeRecurrence() do? A: It sets isRemoveRecurrence to true and clears the recurrence value, marking the form to remove any existing schedule when saving."}
{"text":"Q: How do Reminder’s onActivateReminder and onChange callbacks work? A: onActivateReminder flips the allowSetUpReminder flag causing the reminder effect to sync users, while onChange(reminderData) updates the form’s nested reminder fields directly based on user input."}
{"text":"Q: Why are setTimeStart(startDate) and setTimeEnd(endDate) used before saving? A: They normalize dates to the start and end of day respectively, ensuring the schedule payload covers full-day ranges for recurring tasks."}
{"text":"Q: How does attemptSave integrate with ApprovalModal? A: attemptSave wraps handleSubmit(handleSave) and, if approvals are required, triggers the ApprovalModal flow before final submission, ensuring change requests go through the approval process."}
{"text":"Q: What happens in handleApprove(userApprovals)? A: handleApprove builds an approvals payload with levels and pending changes, calls setUpApprovals, resets the form changes, and re-submits the save with approved values."}
{"text":"Q: How does askOverrideSchedule(callback) affect saving recurring tasks? A: It shows a confirmation alert to the user and only invokes the provided callback if the user confirms, preventing unintentional overwriting of all occurrences in a series."}
{"text":"Q: What is handlerMap.date(v) used for? A: It formats a date value using formatDate and the fullDateTimeFormat locale, or returns v unchanged if falsy."}
{"text":"Q: How does handlerMap.ids(values, options, labelField) format multiple IDs? A: It maps each ID to its corresponding labelField in options, filters out missing labels, and joins them with commas, falling back to joining raw values if needed."}
{"text":"Q: What does handlerMap.dropdown(v) handle? A: It joins an array of dropdown items’ displayName properties into a comma-separated string or returns the value if it’s not an array."}
{"text":"Q: What does the approvalFields array represent? A: It lists the fieldNames from config that have isAllowApprove=true, indicating which form fields require approval on change."}
{"text":"Q: Why use useMemo for pendingMap? A: To efficiently compute a map of pending changes only when detailInfo or fieldsChange change, avoiding unnecessary recalculations on every render."}
{"text":"Q: How are oldValue and newValue determined in pendingMap? A: For each changed field, the code retrieves raw values from detailInfo or fieldsChange, applies the handler if available, and stores both the original and formatted values."}
{"text":"Q: What does the useEffect with watch subscription do? A: It listens to form field changes for approvalFields and updates fieldsChange state whenever a tracked field changes, so pendingMap can detect these changes."}
{"text":"Q: How does attemptSave decide between opening the approval modal and submitting? A: It checks if any changed fieldNames require approval by comparing fieldsChange keys against config, then shows the modal if needed or calls submit() directly."}
{"text":"Q: What does setApprovalModalVisible control? A: It toggles the visibility of the ApprovalModal, allowing the UI to display or hide the modal when approvals are needed."}
{"text":"Q: What is the purpose of FormFieldConfigurable? A: It wraps form fields to inject config-based props (required, disabled, editable) and displays pending changes inline by matching config keys to child components."}
{"text":"Q: How does FormFieldConfigurable determine which fields to configure? A: It uses each child’s fieldKey prop (or label) to look up a matching config item by key, then applies isMandatory and isEditable flags accordingly."}
{"text":"Q: What does updateFieldNameConfig(match) do? A: It records the field’s metadata (including its fieldName) in an external map so other logic (like approval handling) knows which fields to watch."}
{"text":"Q: How are pendingMap entries rendered? A: If pendingMap contains an entry for a child’s name, the component clones the child with its oldValue and renders the pending newValue in red underneath."}
{"text":"Q: How does disableApprovals affect field behavior? A: When disableApprovals is true, any config items with isAllowApprove=true get forced disabled, preventing edits until approvals are cleared."}
{"text":"Q: Why use React.cloneElement and React.Children.map? A: cloneElement lets you apply new props to a child element, while Children.map ensures nested children are processed recursively for deep configurations."}
{"text":"Q: What Role do PropTypes play here? A: They enforce at runtime that config is an array of properly shaped objects and that the component receives valid children and flags, helping catch misuses early."}
{"text":"Q: Why does Reminder use useCompatibleForm with defaultValues? A: It initializes the React Hook Form with both the incoming initialValues and default placeholders (newReminderBefore/After), ensuring controlled inputs have proper starting state."}
{"text":"Q: How does the empty-deps useEffect fetching employees work? A: The effect with `[]` dependencies calls `getEmployees({page:1})` once on mount to load the user list for the dropdown."}
{"text":"Q: What does the useEffect watching [initialValues] do? A: When `initialValues` prop changes (e.g. editing existing reminders), it resets all form fields to those values via `formMethods.reset`."}
{"text":"Q: How does the timeUnitSuffix effect update labels? A: It listens to `configure.timeUnit` and sets `timeUnitSuffix` to the correct localized string (days, hours, or minutes) whenever that prop changes."}
{"text":"Q: What do convertToMinutes(value) and convertMinutesToUnit(minutes) do? A: They convert between the configured unit (days/hours/minutes) and raw minutes for storage, allowing the UI to show human-friendly units but keep a consistent minute-based payload."}
{"text":"Q: How does addReminder(type) manage new reminder entries? A: It reads the raw input, converts it to minutes, prevents duplicates with an error, then appends and sorts the reminders array before clearing the input field."}
{"text":"Q: How are emails validated and added? A: onCheckEmail runs `validateEmail`, shows an error toast if invalid, otherwise calls addEmailAndResetInput to push the new address into the emails array and clear the input."}
{"text":"Q: How does the watch-subscription effect notify the parent? A: A useEffect subscribes to all form value changes via `watch`, and on each change it calls `onChange(value)` so the parent always has the latest reminder state."}
{"text":"Q: Why wrap everything in <FormProvider {...formMethods}>? A: To supply the RHF context (methods, state, watch, setValue) to all nested form components (inputs, dropdowns, switches) without prop drilling."}
{"text":"Q: How are removeEmail and handleRemove(type, index) implemented? A: removeEmail filters out a single address from `emails`, while handleRemove filters out a selected minute value from either the before or after reminders list."}
{"text":"Q: What is the purpose of FieldPrefixProvider? A: It automatically prefixes form field labels and placeholders based on a given prefix, reducing manual prop management for internationalization or naming conventions."}
{"text":"Q: How does FieldPrefixProvider determine which fields to prefix? A: It uses each child’s fieldKey prop or its original label string to compute the base key, skipping any keys listed in the excludeKeys array."}
{"text":"Q: When does FieldPrefixProvider skip prefixing? A: If the baseKey is missing, if it’s included in excludeKeys, or if the label already starts with the prefix, the provider leaves props unchanged."}
{"text":"Q: How are placeholders handled when prefixing? A: If a child’s original placeholder matches its label, the provider mirrors the new prefixed label as the placeholder; otherwise, it preserves any custom placeholder."}
{"text":"Q: Why use React.cloneElement and recursion? A: cloneElement lets the provider inject new props into each element, and recursion via React.Children.map ensures nested children also receive prefixing where appropriate."}
{"text":"Q: What is the role of RecurrenceSetting? A: It displays the current recurrence summary via InfoText and toggles the visibility of ConfigRecurrenceModal when the user taps it."}
{"text":"Q: How does RecurrenceSetting read the current recurrence value? A: It uses useCommonFormController('recurrence') to subscribe to the RHF form context and extract the 'recurrence' field’s current value."}
{"text":"Q: Why does RecurrenceSetting compute color from value? A: It uses Colors.text if a recurrence exists or Colors.placeholder if not, visually indicating to the user whether a selection has been made."}
{"text":"Q: What props does RecurrenceSetting pass to ConfigRecurrenceModal? A: It forwards schedule, onSubmitForm, onRemove, showDuration, and visible/onClose handlers to control modal behavior."}
{"text":"Q: Why does ConfigRecurrenceModal build frequencyOptions and related arrays? A: To provide dropdown choices for daily, weekly, monthly, and yearly frequencies, as well as sub-options like days-of-week and ordinal positions."}
{"text":"Q: What default form state does ConfigRecurrenceModal initialize? A: It sets a defaultValues object including frequency=daily, every='1', empty dayOfWeeks, onType=first daily type, startTime=9 AM, durations=30, today’s date as startDate, undefined endDate, and isNearestWeekday=false."}
{"text":"Q: How does transformFromCronExpression work? A: It splits the cronExpression string, extracts fields (dayOfMonth, month, dayOfWeek), determines the recurrence frequency, and maps those pieces into the form schema object."}
{"text":"Q: Why use useEffect(() => {...}, [schedule]) with isInitial? A: When schedule prop first arrives and isInitial is false, it transforms and resets the form to the existing schedule, calls onSubmit for initial load, then sets isInitial=true to avoid re-running."}
{"text":"Q: What does handleRemove do in ConfigRecurrenceModal? A: It displays a confirmation Alert; if the user confirms, it calls onRemove(), resets the form to initialValues, and closes the modal."}
{"text":"Q: How is transformToCronExpression implemented? A: It reconstructs a cron expression string from form inputs (frequency, onDay, every, dayOfWeeks, startTime, isNearestWeekday) to send back to the server."}
{"text":"Q: What helper functions support cron transformation? A: checkCronValueBlank checks for '*' or '0'; parseZeroTime converts '00' to '0'; term and sanitizeInput strip trailing punctuation from numeric inputs."}
{"text":"Q: How does onChangeDay(text, key, nestedKey) update nested form values? A: It sanitizes the input text, then either sets a top-level field or updates a nested property (like onDay.name) using RHF’s setFieldValue."}
{"text":"Q: How is the Accept button enabled or disabled? A: disabledBtn is true if endDate is missing, required onDay or dayOfWeeks aren’t selected based on frequency, or durations is missing when showDuration=true, preventing invalid submissions."}
{"text":"Q: Why wrap form fields in <FormProvider>? A: To supply formMethods (including watch, setFieldValue, handleSubmit) to nested FormInput, FormDropdown, FormDate, and FormCheckBox components without prop drilling."}
{"text":"Q: How does ConfigRecurrenceModal handle submission? A: The primary button calls handleSubmit(onSubmit), which transforms form params to cronExpression, resets the form, closes the modal, and calls onSubmitForm(params, isInit)."}  
{"text":"Q: What is the purpose of ApprovalSection? A: It renders Approve/Reject buttons for the current user when they have a pending approval entry and all earlier approval levels are completed."}
{"text":"Q: How does ApprovalSection determine the current user’s approval entry? A: It finds the entry in jrDetail.workOrderApprovalMatrixs where approverUserId matches the logged-in user’s ID."}
{"text":"Q: What does prevLevelsApproved check? A: It verifies that every matrix entry with a lower level than the current user’s entry has isApproved=true, ensuring approvals happen in order."}
{"text":"Q: Why does ApprovalSection return null in some cases? A: It hides the section if the user has no entry (myEntry), previous levels aren’t all approved, or the user’s entry is already approved (myEntry.isApproved)."}
{"text":"Q: What does handleDecision(isApprove) do? A: It shows a confirmation Alert; on confirm it builds a payload (including optional rejectionReason), calls approveChange or rejectChange, emits a reload event, and navigates back."}
{"text":"Q: Why use Alert.alert before calling approveChange/rejectChange? A: To prompt the user for confirmation and prevent accidental approvals or rejections."}
{"text":"Q: What is DeviceEventEmitter.emit('UpdateListWorkOrder') for? A: It notifies other parts of the app (such as a job request list) to refresh their data after an approval decision."}
{"text":"Q: How does NavigationService.goBack() integrate here? A: After the approval API call and event emission, it navigates back to the previous screen, closing the current detail view."}
{"text":"Q: Why wrap buttons in styled components ApproverRow and ApproverButton? A: To apply consistent layout, spacing, and alignment via styled-components, keeping presentation concerns separate from logic."}
{"text":"Q: How are RejectLabel and ApproveLabel styled? A: They use Text components with colors set to Colors.red and Colors.success respectively, visually indicating the action type."}

{"text": "API Handler Wrappers"}
{"text":"Q: Why wrap RequestApi calls in individual async functions in the hook? A: To encapsulate each API endpoint behind a named method, allowing handler wrappers to uniformly manage side effects and dispatch actions."}
{"text":"Q: How does withErrorHandling enhance getPriorityList? A: It dispatches GET_PRIORITY_LIST.REQUEST before the call, then GET_PRIORITY_LIST.SUCCESS or GET_PRIORITY_LIST.FAILURE after, centralizing error dispatch without loading states."}
{"text":"Q: What additional behavior does withLoadingAndErrorHandling add for addTask? A: It also dispatches loading state actions (e.g., SET_LOADING) around the API call so the UI can show spinners while the request is in progress."}
{"text":"Q: Why import useHandlerAction alongside useStateValue? A: useHandlerAction provides the handler wrappers (withErrorHandling, withLoadingAndErrorHandling) that bind API methods to Redux action lifecycles."}
{"text":"Q: How does generateAction facilitate consistent action type creation? A: It takes a base string (e.g., 'taskManagement/GET_TASK_LIST') and returns .REQUEST, .SUCCESS, and .FAILURE constants automatically."}
{"text":"Q: Why include RequestApi.getTMTeamList in getTeamsByTenant? A: To call the shared team-list endpoint with specific params (target:'TaskManagement', isActive:true) while letting the wrapper manage dispatch."}
{"text":"Q: How does getMentionUsers leverage both transformMentionUsers and getCacheKey? A: The async method returns a structured object so the handler can dispatch GET_MENTION_USER.SUCCESS with both data and cache key for the reducer."}
{"text":"Q: What does getTaskList(params) wrap? A: It wraps RequestApi.getTaskList(params) to fetch a paginated list of tasks and returns the response."}
{"text":"Q: What does getPriorityList() wrap? A: It wraps RequestApi.getPriorityList() to retrieve the priority options for tasks and returns the response."}
{"text":"Q: What does getTeamsByTenant(params) wrap? A: It wraps RequestApi.getTMTeamList({ ...params, target:'TaskManagement', isActive:true }) to fetch active teams for a given tenant."}
{"text":"Q: What does getCurrentTeamList() wrap? A: It wraps RequestApi.getCurrentTeamList() to fetch teams assigned to the current user context."}
{"text":"Q: What does getAssigneeList(params) wrap? A: It wraps RequestApi.getUsersInTeamByTenant(params) to fetch users for a specific team and returns the response."}
{"text":"Q: What does getUsersInTeamByTenants(params) wrap? A: It wraps RequestApi.getUsersInTeamByTenants(params) to fetch users across multiple teams in one call."}
{"text":"Q: What does getTaskDetail(taskId) wrap? A: It wraps RequestApi.getTaskDetail(taskId) to fetch detailed information for a single task by its ID."}
{"text":"Q: What does addTask(payload) wrap? A: It wraps RequestApi.addTask or RequestApi.addTaskWithSchedule based on payload.schedule, then handles file uploads and navigation."}
{"text":"Q: What does updateTask(payload) wrap? A: It wraps RequestApi.updateTask or RequestApi.updateTaskWithSchedule based on payload.isSeries, then handles file uploads and navigation."}
{"text":"Q: What does getStatusList() wrap? A: It wraps RequestApi.getStatusList() to retrieve the status options for tasks and returns the response."}
{"text":"Q: What does addComment(params) wrap? A: It wraps RequestApi.addComment(params) to submit a new comment for a task and returns the response."}
{"text":"Q: What does getCommentByTask(params) wrap? A: It wraps RequestApi.getCommentByTask(params) to fetch comments for a given task and returns the response."}
{"text":"Q: What does getEmployeesByTenant(params) wrap? A: It wraps RequestApi.getListEmployeesByTenant(params) to fetch a paginated list of employees for a tenant."}
{"text":"Q: What does getTeamsForTaskDetail(params) wrap? A: It wraps RequestApi.getTMTeamList({ ...params, target:'TaskManagement', isActive:true }) to fetch teams related to an existing task."}
{"text":"Q: What does getTenantsTaskDetail(params) wrap? A: It wraps RequestApi.getTenantList({ ...params, editionIdSpecified:false, skipCount:0 }) to fetch the list of tenants."}
{"text":"Q: What does getTaskSetting() wrap? A: It wraps RequestApi.getTaskSetting() to fetch configuration settings for tasks, like default reminder intervals."}
{"text":"Q: What does getFileByReferenceId(params) wrap? A: It wraps RequestApi.getTaskFileReference(params) to fetch files attached to a task or schedule document by referenceId."}
{"text":"Q: What does setUpApprovals(params) wrap? A: It wraps RequestApi.setUpAprrovals(params) to submit pending changes for approval workflow initiation."}
{"text":"Q: What does approveChange(params) wrap? A: It wraps RequestApi.approveChange(params) to record an approval decision for a pending change."}
{"text":"Q: What does rejectChange(params) wrap? A: It wraps RequestApi.rejectChange(params) to record a rejection decision, including an optional rejectionReason."}
{"text":"Q: What does getTaskPropertyConfig() wrap? A: It wraps RequestApi.getTaskPropertyConfig() to fetch dynamic form field configurations for tasks."}
{"text": "Action & Saga Integration"}
{"text":"Q: What lifecycle actions occur when getTaskDetail is called? A: withLoadingAndErrorHandling dispatches GET_TASK_DETAIL.REQUEST, then on success GET_TASK_DETAIL.SUCCESS, or GET_TASK_DETAIL.FAILURE on error."}
{"text":"Q: How does resetTaskDetailRequest integrate with sagas? A: It dispatches RESET_TASK_DETAIL, which a saga or reducer listens for to clear taskDetail state without invoking an API."}
{"text":"Q: Why are REQUEST, SUCCESS, and FAILURE actions important? A: They demarcate each phase of an async operation, enabling sagas to trigger side effects on REQUEST and letting reducers handle state changes appropriately."}
{"text":"Q: How would a saga watch for UPDATE_TASK actions? A: A saga uses takeEvery(UPDATE_TASK.REQUEST, workerUpdateTask) to perform the API call and then dispatch UPDATE_TASK.SUCCESS or FAILURE based on the outcome."}
{"text":"Q: What action constant pattern is used for addComment? A: ADD_COMMENT.REQUEST is dispatched at call start, then ADD_COMMENT.SUCCESS or ADD_COMMENT.FAILURE is dispatched when the API resolves."}
{"text":"Q: How does withLoadingAndErrorHandling know which actions to dispatch? A: It receives the base constant (e.g., ADD_TASK) and automatically appends .REQUEST, .SUCCESS, and .FAILURE when wrapping the provided method."}
{"text":"Q: Which saga watches GET_TASK_LIST.REQUEST and what does it do? A: A watcher saga uses takeEvery(GET_TASK_LIST.REQUEST, handleGetTaskList) to call the API and dispatch GET_TASK_LIST.SUCCESS or FAILURE based on the response."}
{"text":"Q: Which saga watches GET_PRIORITY_LIST.REQUEST and what does it do? A: A watcher saga uses takeEvery(GET_PRIORITY_LIST.REQUEST, handleGetPriorityList) to fetch priorities and dispatch GET_PRIORITY_LIST.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_TEAMS_BY_TENANT.REQUEST and what does it do? A: It uses takeEvery(GET_TEAMS_BY_TENANT.REQUEST, handleGetTeamsByTenant) to call getTMTeamList and dispatch success or failure actions."}
{"text":"Q: Which saga watches GET_CURRENT_TEAMS.REQUEST and what does it do? A: It uses takeEvery(GET_CURRENT_TEAMS.REQUEST, handleGetCurrentTeamList) to fetch the user’s teams and dispatch GET_CURRENT_TEAMS.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_ASSIGNEE_LIST.REQUEST and what does it do? A: It uses takeEvery(GET_ASSIGNEE_LIST.REQUEST, handleGetAssigneeList) to fetch team users and dispatch GET_ASSIGNEE_LIST.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_USERS_IN_TEAMS_BY_TENANTS.REQUEST and what does it do? A: It uses takeEvery(GET_USERS_IN_TEAMS_BY_TENANTS.REQUEST, handleGetUsersInTeamByTenants) to batch-fetch users across teams."}
{"text":"Q: Which saga watches GET_TASK_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_TASK_DETAIL.REQUEST, handleGetTaskDetail) to fetch task details and dispatch GET_TASK_DETAIL.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches ADD_TASK.REQUEST and what does it do? A: It uses takeEvery(ADD_TASK.REQUEST, handleAddTask) to call addTask API, upload files, navigate back, and dispatch ADD_TASK.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches UPDATE_TASK.REQUEST and what does it do? A: It uses takeEvery(UPDATE_TASK.REQUEST, handleUpdateTask) to update tasks or series, upload files, navigate back, and dispatch UPDATE_TASK.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_STATUS_LIST.REQUEST and what does it do? A: It uses takeEvery(GET_STATUS_LIST.REQUEST, handleGetStatusList) to fetch statuses and dispatch GET_STATUS_LIST.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_MENTION_USER.REQUEST and what does it do? A: It uses takeEvery(GET_MENTION_USER.REQUEST, handleGetMentionUsers) to transform and cache mention data."}
{"text":"Q: Which saga watches ADD_COMMENT.REQUEST and what does it do? A: It uses takeEvery(ADD_COMMENT.REQUEST, handleAddComment) to submit a comment and dispatch ADD_COMMENT.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_COMMENT_BY_TASK.REQUEST and what does it do? A: It uses takeEvery(GET_COMMENT_BY_TASK.REQUEST, handleGetCommentByTask) to fetch task comments."}
{"text":"Q: Which saga watches GET_EMPLOYEES_BY_TENANT.REQUEST and what does it do? A: It uses takeEvery(GET_EMPLOYEES_BY_TENANT.REQUEST, handleGetEmployeesByTenant) to paginate tenant employees."}
{"text":"Q: Which saga watches GET_TEAMS_FOR_TASK_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_TEAMS_FOR_TASK_DETAIL.REQUEST, handleGetTeamsForTaskDetail) to load teams for an existing task."}
{"text":"Q: Which saga watches GET_TENANTS_TASK_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_TENANTS_TASK_DETAIL.REQUEST, handleGetTenantsTaskDetail) to load tenant list for control office users."}
{"text":"Q: Which saga watches GET_TASK_SETTING.REQUEST and what does it do? A: It uses takeEvery(GET_TASK_SETTING.REQUEST, handleGetTaskSetting) to fetch default task config (reminders) for the form."}
{"text":"Q: Which saga watches GET_FILE_BY_REFERENCE_ID.REQUEST and what does it do? A: It uses takeEvery(GET_FILE_BY_REFERENCE_ID.REQUEST, handleGetFileByReferenceId) to clear and load attachments."}
{"text":"Q: Which saga watches SET_UP_APPROVAL.REQUEST and what does it do? A: It uses takeEvery(SET_UP_APPROVAL.REQUEST, handleSetUpApprovals) to send pending changes for approvals."}
{"text":"Q: Which saga watches APPROVE_CHANGE.REQUEST and what does it do? A: It uses takeEvery(APPROVE_CHANGE.REQUEST, handleApproveChange) to approve pending changes."}
{"text":"Q: Which saga watches REJECT_CHANGE.REQUEST and what does it do? A: It uses takeEvery(REJECT_CHANGE.REQUEST, handleRejectChange) to reject pending changes with optional reason."}
{"text":"Q: Which saga watches GET_TASK_PROPERTY_CONFIG.REQUEST and what does it do? A: It uses takeEvery(GET_TASK_PROPERTY_CONFIG.REQUEST, handleGetTaskPropertyConfig) to load dynamic form field configs."}
{"text":"Q: What does GET_TASK_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates tasks were fetched successfully; the reducer calls `state.list.setData(payload)` and deep-clones the ListModel to update `state.list`."}
{"text":"Q: What does GET_PRIORITY_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates priorities were fetched successfully; the reducer sets `state.priorityList = payload`."}
{"text":"Q: What does GET_TEAMS_BY_TENANT.SUCCESS indicate, and how does the reducer handle it? A: It indicates team data was fetched successfully; the reducer applies `transformWithCOTags(payload)` and sets `state.teamList`."}
{"text":"Q: What does GET_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates task details were fetched; the reducer sets `state.taskDetail = payload`."}
{"text":"Q: What does ADD_TASK.SUCCESS indicate, and how should the app respond? A: It indicates a new task was created successfully; UI components typically refresh the task list and navigate back (handled by sagas)."}
{"text":"Q: What does UPDATE_TASK.SUCCESS indicate, and how should the app respond? A: It indicates a task update succeeded; UI components refresh the display or navigate back as appropriate."}
{"text":"Q: What does GET_STATUS_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates statuses were fetched; the reducer sets `state.statusList = payload`."}
{"text":"Q: What does GET_MENTION_USER.SUCCESS indicate, and how does the reducer handle it? A: It indicates mentions were fetched; the reducer stores `state.mentionUsersDic[key] = mentionUsers` based on the provided key."}
{"text":"Q: What does ADD_COMMENT.SUCCESS indicate, and how does the reducer handle it? A: It indicates a comment was added; subsequent sagas or components may re-fetch comments, but the reducer does not directly update state here."}
{"text":"Q: What does GET_COMMENT_BY_TASK.SUCCESS indicate, and how does the reducer handle it? A: It indicates comments were fetched; the reducer sets `state.comments = payload`."}
{"text":"Q: What does GET_ASSIGNEE_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates team assignees were fetched successfully; the reducer applies `transformWithCOTags(payload)` and sets `state.assigneeList`."}
{"text":"Q: What does GET_CURRENT_TEAMS.SUCCESS indicate, and how does the reducer handle it? A: It indicates the current user’s teams were fetched; the reducer sets `state.teamList = payload`."}
{"text":"Q: What does GET_STATUS_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates status options were fetched; the reducer sets `state.statusList = payload`."}
{"text":"Q: What does GET_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates detailed information for a task was fetched; the reducer sets `state.taskDetail = payload`."}
{"text":"Q: What does GET_TEAMS_FOR_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates teams for an existing task were fetched; the reducer applies `transformWithCOTags(payload)` and sets `state.teamsTaskDetail`."}
{"text":"Q: What does GET_USERS_IN_TEAMS_BY_TENANTS.SUCCESS indicate, and how does the reducer handle it? A: It indicates users across selected teams were fetched; the reducer applies `transformWithCOTags(payload)` and sets `state.usersInTeams`."}
{"text":"Q: What does GET_EMPLOYEES_BY_TENANT.SUCCESS indicate, and how does the reducer handle it? A: It indicates employees for a tenant were fetched; the reducer transforms items with `transformWithCOTags`, calls `employeesByTenant.setData(payload)`, and deep clones it."}
{"text":"Q: What does GET_TENANTS_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates the tenant list was fetched; the reducer calls `tenantsDetail.setData(payload)`, sets `totalPage = 1`, and returns a deep clone."}
{"text": "Reducer & State Management"}
{"text":"Q: How does the reducer handle GET_TASK_LIST.REQUEST? A: It calls state.list.setPage(page) on the ListModel and then returns a deep clone so Redux detects the change."}
{"text":"Q: What does GET_TASK_LIST.SUCCESS do in the reducer? A: It sets the fetched data on the ListModel via list.setData(payload) and deep-clones the state for immutability."}
{"text":"Q: How are control-office tags applied to team lists? A: On GET_TEAMS_BY_TENANT.SUCCESS and GET_TEAMS_FOR_TASK_DETAIL.SUCCESS, the reducer calls transformWithCOTags before storing in state.teamList or state.teamsTaskDetail."}
{"text":"Q: Why deep-clone ListModel instances after mutation? A: Because ListModel methods mutate internal state, deep cloning ensures a new reference so Redux change detection works correctly."}
{"text":"Q: How does the reducer respond to GET_TENANTS_TASK_DETAIL.REQUEST vs SUCCESS? A: REQUEST resets pagination (page=1, totalPage=1), and SUCCESS populates tenantsDetail.setData(payload) before deep-cloning."}
{"text":"Q: What happens on GET_FILE_BY_REFERENCE_ID.REQUEST? A: The reducer clears state.files to an empty array, removing stale attachments before the new payload arrives."}
{"text":"Q: How are dynamic field configs loaded into state? A: On GET_TASK_PROPERTY_CONFIG.SUCCESS, the reducer prefixes each item’s key with TM_FFC_ and stores them in state.taskPropertyConfigs."}
{"text":"Q: What does the reducer’s default case do? A: It returns the unchanged state for any unrecognized action, preventing unintended state mutations."}
{"text":"Q: When GET_TASK_LIST.REQUEST is dispatched, which saga and reducer cases handle it? A: The saga watcher `takeEvery(GET_TASK_LIST.REQUEST, handleGetTaskList)` calls the API; on success it dispatches GET_TASK_LIST.SUCCESS, which the reducer handles by calling `state.list.setData(payload)` and deep-cloning the ListModel."}
{"text":"Q: How do GET_PRIORITY_LIST.REQUEST, its saga, and reducer integrate? A: `takeEvery(GET_PRIORITY_LIST.REQUEST, handleGetPriorityList)` invokes the priority API, then dispatches GET_PRIORITY_LIST.SUCCESS; the reducer sets `state.priorityList = payload`."}
{"text":"Q: Describe the flow for GET_TEAMS_BY_TENANT.REQUEST through saga and reducer. A: The saga watcher `takeEvery(GET_TEAMS_BY_TENANT.REQUEST, handleGetTeamsByTenant)` calls `getTMTeamList`; on GET_TEAMS_BY_TENANT.SUCCESS the reducer applies `transformWithCOTags` and stores the result in `state.teamList`."}
{"text":"Q: What happens from GET_TASK_DETAIL.REQUEST to the reducer update? A: The saga `takeEvery(GET_TASK_DETAIL.REQUEST, handleGetTaskDetail)` calls the detail API, then dispatches GET_TASK_DETAIL.SUCCESS; the reducer sets `state.taskDetail = payload`."}
{"text":"Q: How is ADD_TASK.REQUEST handled by saga and reducer? A: Under the saga `takeEvery(ADD_TASK.REQUEST, handleAddTask)`, the API call and file uploads occur, navigation is triggered, and then ADD_TASK.SUCCESS is dispatched; the reducer doesn’t store new state here, but components reload the list afterward."}
{"text":"Q: Explain the lifecycle for UPDATE_TASK.REQUEST. A: The saga `takeEvery(UPDATE_TASK.REQUEST, handleUpdateTask)` calls the update API (single or series), uploads files, navigates back, then dispatches UPDATE_TASK.SUCCESS; the reducer may clear pending changes or trigger side-effects via listeners."}
{"text":"Q: Outline how RESET_TASK_DETAIL is processed in saga and reducer. A: RESET_TASK_DETAIL is a plain action (no saga watcher); the reducer listens for RESET_TASK_DETAIL and sets `state.taskDetail = null` to clear the detail state."}
{"text":"Q: What is the flow for GET_COMMENT_BY_TASK.REQUEST? A: The saga `takeEvery(GET_COMMENT_BY_TASK.REQUEST, handleGetCommentByTask)` fetches comments, dispatches GET_COMMENT_BY_TASK.SUCCESS; the reducer then assigns `state.comments = payload`."}
{"text":"Q: How are SET_UP_APPROVAL.REQUEST and APPROVE_CHANGE.REQUEST handled? A: `takeEvery(SET_UP_APPROVAL.REQUEST, handleSetUpApprovals)` sends pending changes; upon SET_UP_APPROVAL.SUCCESS components may re-fetch taskDetail. Similarly, `takeEvery(APPROVE_CHANGE.REQUEST, handleApproveChange)` triggers backend approval and then APPROVE_CHANGE.SUCCESS updates approval state in the reducer."}
{"text":"Q: Describe the GET_TASK_PROPERTY_CONFIG.REQUEST to reducer update. A: The saga `takeEvery(GET_TASK_PROPERTY_CONFIG.REQUEST, handleGetTaskPropertyConfig)` fetches dynamic field configs, dispatches GET_TASK_PROPERTY_CONFIG.SUCCESS; the reducer prefixes each item’s key with `TM_FFC_` and stores them in `state.taskPropertyConfigs`."}
{"text": "Business Logic & Side Effects"}
{"text":"Q: Why call NavigationServices.goBack() after addTask and updateTask? A: To navigate back automatically once the task creation or update (and any file uploads) complete successfully."}
{"text":"Q: How are file uploads coordinated in addTask? A: After the primary API call, the code checks payload.files, derives the correct documentId, and calls RequestApi.uploadTaskManagementFiles."}
{"text":"Q: How does updateTask handle series vs single task updates? A: It checks payload.isSeries or schedule flags to call updateTaskWithSchedule for series or updateTask for single items."}
{"text":"Q: What is setUpApprovals used for? A: It sends pending change details to the approval API, initiating an approval workflow rather than directly updating the task."}
{"text":"Q: How do approveChange and rejectChange differ? A: Both call their respective API, but rejectChange may include a rejectionReason payload, while approveChange sends only approvalMatrixId."}
{"text":"Q: Why return both mentionUsers and key from getMentionUsers? A: So the reducer can cache the transformed user list under the provided key, avoiding duplicate API calls."}
{"text":"Q: How does transformMentionUsers affect caching logic? A: It produces normalized user objects, and getCacheKey ensures each param combination maps to a unique cache entry in state. "}
{"text":"Q: When is resetTaskDetail invoked in business flow? A: Components call resetTaskDetail (dispatch RESET_TASK_DETAIL) in cleanup effects to clear form state when unmounting the detail screen."}
{"text":"Q: How does resetTaskDetailRequest improve UX during navigation? A: By clearing the detail state immediately on unmount or reset, it prevents stale task data from appearing when revisiting the screen."}
{"text":"Q: What side effects does withLoadingAndErrorHandling wrapper trigger beyond dispatching actions? A: It toggles a global loading indicator, allowing the UI to show spinners during long-running operations like file uploads."}
{"text":"Q: How are errors during file uploads handled after addTask/updateTask? A: If uploadTaskManagementFiles fails, withLoadingAndErrorHandling dispatches FAILURE and error state, enabling the app to display an error message."}
{"text":"Q: Why call NavigationServices.goBack() after awaiting file uploads? A: To ensure all side effects complete before navigating away, preventing race conditions and guaranteeing data consistency."}
{"text":"Q: Why include isActive:true when fetching teams? A: To only retrieve active teams, improving performance and UX by excluding inactive entries from dropdowns."}
{"text":"Q: How does getTenantsTaskDetail support control-office workflows? A: By fetching all tenants via RequestApi.getTenantList with editionIdSpecified:false and skipCount:0, it provides the full tenant list for control-office context switching."}
{"text":"Q: Why use _.first(response) when extracting documentId? A: Some schedule APIs return an array; _.first ensures the correct documentId is selected for subsequent file uploads."}
{"text":"Q: What ensures navigation only occurs after file uploads? A: NavigationServices.goBack() is called after awaiting uploadTaskManagementFiles, guaranteeing all uploads finish before leaving the screen."}
{"text":"Feedback"}
{"text":"API Handler Wrappers"}
{"text":"Q: What does getListFB(params) wrap and dispatch? A: It dispatches GET_LIST_FB_REQUEST with params, calls RequestApi.getListFB(params), then dispatches GET_LIST_FB_SUCCESS with the response or GET_LIST_FB_FAILURE on error."}
{"text":"Q: What does getListQRFeedback(params) wrap and dispatch? A: It dispatches GET_LIST_FB_QR_REQUEST, calls RequestApi.getListQRFeedback(params), then dispatches GET_LIST_FB_QR_SUCCESS or GET_LIST_FB_QR_FAILURE on error."}
{"text":"Q: How does addFB integrate with handler wrappers? A: addFB is wrapped by withLoadingAndErrorHandling(ADD_FB) to dispatch ADD_FB.REQUEST, call RequestApi.createFeedback, upload files, then dispatch ADD_FB.SUCCESS or ADD_FB.FAILURE."}
{"text":"Q: How does editFB integrate with handler wrappers? A: editFB is wrapped by withLoadingAndErrorHandling(EDIT_FB) to dispatch EDIT_FB.REQUEST, call RequestApi.updateFeedback, upload files, then dispatch EDIT_FB.SUCCESS or EDIT_FB.FAILURE."}
{"text":"Q: What does editQrFB(params) wrap and dispatch? A: It dispatches EDIT_QR_FB_REQUEST, calls RequestApi.updateQRFeedback(params), then dispatches EDIT_QR_FB_SUCCESS(true) or EDIT_QR_FB_FAILURE(err) on error."}
{"text":"Q: What does detailFB(id) wrap and dispatch? A: It dispatches DETAIL_FB_REQUEST(id), calls RequestApi.getDetailFB(id), then dispatches DETAIL_FB_SUCCESS(response) or DETAIL_FB_FAILURE(err)."}
{"text":"Q: What does detailQRFeedback(id) wrap and dispatch? A: It dispatches DETAIL_FB_QR_REQUEST(id), calls RequestApi.getDetailQRFeedback(id), then dispatches DETAIL_FB_QR_SUCCESS(response) or DETAIL_FB_QR_FAILURE(err)."}
{"text":"Q: What does getSources(params) wrap and dispatch? A: It dispatches GET_SOURCES_REQUEST(params), calls RequestApi.getFeedbackSources(params), then dispatches GET_SOURCES_SUCCESS(response) or GET_SOURCES_FAILURE(err)."}
{"text":"Q: What does getAreas() wrap and dispatch? A: It dispatches GET_AREAS_REQUEST(), calls RequestApi.getAreas(), then dispatches GET_AREAS_SUCCESS(response) or GET_AREAS_FAILURE(err)."}
{"text":"Q: What does getCategories() wrap and dispatch? A: It dispatches GET_CATEGORIES_REQUEST(), calls RequestApi.getFeedbackCategories(), then dispatches GET_CATEGORIES_SUCCESS(response) or GET_CATEGORIES_FAILURE(err)."}
{"text":"Q: What does getTypes() wrap and dispatch? A: It dispatches GET_TYPES_REQUEST(), calls RequestApi.getFeedbackTypes(), then dispatches GET_TYPES_SUCCESS(response) or GET_TYPES_FAILURE(err)."}
{"text":"Q: What does getSubCategories(params) wrap and dispatch? A: It dispatches GET_SUB_CATEGORIES_REQUEST(params), calls RequestApi.getSubCategories(areaId, categoryId), then dispatches GET_SUB_CATEGORIES_SUCCESS(response) or GET_SUB_CATEGORIES_FAILURE(err)."}
{"text":"Q: What does addQuickJR(params) wrap and dispatch? A: It dispatches ADD_QUICK_JR_REQUEST(params), calls RequestApi.requestQuickCreateWorkOrder(params), then dispatches ADD_QUICK_JR_SUCCESS(response) or ADD_QUICK_JR_FAILURE(err)."}
{"text":"Q: What does getQuickJRSetting(params) wrap and dispatch? A: It dispatches GET_QUICK_JR_SETTING_REQUEST(params), calls RequestApi.requestWorkOrderSetting(params), then dispatches GET_QUICK_JR_SETTING_SUCCESS(response) or GET_QUICK_JR_SETTING_FAILURE(err)."}
{"text":"Q: What does getFeedbackStatus() wrap and dispatch? A: It dispatches GET_FEEDBACK_STATUS_REQUEST(), calls RequestApi.getFeedbackStatus(), then dispatches GET_FEEDBACK_STATUS_SUCCESS(response) or GET_FEEDBACK_STATUS_FAILURE(err)."}
{"text":"Q: What does getLocations(payload) wrap and dispatch? A: It dispatches GET_LOCATIONS_REQUEST(payload), calls RequestApi.getListLocation(payload), then dispatches GET_LOCATIONS_SUCCESS(response) or GET_LOCATIONS_FAILURE(err)."}
{"text":"Q: What do getFeedbackDivision() and getQrFeedbackSetting() wrap? A: Both are wrapped by withErrorHandling, calling RequestApi.getFeedbackDivision() and RequestApi.getQrFeedbackSetting(), then dispatching GET_FEEDBACK_DIVISION.SUCCESS or GET_QR_FEEDBACK_SETTING.SUCCESS accordingly."}
{"text":"Q: What does getQuickJRSetting(params) wrap and dispatch? A: It dispatches GET_QUICK_JR_SETTING_REQUEST(params), calls RequestApi.requestWorkOrderSetting(params), then dispatches GET_QUICK_JR_SETTING_SUCCESS(response) or GET_QUICK_JR_SETTING_FAILURE(err)."}
{"text":"Q: What does getFeedbackStatus() wrap and dispatch? A: It dispatches GET_FEEDBACK_STATUS_REQUEST(), calls RequestApi.getFeedbackStatus(), then dispatches GET_FEEDBACK_STATUS_SUCCESS(response) or GET_FEEDBACK_STATUS_FAILURE(err)."}
{"text":"Q: What does getLocations(payload) wrap and dispatch? A: It dispatches GET_LOCATIONS_REQUEST(payload), calls RequestApi.getListLocation(payload), then dispatches GET_LOCATIONS_SUCCESS(response) or GET_LOCATIONS_FAILURE(err)."}
{"text":"Q: What does getFeedbackDivision() wrap? A: It is wrapped by withErrorHandling(GET_FEEDBACK_DIVISION, getFeedbackDivision) to dispatch GET_FEEDBACK_DIVISION.REQUEST, call RequestApi.getFeedbackDivision(), then dispatch GET_FEEDBACK_DIVISION.SUCCESS(response.items) or GET_FEEDBACK_DIVISION.FAILURE(err)."}
{"text":"Q: What does getQrFeedbackSetting() wrap? A: It is wrapped by withErrorHandling(GET_QR_FEEDBACK_SETTING, getQrFeedbackSetting) to dispatch GET_QR_FEEDBACK_SETTING.REQUEST, call RequestApi.getQrFeedbackSetting(), then dispatch GET_QR_FEEDBACK_SETTING.SUCCESS(response) or GET_QR_FEEDBACK_SETTING.FAILURE(err)."}
{"text": "Action & Saga Integration"}
{"text":"Q: Which saga watcher handles GET_LIST_FB_REQUEST? A: A watcher saga uses takeEvery(GET_LIST_FB_REQUEST, handleGetListFB) to call the getListFB worker, then dispatch GET_LIST_FB_SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles ADD_FB.REQUEST? A: takeEvery(ADD_FB.REQUEST, handleAddFB) triggers the addFB flow, uploads files, and dispatches ADD_FB.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles DETAIL_FB_QR_REQUEST? A: takeEvery(DETAIL_FB_QR_REQUEST, handleDetailQRFeedback) invokes the detailQRFeedback worker and dispatches DETAIL_FB_QR_SUCCESS or FAILURE."}
{"text":"Q: What lifecycle actions are dispatched around editFB? A: EDIT_FB.REQUEST at start, then EDIT_FB.SUCCESS on successful update/upload, or EDIT_FB.FAILURE on errors."}
{"text":"Q: How do REQUEST, SUCCESS, and FAILURE actions support the Feedback form? A: They represent each phase of an async call, allowing sagas and reducers to manage loading state, data, and errors for lists, details, and edits."}
{"text":"Q: Why define string constants for GET_LIST_FB_QR_REQUEST/SUCCESS/FAILURE? A: To have explicit action types for saga watchers and reducer cases without generateAction wrappers."}
{"text":"Q: Which saga watches GET_QUICK_JR_SETTING_REQUEST? A: takeEvery(GET_QUICK_JR_SETTING_REQUEST, handleGetQuickJRSetting) calls the API and dispatches GET_QUICK_JR_SETTING_SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_FEEDBACK_STATUS_REQUEST? A: takeEvery(GET_FEEDBACK_STATUS_REQUEST, handleGetFeedbackStatus) to fetch statuses and dispatch corresponding success/failure."}
{"text":"Q: Which saga watches GET_LOCATIONS_REQUEST? A: takeEvery(GET_LOCATIONS_REQUEST, handleGetLocations) to fetch paginated location data and dispatch GET_LOCATIONS_SUCCESS or FAILURE."}
{"text":"Q: How does withLoadingAndErrorHandling differ from manual dispatch in Feedback? A: withLoadingAndErrorHandling auto-dispatches REQUEST/SUCCESS/FAILURE and toggles loading, whereas getListFB manually dispatches actions inside a try/catch."}
{"text":"Q: Which saga watcher handles GET_SUB_CATEGORIES_REQUEST? A: It uses takeEvery(GET_SUB_CATEGORIES_REQUEST, handleGetSubCategories) to call the API and dispatch GET_SUB_CATEGORIES_SUCCESS or GET_SUB_CATEGORIES_FAILURE."}
{"text":"Q: Which saga watcher handles ADD_QUICK_JR_REQUEST? A: It uses takeEvery(ADD_QUICK_JR_REQUEST, handleAddQuickJR) to call requestQuickCreateWorkOrder and dispatch ADD_QUICK_JR_SUCCESS or ADD_QUICK_JR_FAILURE."}
{"text":"Q: Which saga watcher handles GET_FEEDBACK_DIVISION.REQUEST? A: It uses takeEvery(GET_FEEDBACK_DIVISION.REQUEST, handleGetFeedbackDivision) to fetch the division list and dispatch GET_FEEDBACK_DIVISION.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_QR_FEEDBACK_SETTING.REQUEST? A: It uses takeEvery(GET_QR_FEEDBACK_SETTING.REQUEST, handleGetQrFeedbackSetting) to load QR feedback config and dispatch GET_QR_FEEDBACK_SETTING.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles EDIT_FB.REQUEST? A: It uses takeEvery(EDIT_FB.REQUEST, handleEditFB) to wrap updateFeedback, handle file uploads, and dispatch EDIT_FB.SUCCESS or EDIT_FB.FAILURE."}
{"text":"Q: Which saga watcher handles GET_AREAS_REQUEST and what is its flow? A: It uses takeEvery(GET_AREAS_REQUEST, handleGetAreas) to call RequestApi.getAreas and then dispatch GET_AREAS_SUCCESS or GET_AREAS_FAILURE."}
{"text":"Q: Which saga watcher handles GET_CATEGORIES_REQUEST? A: It uses takeEvery(GET_CATEGORIES_REQUEST, handleGetCategories) to fetch feedback categories and dispatch GET_CATEGORIES_SUCCESS or GET_CATEGORIES_FAILURE."}
{"text":"Q: Which saga watcher handles GET_TYPES_REQUEST and what does it do? A: It uses takeEvery(GET_TYPES_REQUEST, handleGetTypes) to invoke RequestApi.getFeedbackTypes and dispatch GET_TYPES_SUCCESS or GET_TYPES_FAILURE."}
{"text": "Reducer & State Management"}
{"text":"Q: How does the Feedback reducer handle GET_LIST_FB_REQUEST? A: It calls state.list.setPage(page) on the ListModel and returns a deep clone to trigger updates."}
{"text":"Q: What happens on GET_LIST_FB_SUCCESS in the reducer? A: It maps each item to enrich fields (id, fullName, phoneNumber, emailAddress), calls list.setData(data), and deep-clones `list`."}
{"text":"Q: How does the reducer handle DETAIL_FB_REQUEST? A: It sets `fbDetail = undefined` and `isLoading = true` to clear previous detail and show a loading indicator."}
{"text":"Q: What does DETAIL_FB_SUCCESS do in state? A: It assigns `fbDetail = payload` and `isLoading = false`, reflecting the loaded feedback detail."}
{"text":"Q: How are sources stored on GET_SOURCES_SUCCESS? A: The reducer sets `state.sources = payload`, updating the dropdown options for feedback sources."}
{"text":"Q: How does GET_AREAS_REQUEST vs GET_AREAS_SUCCESS differ? A: REQUEST clears `state.areas = []`; SUCCESS populates `state.areas = payload`."}
{"text":"Q: How does GET_TYPES_REQUEST vs GET_TYPES_SUCCESS behave? A: REQUEST leaves `state.types` unchanged; SUCCESS sets `state.types = payload`."}
{"text":"Q: How does GET_LOCATIONS_SUCCESS update the ListModel? A: It calls `locations.setData(payload)` then deep-clones `locations` so pagination and items are updated immutably."}
{"text":"Q: What does GET_FEEDBACK_DIVISION.SUCCESS do? A: It sets `state.divisionList = payload`, storing divisions for quick-create work orders."}
{"text":"Q: How is EDIT_QR_FB_REQUEST handled in the reducer? A: It sets `isLoading = true` to indicate the edit operation is in progress."}
{"text":"Q: How is EDIT_QR_FB_SUCCESS handled? A: It sets `isLoading = false` once the QR feedback edit completes successfully."}
{"text":"Q: How does the reducer handle failures like GET_LIST_FB_FAILURE? A: It stores `error = payload`, allowing the UI to display an error message."}
{"text":"Q: What does RESET state on user switch (SWITCH_TO_USER_ACCOUNT_SUCCESS) do? A: It returns INITIAL_STATE, clearing all feedback data when switching accounts."}
{"text":"Q: Why deep-clone ListModel after mutation? A: Because ListModel methods mutate internal state; deep cloning ensures Redux notices the change by new references."}
{"text":"Q: How does DETAIL_FB_QR_FAILURE affect loading state? A: It sets `isLoading = false` without altering `qrFBDetail`, preserving previous data if any."}
{"text":"Q: What is the reducer’s default case behavior? A: It returns the unchanged state for any unknown action type, preventing unintended mutations."}
{"text":"Q: How does the reducer handle GET_SUB_CATEGORIES_REQUEST? A: It typically resets or clears `state.subCategories` before loading new sub-categories."}
{"text":"Q: What does GET_SUB_CATEGORIES_SUCCESS do in the reducer? A: It assigns `state.subCategories = payload`, updating the list based on selected area and category."}
{"text":"Q: How does GET_SUB_CATEGORIES_FAILURE affect state? A: It leaves `state.subCategories` unchanged and may set an error flag, preventing stale data replacement."}
{"text":"Q: What does ADD_QUICK_JR_SUCCESS do in the reducer? A: It may store the response in a `quickJR` slice or trigger a list refresh, indicating successful creation."}
{"text":"Q: How is GET_FEEDBACK_DIVISION.SUCCESS handled? A: The reducer sets `state.divisionList = payload`, making divisions available for quick work order creation."}
{"text":"Q: How is GET_QR_FEEDBACK_SETTING.SUCCESS handled? A: It sets `state.qrFeedbackSetting = payload`, storing QR feedback modal configuration."}
{"text":"Q: What does GET_FEEDBACK_STATUS_REQUEST do to `state.statusList`? A: It typically clears or marks it loading, preparing to fetch status options."}
{"text":"Q: How does GET_FEEDBACK_STATUS_SUCCESS update the store? A: It sets `state.statusList = payload`, populating feedback status dropdown values."}
{"text":"Q: How are feedback errors handled on GET_FEEDBACK_STATUS_FAILURE? A: The reducer retains the previous `statusList` and may store an error flag without clearing existing data."}
{"text":"Q: How does SWITCH_TO_USER_ACCOUNT_SUCCESS reset feedback state? A: It returns `INITIAL_STATE`, clearing all lists, details, loading flags, and configurations for the new user context."}
{"text": "Business Logic & Side Effects"}
{"text":"Q: Why upload files only after receiving a GUID in addFB? A: Because the backend assigns a document ID on creation, which is needed to associate uploaded files correctly."}
{"text":"Q: How does editFB decide which files to upload? A: It passes `isNewCommentBox: false` to uploadFileFeedback to indicate an edit context vs initial creation."}
{"text":"Q: Why return `true` on editQrFBSuccess? A: So calling components know the edit succeeded and can proceed (e.g., close modals or refresh data)."}
{"text":"Q: Why do manual dispatches in getListFB use try/catch instead of wrappers? A: To customize error handling or to perform additional logic before/after dispatch, independent of global loading state."}
{"text":"Q: How does withLoadingAndErrorHandling improve UX for addFB/editFB? A: It automatically toggles a global spinner during long operations, giving users immediate feedback."}
{"text":"Q: What side effect does SWITCH_TO_USER_ACCOUNT_SUCCESS in the Feedback reducer trigger? A: It resets all feedback state so new user sessions start with a clean slate."}
{"text":"Q: Why clear `fbDetail` on DETAIL_FB_REQUEST? A: To prevent stale detail data from flashing while the new detail is being fetched."}
{"text":"Q: How does the reducer ensure pagination resets on GET_LIST_FB_QR_REQUEST? A: It calls `state.listQRFeedback.setPage(page)` before fetching, aligning the ListModel with the requested page."}
{"text":"Q: Why not wrap getFeedbackDivision in withLoadingAndErrorHandling? A: Likely because division data is small/static and doesn’t require a loading spinner, only error handling."}
{"text":"Q: How does the hook decide whether to use manual dispatch vs handler wrappers? A: It uses manual dispatch when custom try/catch logic is needed; uses wrappers for standard CRUD operations to reduce boilerplate."}
{"text":"Booking"}
{"text":"API Handler Wrappers"}
{"text":"Q: What does getBookingStatus wrap and dispatch? A: It wraps RequestApi.getBookingStatus() to retrieve booking statuses and, when used with withErrorHandling(GET_BOOKING_STATUS), dispatches GET_BOOKING_STATUS.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does filterBookings wrap and dispatch? A: It wraps RequestApi.filterBookings(params, isSorting) to fetch filtered reservations and, with withErrorHandling(FILTER_BOOKINGS), dispatches FILTER_BOOKINGS.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does getAllTimeSlots wrap and dispatch? A: It wraps RequestApi.getAllTimeSlots(params) to load available timeslots and, with withLoadingAndErrorHandling(GET_ALL_TIMESLOTS), dispatches GET_ALL_TIMESLOTS.REQUEST then SUCCESS or FAILURE and manages loading state."}
{"text":"Q: What does getBookingDetail wrap and dispatch? A: It wraps RequestApi.getBookingDetail(reservationId) to fetch a single booking’s details and, with withLoadingAndErrorHandling(GET_BOOKING_DETAIL), dispatches GET_BOOKING_DETAIL.REQUEST then SUCCESS or FAILURE and manages loading state."}
{"text":"Q: What does getPaymentStatus wrap and dispatch? A: It wraps RequestApi.getPaymentStatus() to retrieve payment status options and, with withErrorHandling(GET_PAYMENT_STATUS), dispatches GET_PAYMENT_STATUS.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does addBooking wrap and dispatch? A: It wraps RequestApi.addBooking(payload), handles file uploads via RequestApi.uploadBookingFiles when files exist, and, with withLoadingAndErrorHandling(ADD_BOOKING), dispatches ADD_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does updateBooking wrap and dispatch? A: It wraps RequestApi.updateBooking(payload), handles file uploads when files exist, and, with withLoadingAndErrorHandling(UPDATE_BOOKING), dispatches UPDATE_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does validateRecurringBooking wrap and dispatch? A: It wraps RequestApi.validateRecurringBooking(payload) and, with withLoadingAndErrorHandling(VALIDATE_RECURRING_BOOKING), dispatches VALIDATE_RECURRING_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does recurringBooking wrap and dispatch? A: It wraps RequestApi.recurringBooking(payload) and, with withLoadingAndErrorHandling(RECURRING_BOOKING), dispatches RECURRING_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does getAmenityDetail wrap and dispatch? A: It wraps RequestApi.getAmenityDetail(amenityId) and, with withLoadingAndErrorHandling(GET_AMENITY_DETAIL), dispatches GET_AMENITY_DETAIL.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does getAmenities wrap and dispatch? A: It wraps RequestApi.getAmenities(params) to fetch amenity lists and, with withErrorHandling(GET_AMENITIES), dispatches GET_AMENITIES.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does getBookingPurpose wrap and dispatch? A: It wraps RequestApi.getBookingPurpose() to retrieve booking purposes and, with withErrorHandling(GET_ALL_BOOKING_PURPOSE), dispatches GET_ALL_BOOKING_PURPOSE.REQUEST then SUCCESS or FAILURE."}
{"text": "Action & Saga Integration"}
{"text":"Q: Which saga watcher handles GET_BOOKING_STATUS.REQUEST and what does it do? A: A saga uses takeEvery(GET_BOOKING_STATUS.REQUEST, handleGetBookingStatus) to call getBookingStatus and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles FILTER_BOOKINGS.REQUEST and what does it do? A: It uses takeEvery(FILTER_BOOKINGS.REQUEST, handleFilterBookings) to call filterBookings and dispatch FILTER_BOOKINGS.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_ALL_TIMESLOTS.REQUEST and what does it do? A: It uses takeEvery(GET_ALL_TIMESLOTS.REQUEST, handleGetAllTimeSlots) to call getAllTimeSlots, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_BOOKING_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_BOOKING_DETAIL.REQUEST, handleGetBookingDetail) to call getBookingDetail, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_PAYMENT_STATUS.REQUEST and what does it do? A: It uses takeEvery(GET_PAYMENT_STATUS.REQUEST, handleGetPaymentStatus) to call getPaymentStatus and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles ADD_BOOKING.REQUEST and what does it do? A: It uses takeEvery(ADD_BOOKING.REQUEST, handleAddBooking) to call addBooking, upload files, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles UPDATE_BOOKING.REQUEST and what does it do? A: It uses takeEvery(UPDATE_BOOKING.REQUEST, handleUpdateBooking) to call updateBooking, upload files, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles VALIDATE_RECURRING_BOOKING.REQUEST and what does it do? A: It uses takeEvery(VALIDATE_RECURRING_BOOKING.REQUEST, handleValidateRecurringBooking) to call validateRecurringBooking and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles RECURRING_BOOKING.REQUEST and what does it do? A: It uses takeEvery(RECURRING_BOOKING.REQUEST, handleRecurringBooking) to call recurringBooking and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_AMENITY_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_AMENITY_DETAIL.REQUEST, handleGetAmenityDetail) to call getAmenityDetail, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_AMENITIES.REQUEST and what does it do? A: It uses takeEvery(GET_AMENITIES.REQUEST, handleGetAmenities) to call getAmenities and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_ALL_BOOKING_PURPOSE.REQUEST and what does it do? A: It uses takeEvery(GET_ALL_BOOKING_PURPOSE.REQUEST, handleGetBookingPurpose) to call getBookingPurpose and dispatch SUCCESS or FAILURE."}
{"text": "Reducer & State Management"}
{"text":"Q: What does GET_BOOKING_STATUS.SUCCESS do in the reducer? A: It sets state.statusList = payload, populating booking status options."}
{"text":"Q: How does FILTER_BOOKINGS.REQUEST update the ListModel? A: It calls state.list.setPage(action.payload.page) and deep-clones list to track pagination."}
{"text":"Q: What does FILTER_BOOKINGS.SUCCESS do in the reducer? A: It calls state.list.setData(payload) and deep-clones list to store filtered bookings."}
{"text":"Q: What does GET_ALL_TIMESLOTS.REQUEST do in the reducer? A: It clears state.bookingSlots = [] before new timeslot data arrives."}
{"text":"Q: What does GET_ALL_TIMESLOTS.SUCCESS do in the reducer? A: It sets state.bookingSlots = payload, storing available slots."}
{"text":"Q: What does GET_BOOKING_DETAIL.SUCCESS do in the reducer? A: It sets state.bookingDetail = payload, storing the fetched reservation details."}
{"text":"Q: What does GET_PAYMENT_STATUS.SUCCESS do in the reducer? A: It sets state.paymentStatusList = payload, populating payment status options."}
{"text":"Q: What does RESET_BOOKING_DETAIL do in the reducer? A: It sets state.bookingDetail = null, clearing any displayed reservation detail."}
{"text":"Q: What does GET_AMENITY_DETAIL.REQUEST do in the reducer? A: It sets state.amenityDetail = null to clear previous amenity data before loading."}
{"text":"Q: What does GET_AMENITY_DETAIL.SUCCESS do in the reducer? A: It sets state.amenityDetail = payload, storing the fetched amenity detail."}
{"text":"Q: What does GET_AMENITIES.SUCCESS do in the reducer? A: It filters payload for active items into state.amenityList and tags all items (active/inactive) into state.amenitiesFilter."}
{"text":"Q: What does GET_ALL_BOOKING_PURPOSE.SUCCESS do in the reducer? A: It sets state.bookingPurposes = payload, populating reservation-purpose options."}
{"text":"Q: What is the reducer’s default-case behavior? A: It returns the unchanged state for any unhandled action type, preserving existing data."}
{"text": "Business Logic & Side Effects"}
{"text":"Q: Why upload files after addBooking and updateBooking? A: Because the backend returns a GUID on create/update which is needed to associate uploaded files, so uploads occur only if payload.files exists."}
{"text":"Q: Why clear bookingSlots on GET_ALL_TIMESLOTS.REQUEST? A: To remove stale slot data before fetching fresh availability."}
{"text":"Q: Why reset amenityDetail on GET_AMENITY_DETAIL.REQUEST? A: To prevent previous amenity data from displaying while the new detail is loading."}
{"text":"Q: What transformation does GET_AMENITIES.SUCCESS perform for amenitiesFilter? A: It adds a `tagName: 'INACTIVE'` to inactive items, enabling UI to mark them accordingly."}
{"text":"Q: Why use withLoadingAndErrorHandling for long-running calls? A: To automatically toggle a loading spinner in the UI during operations like file uploads or recurring-booking validation."}
{"text":"Q: How does validateRecurringBooking improve UX before scheduling? A: It lets the backend verify date/rule validity and returns errors before committing a series of bookings."}
{"text":"Q: Why separate validateRecurringBooking and recurringBooking calls? A: To allow pre-flight validation of recurrence rules before actually creating multiple reservations."}
{"text":"Q: Why use withErrorHandling for simple lookups like getBookingStatus? A: Because they only need error dispatching without a global loading spinner, reducing unnecessary UI blocking."}
{"text":"Q: How does resetBookingDetailRequest improve navigation flows? A: Components dispatch it on unmount to clear detail state, preventing stale data when revisiting the booking screen."}
{"text":"Q: Why wrap filterBookings in withErrorHandling rather than manual dispatch? A: To reduce boilerplate by automatically dispatching REQUEST/SUCCESS/FAILURE while still reporting errors to the user."}