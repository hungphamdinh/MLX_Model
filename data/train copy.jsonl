{"text":"Q: Why are `getTaskSetting` and `getTaskPropertyConfig` called immediately in the initialization effect? A: These API calls fetch configuration data (like reminder defaults and dynamic form field settings) needed to render the form correctly before any user interaction."}
{"text":"Q: What is the purpose of `getTaskDetail(id)` in edit modes? A: It retrieves the existing task’s details (fields, schedule, reminders) so the form can be populated for editing rather than creating a new task."}
{"text":"Q: Why does the component call `getTenantsTaskDetail()` when `isControlOffice` is true? A: Control office users need access to all tenants’ data, so this API fetches tenant information for selection in the form."}
{"text":"Q: How does `getEmployeesByTenant({ keyword, page, tenantId, isCO })` optimize employee loading? A: It performs a paginated, filtered API request to only load relevant employees for the chosen tenant, reducing initial load and supporting search."}
{"text":"Q: Why use `getUsersInTeamByTenants({ teamIds, tenantId, teamCoIds })` in `handleTeamChange`? A: This API fetches the assignees belonging to the selected teams (including control office teams), keeping the assignee list in sync with team selection."}
{"text":"Q: What does `getTeamsForTaskDetail({ tenantId, isCO })` do differently from `getTeamsByUsers`? A: It retrieves all teams available for the given tenant context (rather than just teams assigned to the current user), which is necessary when toggling between team-first and assignee-first workflows."}
{"text":"Q: Why is `getFileByReferenceId({ referenceId, tenantId })` invoked in `getInitialValuesForUpdate`? A: It loads attachments linked to the existing task or series, ensuring file picker displays current files for editing."}
{"text":"Q: How does the component decide between `addTask` and `updateTask` when saving? A: It checks `isAddNew` or `isAddNewSubTask` flags to call `addTask` for new entries and `updateTask` for editing existing ones, matching the correct API endpoint."}
{"text":"Q: Why is `transformParams` used before calling `addTask` or `updateTask`? A: It converts the form’s nested values (like user objects and reminder settings) into a flat payload of IDs and primitives that the backend API expects."}
{"text":"Q: What role does `removeUnnecessaryProperties` play in preparing the API payload? A: It strips out any form fields not required by the API (such as UI-only flags), reducing payload size and preventing backend validation errors."}
{"text":"Q: How does `askOverrideSchedule` integrate with API calls for recurring tasks? A: It prompts the user before calling the API to update a series, ensuring they acknowledge that editing will apply to all occurrences via the API call."}
{"text":"Q: Why wrap the API call in `askOverrideSchedule` callback? A: To defer execution of `updateTask` until the user confirms, preventing unintended overwrites of a task series in the backend."}
{"text":"Q: What error condition is checked before submitting a daily recurrence? A: The code calculates the date range and shows an error toast if it exceeds 90 days, preventing an invalid payload from reaching the API."}
{"text":"Q: How does `setUpApprovals(payload)` differ from a regular update API call? A: It sends pending changes and approval metadata to a dedicated approvals API, triggering a workflow rather than immediately updating the task."}
{"text":"Q: Why is `DeviceEventEmitter.emit('ReloadTM')` called after successful API calls? A: To notify other components (like task lists) to refresh their data from the API, ensuring UI consistency after a change."}
{"text":"Q: Why does the component use `useEffect(() => { initialize(); ... }, []);` with an empty dependency array? A: To perform one-time setup on mount—fetching task settings, property configs, and task details if editing—and to register a cleanup that resets the task detail on unmount, preventing stale data."}
{"text":"Q: What does the `initialize` function inside the first `useEffect` do? A: It calls `getTaskSetting()` and `getTaskPropertyConfig()` to load form configuration, and conditionally calls `getTaskDetail(id)` when in edit mode to populate the form with existing task data."}
{"text":"Q: Why is `getTenantsTaskDetail()` called inside the same `useEffect` only if `isControlOffice` is true? A: Control-office users need access to all tenant records, so that API fetch is triggered once on mount for those users to populate the tenant dropdown."}
{"text":"Q: Why does the second `useEffect` depend on `[isPublic]` and call `onChangeTenantId(tenant)`? A: Whenever the public/site toggle changes, it must re-fetch teams or assignees for the current tenant, so this effect listens to `isPublic` and updates the tenant selection accordingly."}
{"text":"Q: What is the purpose of the `useEffect` watching `[taskDetail]` and calling `formMethods.reset(getInitialValuesForUpdate())`? A: When the API returns new `taskDetail` (e.g., after `getTaskDetail`), this effect resets the form to the fetched values, ensuring the form fields reflect the latest data from the server."}
{"text":"Q: How does the `useEffect` that watches `[reminder?.isActive, assignees]` manage API-driven state? A: It syncs the reminder settings with assignee selection—when reminders are activated or assignees change, it rebuilds the reminder users list and updates the form value, ensuring API payloads include the correct user IDs."}
{"text":"Q: Why is there a `useEffect` listening to `[taskSetting]` that sets initial reminder values? A: After fetching `taskSetting` from the API (which contains default reminder config), this effect initializes the form’s reminder fields—only on create mode—so the UI shows correct defaults."}
{"text":"Q: What does the `useEffect` monitoring `[_.size(files)]` do with API data? A: It watches the number of attached files and, when files change (e.g., after upload or deletion), sets the form’s `files` field to the latest `files` array from the API, keeping attachments in sync."}
{"text":"Q: Why is the form wrapped in <FormProvider {...formMethods}>? A: Wrapping in FormProvider makes the React Hook Form context available to all nested form components so they can register fields, access form state, and trigger validation without prop drilling."}
{"text":"Q: What role does useCompatibleForm({ resolver, defaultValues }) play compared to useForm? A: useCompatibleForm is a custom wrapper around useForm that applies the Yup validation resolver, sets default values, and handles any library compatibility quirks, simplifying setup across components."}
{"text":"Q: How does the Yup resolver integrate with React Hook Form in this code? A: The useYupValidationResolver(validationSchema) hook creates a function that React Hook Form calls to synchronously validate field values against the Yup schema, returning formatted error objects for rendering."}
{"text":"Q: Why are watch(['teamIds','assignees',...]) and array destructuring used? A: watch subscribes to specified fields and returns their current values; destructuring lets you capture multiple watched values in one line and trigger effects when any of them change."}
{"text":"Q: When and why is setValue('reminder', {...}) used? A: setValue is called imperatively inside effects to update complex nested fields (like reminder.users and reminder.userIds) when assignees or reminder activation change, ensuring the form state stays in sync with business logic."}
{"text":"Q: What happens when formMethods.reset(getInitialValuesForUpdate()) is called inside a useEffect? A: Invoking reset replaces all current form values with the object returned by getInitialValuesForUpdate(), reinitializing the form whenever the fetched taskDetail changes (e.g., after loading data in edit mode)."}
{"text":"Q: How does <FieldPrefixProvider prefix=\"TM_FFC_\"> affect form field names? A: FieldPrefixProvider prepends the given prefix to every nested field name, preventing name collisions and allowing dynamic generation of unique field identifiers in configurable forms."}
{"text":"Q: Why use both FormLazyDropdown and FormDropdown components? A: FormLazyDropdown fetches options on demand (useful for large lists like tenants or employees), while FormDropdown uses a preloaded options array; both integrate with React Hook Form via name and internal registration hooks."}
{"text":"Q: What does handleChangeAssignee(value, fromOnChange) do in form handling? A: It maps selected assignees to the internal taskAssigns array, updates reminder users and userIds fields, and optionally marks that reminders should be set up based on the fromOnChange flag."}
{"text":"Q: How does handleTeamChange(selectedTeams, selectedTenant) affect form values? A: It clears current assignees, fetches new users via getUsersInTeamByTenants for the selected teams, and updates the form's teams and users dropdowns based on the API response."}
{"text":"Q: Why wrap the save logic with formMethods.handleSubmit(handleSave)? A: handleSubmit performs validation according to the Yup schema and prevents calling handleSave unless the form data is valid, ensuring the payload meets required constraints."}
{"text":"Q: What is the role of FormDisabledProvider around the form? A: It disables all nested form inputs when isReadOnly is true, preventing edits by users without update permission and visually indicating non-editable state."}
{"text":"Q: How does the Submit button trigger form submission? A: The button’s onPress calls attemptSave, which runs the HOC’s approval logic before invoking formMethods.handleSubmit(handleSave) to perform validation and API submission."}
{"text":"Q: What does submitRecurrence(recurrence, isInit) do in RecurrenceSetting? A: It sets the form’s recurrence value and the isCurrentSchedule flag based on whether it’s the initial load or a user change, enabling the schedule UI and controlling override behavior on save."}
{"text":"Q: What does removeRecurrence() do? A: It sets isRemoveRecurrence to true and clears the recurrence value, marking the form to remove any existing schedule when saving."}
{"text":"Q: How do Reminder’s onActivateReminder and onChange callbacks work? A: onActivateReminder flips the allowSetUpReminder flag causing the reminder effect to sync users, while onChange(reminderData) updates the form’s nested reminder fields directly based on user input."}
{"text":"Q: Why are setTimeStart(startDate) and setTimeEnd(endDate) used before saving? A: They normalize dates to the start and end of day respectively, ensuring the schedule payload covers full-day ranges for recurring tasks."}
{"text":"Q: How does attemptSave integrate with ApprovalModal? A: attemptSave wraps handleSubmit(handleSave) and, if approvals are required, triggers the ApprovalModal flow before final submission, ensuring change requests go through the approval process."}
{"text":"Q: What happens in handleApprove(userApprovals)? A: handleApprove builds an approvals payload with levels and pending changes, calls setUpApprovals, resets the form changes, and re-submits the save with approved values."}
{"text":"Q: How does askOverrideSchedule(callback) affect saving recurring tasks? A: It shows a confirmation alert to the user and only invokes the provided callback if the user confirms, preventing unintentional overwriting of all occurrences in a series."}
{"text":"Q: What is handlerMap.date(v) used for? A: It formats a date value using formatDate and the fullDateTimeFormat locale, or returns v unchanged if falsy."}
{"text":"Q: How does handlerMap.ids(values, options, labelField) format multiple IDs? A: It maps each ID to its corresponding labelField in options, filters out missing labels, and joins them with commas, falling back to joining raw values if needed."}
{"text":"Q: What does handlerMap.dropdown(v) handle? A: It joins an array of dropdown items’ displayName properties into a comma-separated string or returns the value if it’s not an array."}
{"text":"Q: What does the approvalFields array represent? A: It lists the fieldNames from config that have isAllowApprove=true, indicating which form fields require approval on change."}
{"text":"Q: Why use useMemo for pendingMap? A: To efficiently compute a map of pending changes only when detailInfo or fieldsChange change, avoiding unnecessary recalculations on every render."}
{"text":"Q: How are oldValue and newValue determined in pendingMap? A: For each changed field, the code retrieves raw values from detailInfo or fieldsChange, applies the handler if available, and stores both the original and formatted values."}
{"text":"Q: What does the useEffect with watch subscription do? A: It listens to form field changes for approvalFields and updates fieldsChange state whenever a tracked field changes, so pendingMap can detect these changes."}
{"text":"Q: How does attemptSave decide between opening the approval modal and submitting? A: It checks if any changed fieldNames require approval by comparing fieldsChange keys against config, then shows the modal if needed or calls submit() directly."}
{"text":"Q: What does setApprovalModalVisible control? A: It toggles the visibility of the ApprovalModal, allowing the UI to display or hide the modal when approvals are needed."}
{"text":"Q: What is the purpose of FormFieldConfigurable? A: It wraps form fields to inject config-based props (required, disabled, editable) and displays pending changes inline by matching config keys to child components."}
{"text":"Q: How does FormFieldConfigurable determine which fields to configure? A: It uses each child’s fieldKey prop (or label) to look up a matching config item by key, then applies isMandatory and isEditable flags accordingly."}
{"text":"Q: What does updateFieldNameConfig(match) do? A: It records the field’s metadata (including its fieldName) in an external map so other logic (like approval handling) knows which fields to watch."}
{"text":"Q: How are pendingMap entries rendered? A: If pendingMap contains an entry for a child’s name, the component clones the child with its oldValue and renders the pending newValue in red underneath."}
{"text":"Q: How does disableApprovals affect field behavior? A: When disableApprovals is true, any config items with isAllowApprove=true get forced disabled, preventing edits until approvals are cleared."}
{"text":"Q: Why use React.cloneElement and React.Children.map? A: cloneElement lets you apply new props to a child element, while Children.map ensures nested children are processed recursively for deep configurations."}
{"text":"Q: What Role do PropTypes play here? A: They enforce at runtime that config is an array of properly shaped objects and that the component receives valid children and flags, helping catch misuses early."}
{"text":"Q: Why does Reminder use useCompatibleForm with defaultValues? A: It initializes the React Hook Form with both the incoming initialValues and default placeholders (newReminderBefore/After), ensuring controlled inputs have proper starting state."}
{"text":"Q: How does the empty-deps useEffect fetching employees work? A: The effect with `[]` dependencies calls `getEmployees({page:1})` once on mount to load the user list for the dropdown."}
{"text":"Q: What does the useEffect watching [initialValues] do? A: When `initialValues` prop changes (e.g. editing existing reminders), it resets all form fields to those values via `formMethods.reset`."}
{"text":"Q: How does the timeUnitSuffix effect update labels? A: It listens to `configure.timeUnit` and sets `timeUnitSuffix` to the correct localized string (days, hours, or minutes) whenever that prop changes."}
{"text":"Q: What do convertToMinutes(value) and convertMinutesToUnit(minutes) do? A: They convert between the configured unit (days/hours/minutes) and raw minutes for storage, allowing the UI to show human-friendly units but keep a consistent minute-based payload."}
{"text":"Q: How does addReminder(type) manage new reminder entries? A: It reads the raw input, converts it to minutes, prevents duplicates with an error, then appends and sorts the reminders array before clearing the input field."}
{"text":"Q: How are emails validated and added? A: onCheckEmail runs `validateEmail`, shows an error toast if invalid, otherwise calls addEmailAndResetInput to push the new address into the emails array and clear the input."}
{"text":"Q: How does the watch-subscription effect notify the parent? A: A useEffect subscribes to all form value changes via `watch`, and on each change it calls `onChange(value)` so the parent always has the latest reminder state."}
{"text":"Q: Why wrap everything in <FormProvider {...formMethods}>? A: To supply the RHF context (methods, state, watch, setValue) to all nested form components (inputs, dropdowns, switches) without prop drilling."}
{"text":"Q: How are removeEmail and handleRemove(type, index) implemented? A: removeEmail filters out a single address from `emails`, while handleRemove filters out a selected minute value from either the before or after reminders list."}
{"text":"Q: What is the purpose of FieldPrefixProvider? A: It automatically prefixes form field labels and placeholders based on a given prefix, reducing manual prop management for internationalization or naming conventions."}
{"text":"Q: How does FieldPrefixProvider determine which fields to prefix? A: It uses each child’s fieldKey prop or its original label string to compute the base key, skipping any keys listed in the excludeKeys array."}
{"text":"Q: When does FieldPrefixProvider skip prefixing? A: If the baseKey is missing, if it’s included in excludeKeys, or if the label already starts with the prefix, the provider leaves props unchanged."}
{"text":"Q: How are placeholders handled when prefixing? A: If a child’s original placeholder matches its label, the provider mirrors the new prefixed label as the placeholder; otherwise, it preserves any custom placeholder."}
{"text":"Q: Why use React.cloneElement and recursion? A: cloneElement lets the provider inject new props into each element, and recursion via React.Children.map ensures nested children also receive prefixing where appropriate."}
{"text":"Q: What is the role of RecurrenceSetting? A: It displays the current recurrence summary via InfoText and toggles the visibility of ConfigRecurrenceModal when the user taps it."}
{"text":"Q: How does RecurrenceSetting read the current recurrence value? A: It uses useCommonFormController('recurrence') to subscribe to the RHF form context and extract the 'recurrence' field’s current value."}
{"text":"Q: Why does RecurrenceSetting compute color from value? A: It uses Colors.text if a recurrence exists or Colors.placeholder if not, visually indicating to the user whether a selection has been made."}
{"text":"Q: What props does RecurrenceSetting pass to ConfigRecurrenceModal? A: It forwards schedule, onSubmitForm, onRemove, showDuration, and visible/onClose handlers to control modal behavior."}
{"text":"Q: Why does ConfigRecurrenceModal build frequencyOptions and related arrays? A: To provide dropdown choices for daily, weekly, monthly, and yearly frequencies, as well as sub-options like days-of-week and ordinal positions."}
{"text":"Q: What default form state does ConfigRecurrenceModal initialize? A: It sets a defaultValues object including frequency=daily, every='1', empty dayOfWeeks, onType=first daily type, startTime=9 AM, durations=30, today’s date as startDate, undefined endDate, and isNearestWeekday=false."}
{"text":"Q: How does transformFromCronExpression work? A: It splits the cronExpression string, extracts fields (dayOfMonth, month, dayOfWeek), determines the recurrence frequency, and maps those pieces into the form schema object."}
{"text":"Q: Why use useEffect(() => {...}, [schedule]) with isInitial? A: When schedule prop first arrives and isInitial is false, it transforms and resets the form to the existing schedule, calls onSubmit for initial load, then sets isInitial=true to avoid re-running."}
{"text":"Q: What does handleRemove do in ConfigRecurrenceModal? A: It displays a confirmation Alert; if the user confirms, it calls onRemove(), resets the form to initialValues, and closes the modal."}
{"text":"Q: How is transformToCronExpression implemented? A: It reconstructs a cron expression string from form inputs (frequency, onDay, every, dayOfWeeks, startTime, isNearestWeekday) to send back to the server."}
{"text":"Q: What helper functions support cron transformation? A: checkCronValueBlank checks for '*' or '0'; parseZeroTime converts '00' to '0'; term and sanitizeInput strip trailing punctuation from numeric inputs."}
{"text":"Q: How does onChangeDay(text, key, nestedKey) update nested form values? A: It sanitizes the input text, then either sets a top-level field or updates a nested property (like onDay.name) using RHF’s setFieldValue."}
{"text":"Q: How is the Accept button enabled or disabled? A: disabledBtn is true if endDate is missing, required onDay or dayOfWeeks aren’t selected based on frequency, or durations is missing when showDuration=true, preventing invalid submissions."}
{"text":"Q: Why wrap form fields in <FormProvider>? A: To supply formMethods (including watch, setFieldValue, handleSubmit) to nested FormInput, FormDropdown, FormDate, and FormCheckBox components without prop drilling."}
{"text":"Q: How does ConfigRecurrenceModal handle submission? A: The primary button calls handleSubmit(onSubmit), which transforms form params to cronExpression, resets the form, closes the modal, and calls onSubmitForm(params, isInit)."}  
{"text":"Q: What is the purpose of ApprovalSection? A: It renders Approve/Reject buttons for the current user when they have a pending approval entry and all earlier approval levels are completed."}
{"text":"Q: How does ApprovalSection determine the current user’s approval entry? A: It finds the entry in jrDetail.workOrderApprovalMatrixs where approverUserId matches the logged-in user’s ID."}
{"text":"Q: What does prevLevelsApproved check? A: It verifies that every matrix entry with a lower level than the current user’s entry has isApproved=true, ensuring approvals happen in order."}
{"text":"Q: Why does ApprovalSection return null in some cases? A: It hides the section if the user has no entry (myEntry), previous levels aren’t all approved, or the user’s entry is already approved (myEntry.isApproved)."}
{"text":"Q: What does handleDecision(isApprove) do? A: It shows a confirmation Alert; on confirm it builds a payload (including optional rejectionReason), calls approveChange or rejectChange, emits a reload event, and navigates back."}
{"text":"Q: Why use Alert.alert before calling approveChange/rejectChange? A: To prompt the user for confirmation and prevent accidental approvals or rejections."}
{"text":"Q: What is DeviceEventEmitter.emit('UpdateListWorkOrder') for? A: It notifies other parts of the app (such as a job request list) to refresh their data after an approval decision."}
{"text":"Q: How does NavigationService.goBack() integrate here? A: After the approval API call and event emission, it navigates back to the previous screen, closing the current detail view."}
{"text":"Q: Why wrap buttons in styled components ApproverRow and ApproverButton? A: To apply consistent layout, spacing, and alignment via styled-components, keeping presentation concerns separate from logic."}
{"text":"Q: How are RejectLabel and ApproveLabel styled? A: They use Text components with colors set to Colors.red and Colors.success respectively, visually indicating the action type."}

{"text": "API Handler Wrappers"}
{"text":"Q: Why wrap RequestApi calls in individual async functions in the hook? A: To encapsulate each API endpoint behind a named method, allowing handler wrappers to uniformly manage side effects and dispatch actions."}
{"text":"Q: How does withErrorHandling enhance getPriorityList? A: It dispatches GET_PRIORITY_LIST.REQUEST before the call, then GET_PRIORITY_LIST.SUCCESS or GET_PRIORITY_LIST.FAILURE after, centralizing error dispatch without loading states."}
{"text":"Q: What additional behavior does withLoadingAndErrorHandling add for addTask? A: It also dispatches loading state actions (e.g., SET_LOADING) around the API call so the UI can show spinners while the request is in progress."}
{"text":"Q: Why import useHandlerAction alongside useStateValue? A: useHandlerAction provides the handler wrappers (withErrorHandling, withLoadingAndErrorHandling) that bind API methods to Redux action lifecycles."}
{"text":"Q: How does generateAction facilitate consistent action type creation? A: It takes a base string (e.g., 'taskManagement/GET_TASK_LIST') and returns .REQUEST, .SUCCESS, and .FAILURE constants automatically."}
{"text":"Q: Why include RequestApi.getTMTeamList in getTeamsByTenant? A: To call the shared team-list endpoint with specific params (target:'TaskManagement', isActive:true) while letting the wrapper manage dispatch."}
{"text":"Q: How does getMentionUsers leverage both transformMentionUsers and getCacheKey? A: The async method returns a structured object so the handler can dispatch GET_MENTION_USER.SUCCESS with both data and cache key for the reducer."}
{"text":"Q: What does getTaskList(params) wrap? A: It wraps RequestApi.getTaskList(params) to fetch a paginated list of tasks and returns the response."}
{"text":"Q: What does getPriorityList() wrap? A: It wraps RequestApi.getPriorityList() to retrieve the priority options for tasks and returns the response."}
{"text":"Q: What does getTeamsByTenant(params) wrap? A: It wraps RequestApi.getTMTeamList({ ...params, target:'TaskManagement', isActive:true }) to fetch active teams for a given tenant."}
{"text":"Q: What does getCurrentTeamList() wrap? A: It wraps RequestApi.getCurrentTeamList() to fetch teams assigned to the current user context."}
{"text":"Q: What does getAssigneeList(params) wrap? A: It wraps RequestApi.getUsersInTeamByTenant(params) to fetch users for a specific team and returns the response."}
{"text":"Q: What does getUsersInTeamByTenants(params) wrap? A: It wraps RequestApi.getUsersInTeamByTenants(params) to fetch users across multiple teams in one call."}
{"text":"Q: What does getTaskDetail(taskId) wrap? A: It wraps RequestApi.getTaskDetail(taskId) to fetch detailed information for a single task by its ID."}
{"text":"Q: What does addTask(payload) wrap? A: It wraps RequestApi.addTask or RequestApi.addTaskWithSchedule based on payload.schedule, then handles file uploads and navigation."}
{"text":"Q: What does updateTask(payload) wrap? A: It wraps RequestApi.updateTask or RequestApi.updateTaskWithSchedule based on payload.isSeries, then handles file uploads and navigation."}
{"text":"Q: What does getStatusList() wrap? A: It wraps RequestApi.getStatusList() to retrieve the status options for tasks and returns the response."}
{"text":"Q: What does addComment(params) wrap? A: It wraps RequestApi.addComment(params) to submit a new comment for a task and returns the response."}
{"text":"Q: What does getCommentByTask(params) wrap? A: It wraps RequestApi.getCommentByTask(params) to fetch comments for a given task and returns the response."}
{"text":"Q: What does getEmployeesByTenant(params) wrap? A: It wraps RequestApi.getListEmployeesByTenant(params) to fetch a paginated list of employees for a tenant."}
{"text":"Q: What does getTeamsForTaskDetail(params) wrap? A: It wraps RequestApi.getTMTeamList({ ...params, target:'TaskManagement', isActive:true }) to fetch teams related to an existing task."}
{"text":"Q: What does getTenantsTaskDetail(params) wrap? A: It wraps RequestApi.getTenantList({ ...params, editionIdSpecified:false, skipCount:0 }) to fetch the list of tenants."}
{"text":"Q: What does getTaskSetting() wrap? A: It wraps RequestApi.getTaskSetting() to fetch configuration settings for tasks, like default reminder intervals."}
{"text":"Q: What does getFileByReferenceId(params) wrap? A: It wraps RequestApi.getTaskFileReference(params) to fetch files attached to a task or schedule document by referenceId."}
{"text":"Q: What does setUpApprovals(params) wrap? A: It wraps RequestApi.setUpAprrovals(params) to submit pending changes for approval workflow initiation."}
{"text":"Q: What does approveChange(params) wrap? A: It wraps RequestApi.approveChange(params) to record an approval decision for a pending change."}
{"text":"Q: What does rejectChange(params) wrap? A: It wraps RequestApi.rejectChange(params) to record a rejection decision, including an optional rejectionReason."}
{"text":"Q: What does getTaskPropertyConfig() wrap? A: It wraps RequestApi.getTaskPropertyConfig() to fetch dynamic form field configurations for tasks."}
{"text": "Action & Saga Integration"}
{"text":"Q: What lifecycle actions occur when getTaskDetail is called? A: withLoadingAndErrorHandling dispatches GET_TASK_DETAIL.REQUEST, then on success GET_TASK_DETAIL.SUCCESS, or GET_TASK_DETAIL.FAILURE on error."}
{"text":"Q: How does resetTaskDetailRequest integrate with sagas? A: It dispatches RESET_TASK_DETAIL, which a saga or reducer listens for to clear taskDetail state without invoking an API."}
{"text":"Q: Why are REQUEST, SUCCESS, and FAILURE actions important? A: They demarcate each phase of an async operation, enabling sagas to trigger side effects on REQUEST and letting reducers handle state changes appropriately."}
{"text":"Q: How would a saga watch for UPDATE_TASK actions? A: A saga uses takeEvery(UPDATE_TASK.REQUEST, workerUpdateTask) to perform the API call and then dispatch UPDATE_TASK.SUCCESS or FAILURE based on the outcome."}
{"text":"Q: What action constant pattern is used for addComment? A: ADD_COMMENT.REQUEST is dispatched at call start, then ADD_COMMENT.SUCCESS or ADD_COMMENT.FAILURE is dispatched when the API resolves."}
{"text":"Q: How does withLoadingAndErrorHandling know which actions to dispatch? A: It receives the base constant (e.g., ADD_TASK) and automatically appends .REQUEST, .SUCCESS, and .FAILURE when wrapping the provided method."}
{"text":"Q: Which saga watches GET_TASK_LIST.REQUEST and what does it do? A: A watcher saga uses takeEvery(GET_TASK_LIST.REQUEST, handleGetTaskList) to call the API and dispatch GET_TASK_LIST.SUCCESS or FAILURE based on the response."}
{"text":"Q: Which saga watches GET_PRIORITY_LIST.REQUEST and what does it do? A: A watcher saga uses takeEvery(GET_PRIORITY_LIST.REQUEST, handleGetPriorityList) to fetch priorities and dispatch GET_PRIORITY_LIST.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_TEAMS_BY_TENANT.REQUEST and what does it do? A: It uses takeEvery(GET_TEAMS_BY_TENANT.REQUEST, handleGetTeamsByTenant) to call getTMTeamList and dispatch success or failure actions."}
{"text":"Q: Which saga watches GET_CURRENT_TEAMS.REQUEST and what does it do? A: It uses takeEvery(GET_CURRENT_TEAMS.REQUEST, handleGetCurrentTeamList) to fetch the user’s teams and dispatch GET_CURRENT_TEAMS.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_ASSIGNEE_LIST.REQUEST and what does it do? A: It uses takeEvery(GET_ASSIGNEE_LIST.REQUEST, handleGetAssigneeList) to fetch team users and dispatch GET_ASSIGNEE_LIST.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_USERS_IN_TEAMS_BY_TENANTS.REQUEST and what does it do? A: It uses takeEvery(GET_USERS_IN_TEAMS_BY_TENANTS.REQUEST, handleGetUsersInTeamByTenants) to batch-fetch users across teams."}
{"text":"Q: Which saga watches GET_TASK_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_TASK_DETAIL.REQUEST, handleGetTaskDetail) to fetch task details and dispatch GET_TASK_DETAIL.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches ADD_TASK.REQUEST and what does it do? A: It uses takeEvery(ADD_TASK.REQUEST, handleAddTask) to call addTask API, upload files, navigate back, and dispatch ADD_TASK.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches UPDATE_TASK.REQUEST and what does it do? A: It uses takeEvery(UPDATE_TASK.REQUEST, handleUpdateTask) to update tasks or series, upload files, navigate back, and dispatch UPDATE_TASK.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_STATUS_LIST.REQUEST and what does it do? A: It uses takeEvery(GET_STATUS_LIST.REQUEST, handleGetStatusList) to fetch statuses and dispatch GET_STATUS_LIST.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_MENTION_USER.REQUEST and what does it do? A: It uses takeEvery(GET_MENTION_USER.REQUEST, handleGetMentionUsers) to transform and cache mention data."}
{"text":"Q: Which saga watches ADD_COMMENT.REQUEST and what does it do? A: It uses takeEvery(ADD_COMMENT.REQUEST, handleAddComment) to submit a comment and dispatch ADD_COMMENT.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_COMMENT_BY_TASK.REQUEST and what does it do? A: It uses takeEvery(GET_COMMENT_BY_TASK.REQUEST, handleGetCommentByTask) to fetch task comments."}
{"text":"Q: Which saga watches GET_EMPLOYEES_BY_TENANT.REQUEST and what does it do? A: It uses takeEvery(GET_EMPLOYEES_BY_TENANT.REQUEST, handleGetEmployeesByTenant) to paginate tenant employees."}
{"text":"Q: Which saga watches GET_TEAMS_FOR_TASK_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_TEAMS_FOR_TASK_DETAIL.REQUEST, handleGetTeamsForTaskDetail) to load teams for an existing task."}
{"text":"Q: Which saga watches GET_TENANTS_TASK_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_TENANTS_TASK_DETAIL.REQUEST, handleGetTenantsTaskDetail) to load tenant list for control office users."}
{"text":"Q: Which saga watches GET_TASK_SETTING.REQUEST and what does it do? A: It uses takeEvery(GET_TASK_SETTING.REQUEST, handleGetTaskSetting) to fetch default task config (reminders) for the form."}
{"text":"Q: Which saga watches GET_FILE_BY_REFERENCE_ID.REQUEST and what does it do? A: It uses takeEvery(GET_FILE_BY_REFERENCE_ID.REQUEST, handleGetFileByReferenceId) to clear and load attachments."}
{"text":"Q: Which saga watches SET_UP_APPROVAL.REQUEST and what does it do? A: It uses takeEvery(SET_UP_APPROVAL.REQUEST, handleSetUpApprovals) to send pending changes for approvals."}
{"text":"Q: Which saga watches APPROVE_CHANGE.REQUEST and what does it do? A: It uses takeEvery(APPROVE_CHANGE.REQUEST, handleApproveChange) to approve pending changes."}
{"text":"Q: Which saga watches REJECT_CHANGE.REQUEST and what does it do? A: It uses takeEvery(REJECT_CHANGE.REQUEST, handleRejectChange) to reject pending changes with optional reason."}
{"text":"Q: Which saga watches GET_TASK_PROPERTY_CONFIG.REQUEST and what does it do? A: It uses takeEvery(GET_TASK_PROPERTY_CONFIG.REQUEST, handleGetTaskPropertyConfig) to load dynamic form field configs."}
{"text":"Q: What does GET_TASK_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates tasks were fetched successfully; the reducer calls `state.list.setData(payload)` and deep-clones the ListModel to update `state.list`."}
{"text":"Q: What does GET_PRIORITY_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates priorities were fetched successfully; the reducer sets `state.priorityList = payload`."}
{"text":"Q: What does GET_TEAMS_BY_TENANT.SUCCESS indicate, and how does the reducer handle it? A: It indicates team data was fetched successfully; the reducer applies `transformWithCOTags(payload)` and sets `state.teamList`."}
{"text":"Q: What does GET_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates task details were fetched; the reducer sets `state.taskDetail = payload`."}
{"text":"Q: What does ADD_TASK.SUCCESS indicate, and how should the app respond? A: It indicates a new task was created successfully; UI components typically refresh the task list and navigate back (handled by sagas)."}
{"text":"Q: What does UPDATE_TASK.SUCCESS indicate, and how should the app respond? A: It indicates a task update succeeded; UI components refresh the display or navigate back as appropriate."}
{"text":"Q: What does GET_STATUS_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates statuses were fetched; the reducer sets `state.statusList = payload`."}
{"text":"Q: What does GET_MENTION_USER.SUCCESS indicate, and how does the reducer handle it? A: It indicates mentions were fetched; the reducer stores `state.mentionUsersDic[key] = mentionUsers` based on the provided key."}
{"text":"Q: What does ADD_COMMENT.SUCCESS indicate, and how does the reducer handle it? A: It indicates a comment was added; subsequent sagas or components may re-fetch comments, but the reducer does not directly update state here."}
{"text":"Q: What does GET_COMMENT_BY_TASK.SUCCESS indicate, and how does the reducer handle it? A: It indicates comments were fetched; the reducer sets `state.comments = payload`."}
{"text":"Q: What does GET_ASSIGNEE_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates team assignees were fetched successfully; the reducer applies `transformWithCOTags(payload)` and sets `state.assigneeList`."}
{"text":"Q: What does GET_CURRENT_TEAMS.SUCCESS indicate, and how does the reducer handle it? A: It indicates the current user’s teams were fetched; the reducer sets `state.teamList = payload`."}
{"text":"Q: What does GET_STATUS_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates status options were fetched; the reducer sets `state.statusList = payload`."}
{"text":"Q: What does GET_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates detailed information for a task was fetched; the reducer sets `state.taskDetail = payload`."}
{"text":"Q: What does GET_TEAMS_FOR_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates teams for an existing task were fetched; the reducer applies `transformWithCOTags(payload)` and sets `state.teamsTaskDetail`."}
{"text":"Q: What does GET_USERS_IN_TEAMS_BY_TENANTS.SUCCESS indicate, and how does the reducer handle it? A: It indicates users across selected teams were fetched; the reducer applies `transformWithCOTags(payload)` and sets `state.usersInTeams`."}
{"text":"Q: What does GET_EMPLOYEES_BY_TENANT.SUCCESS indicate, and how does the reducer handle it? A: It indicates employees for a tenant were fetched; the reducer transforms items with `transformWithCOTags`, calls `employeesByTenant.setData(payload)`, and deep clones it."}
{"text":"Q: What does GET_TENANTS_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates the tenant list was fetched; the reducer calls `tenantsDetail.setData(payload)`, sets `totalPage = 1`, and returns a deep clone."}
{"text": "Reducer & State Management"}
{"text":"Q: How does the reducer handle GET_TASK_LIST.REQUEST? A: It calls state.list.setPage(page) on the ListModel and then returns a deep clone so Redux detects the change."}
{"text":"Q: What does GET_TASK_LIST.SUCCESS do in the reducer? A: It sets the fetched data on the ListModel via list.setData(payload) and deep-clones the state for immutability."}
{"text":"Q: How are control-office tags applied to team lists? A: On GET_TEAMS_BY_TENANT.SUCCESS and GET_TEAMS_FOR_TASK_DETAIL.SUCCESS, the reducer calls transformWithCOTags before storing in state.teamList or state.teamsTaskDetail."}
{"text":"Q: Why deep-clone ListModel instances after mutation? A: Because ListModel methods mutate internal state, deep cloning ensures a new reference so Redux change detection works correctly."}
{"text":"Q: How does the reducer respond to GET_TENANTS_TASK_DETAIL.REQUEST vs SUCCESS? A: REQUEST resets pagination (page=1, totalPage=1), and SUCCESS populates tenantsDetail.setData(payload) before deep-cloning."}
{"text":"Q: What happens on GET_FILE_BY_REFERENCE_ID.REQUEST? A: The reducer clears state.files to an empty array, removing stale attachments before the new payload arrives."}
{"text":"Q: How are dynamic field configs loaded into state? A: On GET_TASK_PROPERTY_CONFIG.SUCCESS, the reducer prefixes each item’s key with TM_FFC_ and stores them in state.taskPropertyConfigs."}
{"text":"Q: What does the reducer’s default case do? A: It returns the unchanged state for any unrecognized action, preventing unintended state mutations."}
{"text":"Q: When GET_TASK_LIST.REQUEST is dispatched, which saga and reducer cases handle it? A: The saga watcher `takeEvery(GET_TASK_LIST.REQUEST, handleGetTaskList)` calls the API; on success it dispatches GET_TASK_LIST.SUCCESS, which the reducer handles by calling `state.list.setData(payload)` and deep-cloning the ListModel."}
{"text":"Q: How do GET_PRIORITY_LIST.REQUEST, its saga, and reducer integrate? A: `takeEvery(GET_PRIORITY_LIST.REQUEST, handleGetPriorityList)` invokes the priority API, then dispatches GET_PRIORITY_LIST.SUCCESS; the reducer sets `state.priorityList = payload`."}
{"text":"Q: Describe the flow for GET_TEAMS_BY_TENANT.REQUEST through saga and reducer. A: The saga watcher `takeEvery(GET_TEAMS_BY_TENANT.REQUEST, handleGetTeamsByTenant)` calls `getTMTeamList`; on GET_TEAMS_BY_TENANT.SUCCESS the reducer applies `transformWithCOTags` and stores the result in `state.teamList`."}
{"text":"Q: What happens from GET_TASK_DETAIL.REQUEST to the reducer update? A: The saga `takeEvery(GET_TASK_DETAIL.REQUEST, handleGetTaskDetail)` calls the detail API, then dispatches GET_TASK_DETAIL.SUCCESS; the reducer sets `state.taskDetail = payload`."}
{"text":"Q: How is ADD_TASK.REQUEST handled by saga and reducer? A: Under the saga `takeEvery(ADD_TASK.REQUEST, handleAddTask)`, the API call and file uploads occur, navigation is triggered, and then ADD_TASK.SUCCESS is dispatched; the reducer doesn’t store new state here, but components reload the list afterward."}
{"text":"Q: Explain the lifecycle for UPDATE_TASK.REQUEST. A: The saga `takeEvery(UPDATE_TASK.REQUEST, handleUpdateTask)` calls the update API (single or series), uploads files, navigates back, then dispatches UPDATE_TASK.SUCCESS; the reducer may clear pending changes or trigger side-effects via listeners."}
{"text":"Q: Outline how RESET_TASK_DETAIL is processed in saga and reducer. A: RESET_TASK_DETAIL is a plain action (no saga watcher); the reducer listens for RESET_TASK_DETAIL and sets `state.taskDetail = null` to clear the detail state."}
{"text":"Q: What is the flow for GET_COMMENT_BY_TASK.REQUEST? A: The saga `takeEvery(GET_COMMENT_BY_TASK.REQUEST, handleGetCommentByTask)` fetches comments, dispatches GET_COMMENT_BY_TASK.SUCCESS; the reducer then assigns `state.comments = payload`."}
{"text":"Q: How are SET_UP_APPROVAL.REQUEST and APPROVE_CHANGE.REQUEST handled? A: `takeEvery(SET_UP_APPROVAL.REQUEST, handleSetUpApprovals)` sends pending changes; upon SET_UP_APPROVAL.SUCCESS components may re-fetch taskDetail. Similarly, `takeEvery(APPROVE_CHANGE.REQUEST, handleApproveChange)` triggers backend approval and then APPROVE_CHANGE.SUCCESS updates approval state in the reducer."}
{"text":"Q: Describe the GET_TASK_PROPERTY_CONFIG.REQUEST to reducer update. A: The saga `takeEvery(GET_TASK_PROPERTY_CONFIG.REQUEST, handleGetTaskPropertyConfig)` fetches dynamic field configs, dispatches GET_TASK_PROPERTY_CONFIG.SUCCESS; the reducer prefixes each item’s key with `TM_FFC_` and stores them in `state.taskPropertyConfigs`."}
{"text": "Business Logic & Side Effects"}
{"text":"Q: Why call NavigationServices.goBack() after addTask and updateTask? A: To navigate back automatically once the task creation or update (and any file uploads) complete successfully."}
{"text":"Q: How are file uploads coordinated in addTask? A: After the primary API call, the code checks payload.files, derives the correct documentId, and calls RequestApi.uploadTaskManagementFiles."}
{"text":"Q: How does updateTask handle series vs single task updates? A: It checks payload.isSeries or schedule flags to call updateTaskWithSchedule for series or updateTask for single items."}
{"text":"Q: What is setUpApprovals used for? A: It sends pending change details to the approval API, initiating an approval workflow rather than directly updating the task."}
{"text":"Q: How do approveChange and rejectChange differ? A: Both call their respective API, but rejectChange may include a rejectionReason payload, while approveChange sends only approvalMatrixId."}
{"text":"Q: Why return both mentionUsers and key from getMentionUsers? A: So the reducer can cache the transformed user list under the provided key, avoiding duplicate API calls."}
{"text":"Q: How does transformMentionUsers affect caching logic? A: It produces normalized user objects, and getCacheKey ensures each param combination maps to a unique cache entry in state. "}
{"text":"Q: When is resetTaskDetail invoked in business flow? A: Components call resetTaskDetail (dispatch RESET_TASK_DETAIL) in cleanup effects to clear form state when unmounting the detail screen."}
{"text":"Q: How does resetTaskDetailRequest improve UX during navigation? A: By clearing the detail state immediately on unmount or reset, it prevents stale task data from appearing when revisiting the screen."}
{"text":"Q: What side effects does withLoadingAndErrorHandling wrapper trigger beyond dispatching actions? A: It toggles a global loading indicator, allowing the UI to show spinners during long-running operations like file uploads."}
{"text":"Q: How are errors during file uploads handled after addTask/updateTask? A: If uploadTaskManagementFiles fails, withLoadingAndErrorHandling dispatches FAILURE and error state, enabling the app to display an error message."}
{"text":"Q: Why call NavigationServices.goBack() after awaiting file uploads? A: To ensure all side effects complete before navigating away, preventing race conditions and guaranteeing data consistency."}
{"text":"Q: Why include isActive:true when fetching teams? A: To only retrieve active teams, improving performance and UX by excluding inactive entries from dropdowns."}
{"text":"Q: How does getTenantsTaskDetail support control-office workflows? A: By fetching all tenants via RequestApi.getTenantList with editionIdSpecified:false and skipCount:0, it provides the full tenant list for control-office context switching."}
{"text":"Q: Why use _.first(response) when extracting documentId? A: Some schedule APIs return an array; _.first ensures the correct documentId is selected for subsequent file uploads."}
{"text":"Q: What ensures navigation only occurs after file uploads? A: NavigationServices.goBack() is called after awaiting uploadTaskManagementFiles, guaranteeing all uploads finish before leaving the screen."}
{"text":"Feedback"}
{"text":"API Handler Wrappers"}
{"text":"Q: What does getListFB(params) wrap and dispatch? A: It dispatches GET_LIST_FB_REQUEST with params, calls RequestApi.getListFB(params), then dispatches GET_LIST_FB_SUCCESS with the response or GET_LIST_FB_FAILURE on error."}
{"text":"Q: What does getListQRFeedback(params) wrap and dispatch? A: It dispatches GET_LIST_FB_QR_REQUEST, calls RequestApi.getListQRFeedback(params), then dispatches GET_LIST_FB_QR_SUCCESS or GET_LIST_FB_QR_FAILURE on error."}
{"text":"Q: How does addFB integrate with handler wrappers? A: addFB is wrapped by withLoadingAndErrorHandling(ADD_FB) to dispatch ADD_FB.REQUEST, call RequestApi.createFeedback, upload files, then dispatch ADD_FB.SUCCESS or ADD_FB.FAILURE."}
{"text":"Q: How does editFB integrate with handler wrappers? A: editFB is wrapped by withLoadingAndErrorHandling(EDIT_FB) to dispatch EDIT_FB.REQUEST, call RequestApi.updateFeedback, upload files, then dispatch EDIT_FB.SUCCESS or EDIT_FB.FAILURE."}
{"text":"Q: What does editQrFB(params) wrap and dispatch? A: It dispatches EDIT_QR_FB_REQUEST, calls RequestApi.updateQRFeedback(params), then dispatches EDIT_QR_FB_SUCCESS(true) or EDIT_QR_FB_FAILURE(err) on error."}
{"text":"Q: What does detailFB(id) wrap and dispatch? A: It dispatches DETAIL_FB_REQUEST(id), calls RequestApi.getDetailFB(id), then dispatches DETAIL_FB_SUCCESS(response) or DETAIL_FB_FAILURE(err)."}
{"text":"Q: What does detailQRFeedback(id) wrap and dispatch? A: It dispatches DETAIL_FB_QR_REQUEST(id), calls RequestApi.getDetailQRFeedback(id), then dispatches DETAIL_FB_QR_SUCCESS(response) or DETAIL_FB_QR_FAILURE(err)."}
{"text":"Q: What does getSources(params) wrap and dispatch? A: It dispatches GET_SOURCES_REQUEST(params), calls RequestApi.getFeedbackSources(params), then dispatches GET_SOURCES_SUCCESS(response) or GET_SOURCES_FAILURE(err)."}
{"text":"Q: What does getAreas() wrap and dispatch? A: It dispatches GET_AREAS_REQUEST(), calls RequestApi.getAreas(), then dispatches GET_AREAS_SUCCESS(response) or GET_AREAS_FAILURE(err)."}
{"text":"Q: What does getCategories() wrap and dispatch? A: It dispatches GET_CATEGORIES_REQUEST(), calls RequestApi.getFeedbackCategories(), then dispatches GET_CATEGORIES_SUCCESS(response) or GET_CATEGORIES_FAILURE(err)."}
{"text":"Q: What does getTypes() wrap and dispatch? A: It dispatches GET_TYPES_REQUEST(), calls RequestApi.getFeedbackTypes(), then dispatches GET_TYPES_SUCCESS(response) or GET_TYPES_FAILURE(err)."}
{"text":"Q: What does getSubCategories(params) wrap and dispatch? A: It dispatches GET_SUB_CATEGORIES_REQUEST(params), calls RequestApi.getSubCategories(areaId, categoryId), then dispatches GET_SUB_CATEGORIES_SUCCESS(response) or GET_SUB_CATEGORIES_FAILURE(err)."}
{"text":"Q: What does addQuickJR(params) wrap and dispatch? A: It dispatches ADD_QUICK_JR_REQUEST(params), calls RequestApi.requestQuickCreateWorkOrder(params), then dispatches ADD_QUICK_JR_SUCCESS(response) or ADD_QUICK_JR_FAILURE(err)."}
{"text":"Q: What does getQuickJRSetting(params) wrap and dispatch? A: It dispatches GET_QUICK_JR_SETTING_REQUEST(params), calls RequestApi.requestWorkOrderSetting(params), then dispatches GET_QUICK_JR_SETTING_SUCCESS(response) or GET_QUICK_JR_SETTING_FAILURE(err)."}
{"text":"Q: What does getFeedbackStatus() wrap and dispatch? A: It dispatches GET_FEEDBACK_STATUS_REQUEST(), calls RequestApi.getFeedbackStatus(), then dispatches GET_FEEDBACK_STATUS_SUCCESS(response) or GET_FEEDBACK_STATUS_FAILURE(err)."}
{"text":"Q: What does getLocations(payload) wrap and dispatch? A: It dispatches GET_LOCATIONS_REQUEST(payload), calls RequestApi.getListLocation(payload), then dispatches GET_LOCATIONS_SUCCESS(response) or GET_LOCATIONS_FAILURE(err)."}
{"text":"Q: What do getFeedbackDivision() and getQrFeedbackSetting() wrap? A: Both are wrapped by withErrorHandling, calling RequestApi.getFeedbackDivision() and RequestApi.getQrFeedbackSetting(), then dispatching GET_FEEDBACK_DIVISION.SUCCESS or GET_QR_FEEDBACK_SETTING.SUCCESS accordingly."}
{"text":"Q: What does getQuickJRSetting(params) wrap and dispatch? A: It dispatches GET_QUICK_JR_SETTING_REQUEST(params), calls RequestApi.requestWorkOrderSetting(params), then dispatches GET_QUICK_JR_SETTING_SUCCESS(response) or GET_QUICK_JR_SETTING_FAILURE(err)."}
{"text":"Q: What does getFeedbackStatus() wrap and dispatch? A: It dispatches GET_FEEDBACK_STATUS_REQUEST(), calls RequestApi.getFeedbackStatus(), then dispatches GET_FEEDBACK_STATUS_SUCCESS(response) or GET_FEEDBACK_STATUS_FAILURE(err)."}
{"text":"Q: What does getLocations(payload) wrap and dispatch? A: It dispatches GET_LOCATIONS_REQUEST(payload), calls RequestApi.getListLocation(payload), then dispatches GET_LOCATIONS_SUCCESS(response) or GET_LOCATIONS_FAILURE(err)."}
{"text":"Q: What does getFeedbackDivision() wrap? A: It is wrapped by withErrorHandling(GET_FEEDBACK_DIVISION, getFeedbackDivision) to dispatch GET_FEEDBACK_DIVISION.REQUEST, call RequestApi.getFeedbackDivision(), then dispatch GET_FEEDBACK_DIVISION.SUCCESS(response.items) or GET_FEEDBACK_DIVISION.FAILURE(err)."}
{"text":"Q: What does getQrFeedbackSetting() wrap? A: It is wrapped by withErrorHandling(GET_QR_FEEDBACK_SETTING, getQrFeedbackSetting) to dispatch GET_QR_FEEDBACK_SETTING.REQUEST, call RequestApi.getQrFeedbackSetting(), then dispatch GET_QR_FEEDBACK_SETTING.SUCCESS(response) or GET_QR_FEEDBACK_SETTING.FAILURE(err)."}
{"text": "Action & Saga Integration"}
{"text":"Q: Which saga watcher handles GET_LIST_FB_REQUEST? A: A watcher saga uses takeEvery(GET_LIST_FB_REQUEST, handleGetListFB) to call the getListFB worker, then dispatch GET_LIST_FB_SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles ADD_FB.REQUEST? A: takeEvery(ADD_FB.REQUEST, handleAddFB) triggers the addFB flow, uploads files, and dispatches ADD_FB.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles DETAIL_FB_QR_REQUEST? A: takeEvery(DETAIL_FB_QR_REQUEST, handleDetailQRFeedback) invokes the detailQRFeedback worker and dispatches DETAIL_FB_QR_SUCCESS or FAILURE."}
{"text":"Q: What lifecycle actions are dispatched around editFB? A: EDIT_FB.REQUEST at start, then EDIT_FB.SUCCESS on successful update/upload, or EDIT_FB.FAILURE on errors."}
{"text":"Q: How do REQUEST, SUCCESS, and FAILURE actions support the Feedback form? A: They represent each phase of an async call, allowing sagas and reducers to manage loading state, data, and errors for lists, details, and edits."}
{"text":"Q: Why define string constants for GET_LIST_FB_QR_REQUEST/SUCCESS/FAILURE? A: To have explicit action types for saga watchers and reducer cases without generateAction wrappers."}
{"text":"Q: Which saga watches GET_QUICK_JR_SETTING_REQUEST? A: takeEvery(GET_QUICK_JR_SETTING_REQUEST, handleGetQuickJRSetting) calls the API and dispatches GET_QUICK_JR_SETTING_SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_FEEDBACK_STATUS_REQUEST? A: takeEvery(GET_FEEDBACK_STATUS_REQUEST, handleGetFeedbackStatus) to fetch statuses and dispatch corresponding success/failure."}
{"text":"Q: Which saga watches GET_LOCATIONS_REQUEST? A: takeEvery(GET_LOCATIONS_REQUEST, handleGetLocations) to fetch paginated location data and dispatch GET_LOCATIONS_SUCCESS or FAILURE."}
{"text":"Q: How does withLoadingAndErrorHandling differ from manual dispatch in Feedback? A: withLoadingAndErrorHandling auto-dispatches REQUEST/SUCCESS/FAILURE and toggles loading, whereas getListFB manually dispatches actions inside a try/catch."}
{"text":"Q: Which saga watcher handles GET_SUB_CATEGORIES_REQUEST? A: It uses takeEvery(GET_SUB_CATEGORIES_REQUEST, handleGetSubCategories) to call the API and dispatch GET_SUB_CATEGORIES_SUCCESS or GET_SUB_CATEGORIES_FAILURE."}
{"text":"Q: Which saga watcher handles ADD_QUICK_JR_REQUEST? A: It uses takeEvery(ADD_QUICK_JR_REQUEST, handleAddQuickJR) to call requestQuickCreateWorkOrder and dispatch ADD_QUICK_JR_SUCCESS or ADD_QUICK_JR_FAILURE."}
{"text":"Q: Which saga watcher handles GET_FEEDBACK_DIVISION.REQUEST? A: It uses takeEvery(GET_FEEDBACK_DIVISION.REQUEST, handleGetFeedbackDivision) to fetch the division list and dispatch GET_FEEDBACK_DIVISION.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_QR_FEEDBACK_SETTING.REQUEST? A: It uses takeEvery(GET_QR_FEEDBACK_SETTING.REQUEST, handleGetQrFeedbackSetting) to load QR feedback config and dispatch GET_QR_FEEDBACK_SETTING.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles EDIT_FB.REQUEST? A: It uses takeEvery(EDIT_FB.REQUEST, handleEditFB) to wrap updateFeedback, handle file uploads, and dispatch EDIT_FB.SUCCESS or EDIT_FB.FAILURE."}
{"text":"Q: Which saga watcher handles GET_AREAS_REQUEST and what is its flow? A: It uses takeEvery(GET_AREAS_REQUEST, handleGetAreas) to call RequestApi.getAreas and then dispatch GET_AREAS_SUCCESS or GET_AREAS_FAILURE."}
{"text":"Q: Which saga watcher handles GET_CATEGORIES_REQUEST? A: It uses takeEvery(GET_CATEGORIES_REQUEST, handleGetCategories) to fetch feedback categories and dispatch GET_CATEGORIES_SUCCESS or GET_CATEGORIES_FAILURE."}
{"text":"Q: Which saga watcher handles GET_TYPES_REQUEST and what does it do? A: It uses takeEvery(GET_TYPES_REQUEST, handleGetTypes) to invoke RequestApi.getFeedbackTypes and dispatch GET_TYPES_SUCCESS or GET_TYPES_FAILURE."}
{"text": "Reducer & State Management"}
{"text":"Q: How does the Feedback reducer handle GET_LIST_FB_REQUEST? A: It calls state.list.setPage(page) on the ListModel and returns a deep clone to trigger updates."}
{"text":"Q: What happens on GET_LIST_FB_SUCCESS in the reducer? A: It maps each item to enrich fields (id, fullName, phoneNumber, emailAddress), calls list.setData(data), and deep-clones `list`."}
{"text":"Q: How does the reducer handle DETAIL_FB_REQUEST? A: It sets `fbDetail = undefined` and `isLoading = true` to clear previous detail and show a loading indicator."}
{"text":"Q: What does DETAIL_FB_SUCCESS do in state? A: It assigns `fbDetail = payload` and `isLoading = false`, reflecting the loaded feedback detail."}
{"text":"Q: How are sources stored on GET_SOURCES_SUCCESS? A: The reducer sets `state.sources = payload`, updating the dropdown options for feedback sources."}
{"text":"Q: How does GET_AREAS_REQUEST vs GET_AREAS_SUCCESS differ? A: REQUEST clears `state.areas = []`; SUCCESS populates `state.areas = payload`."}
{"text":"Q: How does GET_TYPES_REQUEST vs GET_TYPES_SUCCESS behave? A: REQUEST leaves `state.types` unchanged; SUCCESS sets `state.types = payload`."}
{"text":"Q: How does GET_LOCATIONS_SUCCESS update the ListModel? A: It calls `locations.setData(payload)` then deep-clones `locations` so pagination and items are updated immutably."}
{"text":"Q: What does GET_FEEDBACK_DIVISION.SUCCESS do? A: It sets `state.divisionList = payload`, storing divisions for quick-create work orders."}
{"text":"Q: How is EDIT_QR_FB_REQUEST handled in the reducer? A: It sets `isLoading = true` to indicate the edit operation is in progress."}
{"text":"Q: How is EDIT_QR_FB_SUCCESS handled? A: It sets `isLoading = false` once the QR feedback edit completes successfully."}
{"text":"Q: How does the reducer handle failures like GET_LIST_FB_FAILURE? A: It stores `error = payload`, allowing the UI to display an error message."}
{"text":"Q: What does RESET state on user switch (SWITCH_TO_USER_ACCOUNT_SUCCESS) do? A: It returns INITIAL_STATE, clearing all feedback data when switching accounts."}
{"text":"Q: Why deep-clone ListModel after mutation? A: Because ListModel methods mutate internal state; deep cloning ensures Redux notices the change by new references."}
{"text":"Q: How does DETAIL_FB_QR_FAILURE affect loading state? A: It sets `isLoading = false` without altering `qrFBDetail`, preserving previous data if any."}
{"text":"Q: What is the reducer’s default case behavior? A: It returns the unchanged state for any unknown action type, preventing unintended mutations."}
{"text":"Q: How does the reducer handle GET_SUB_CATEGORIES_REQUEST? A: It typically resets or clears `state.subCategories` before loading new sub-categories."}
{"text":"Q: What does GET_SUB_CATEGORIES_SUCCESS do in the reducer? A: It assigns `state.subCategories = payload`, updating the list based on selected area and category."}
{"text":"Q: How does GET_SUB_CATEGORIES_FAILURE affect state? A: It leaves `state.subCategories` unchanged and may set an error flag, preventing stale data replacement."}
{"text":"Q: What does ADD_QUICK_JR_SUCCESS do in the reducer? A: It may store the response in a `quickJR` slice or trigger a list refresh, indicating successful creation."}
{"text":"Q: How is GET_FEEDBACK_DIVISION.SUCCESS handled? A: The reducer sets `state.divisionList = payload`, making divisions available for quick work order creation."}
{"text":"Q: How is GET_QR_FEEDBACK_SETTING.SUCCESS handled? A: It sets `state.qrFeedbackSetting = payload`, storing QR feedback modal configuration."}
{"text":"Q: What does GET_FEEDBACK_STATUS_REQUEST do to `state.statusList`? A: It typically clears or marks it loading, preparing to fetch status options."}
{"text":"Q: How does GET_FEEDBACK_STATUS_SUCCESS update the store? A: It sets `state.statusList = payload`, populating feedback status dropdown values."}
{"text":"Q: How are feedback errors handled on GET_FEEDBACK_STATUS_FAILURE? A: The reducer retains the previous `statusList` and may store an error flag without clearing existing data."}
{"text":"Q: How does SWITCH_TO_USER_ACCOUNT_SUCCESS reset feedback state? A: It returns `INITIAL_STATE`, clearing all lists, details, loading flags, and configurations for the new user context."}
{"text": "Business Logic & Side Effects"}
{"text":"Q: Why upload files only after receiving a GUID in addFB? A: Because the backend assigns a document ID on creation, which is needed to associate uploaded files correctly."}
{"text":"Q: How does editFB decide which files to upload? A: It passes `isNewCommentBox: false` to uploadFileFeedback to indicate an edit context vs initial creation."}
{"text":"Q: Why return `true` on editQrFBSuccess? A: So calling components know the edit succeeded and can proceed (e.g., close modals or refresh data)."}
{"text":"Q: Why do manual dispatches in getListFB use try/catch instead of wrappers? A: To customize error handling or to perform additional logic before/after dispatch, independent of global loading state."}
{"text":"Q: How does withLoadingAndErrorHandling improve UX for addFB/editFB? A: It automatically toggles a global spinner during long operations, giving users immediate feedback."}
{"text":"Q: What side effect does SWITCH_TO_USER_ACCOUNT_SUCCESS in the Feedback reducer trigger? A: It resets all feedback state so new user sessions start with a clean slate."}
{"text":"Q: Why clear `fbDetail` on DETAIL_FB_REQUEST? A: To prevent stale detail data from flashing while the new detail is being fetched."}
{"text":"Q: How does the reducer ensure pagination resets on GET_LIST_FB_QR_REQUEST? A: It calls `state.listQRFeedback.setPage(page)` before fetching, aligning the ListModel with the requested page."}
{"text":"Q: Why not wrap getFeedbackDivision in withLoadingAndErrorHandling? A: Likely because division data is small/static and doesn’t require a loading spinner, only error handling."}
{"text":"Q: How does the hook decide whether to use manual dispatch vs handler wrappers? A: It uses manual dispatch when custom try/catch logic is needed; uses wrappers for standard CRUD operations to reduce boilerplate."}
{"text":"Booking"}
{"text":"API Handler Wrappers"}
{"text":"Q: What does getBookingStatus wrap and dispatch? A: It wraps RequestApi.getBookingStatus() to retrieve booking statuses and, when used with withErrorHandling(GET_BOOKING_STATUS), dispatches GET_BOOKING_STATUS.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does filterBookings wrap and dispatch? A: It wraps RequestApi.filterBookings(params, isSorting) to fetch filtered reservations and, with withErrorHandling(FILTER_BOOKINGS), dispatches FILTER_BOOKINGS.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does getAllTimeSlots wrap and dispatch? A: It wraps RequestApi.getAllTimeSlots(params) to load available timeslots and, with withLoadingAndErrorHandling(GET_ALL_TIMESLOTS), dispatches GET_ALL_TIMESLOTS.REQUEST then SUCCESS or FAILURE and manages loading state."}
{"text":"Q: What does getBookingDetail wrap and dispatch? A: It wraps RequestApi.getBookingDetail(reservationId) to fetch a single booking’s details and, with withLoadingAndErrorHandling(GET_BOOKING_DETAIL), dispatches GET_BOOKING_DETAIL.REQUEST then SUCCESS or FAILURE and manages loading state."}
{"text":"Q: What does getPaymentStatus wrap and dispatch? A: It wraps RequestApi.getPaymentStatus() to retrieve payment status options and, with withErrorHandling(GET_PAYMENT_STATUS), dispatches GET_PAYMENT_STATUS.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does addBooking wrap and dispatch? A: It wraps RequestApi.addBooking(payload), handles file uploads via RequestApi.uploadBookingFiles when files exist, and, with withLoadingAndErrorHandling(ADD_BOOKING), dispatches ADD_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does updateBooking wrap and dispatch? A: It wraps RequestApi.updateBooking(payload), handles file uploads when files exist, and, with withLoadingAndErrorHandling(UPDATE_BOOKING), dispatches UPDATE_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does validateRecurringBooking wrap and dispatch? A: It wraps RequestApi.validateRecurringBooking(payload) and, with withLoadingAndErrorHandling(VALIDATE_RECURRING_BOOKING), dispatches VALIDATE_RECURRING_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does recurringBooking wrap and dispatch? A: It wraps RequestApi.recurringBooking(payload) and, with withLoadingAndErrorHandling(RECURRING_BOOKING), dispatches RECURRING_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does getAmenityDetail wrap and dispatch? A: It wraps RequestApi.getAmenityDetail(amenityId) and, with withLoadingAndErrorHandling(GET_AMENITY_DETAIL), dispatches GET_AMENITY_DETAIL.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does getAmenities wrap and dispatch? A: It wraps RequestApi.getAmenities(params) to fetch amenity lists and, with withErrorHandling(GET_AMENITIES), dispatches GET_AMENITIES.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does getBookingPurpose wrap and dispatch? A: It wraps RequestApi.getBookingPurpose() to retrieve booking purposes and, with withErrorHandling(GET_ALL_BOOKING_PURPOSE), dispatches GET_ALL_BOOKING_PURPOSE.REQUEST then SUCCESS or FAILURE."}
{"text": "Action & Saga Integration"}
{"text":"Q: Which saga watcher handles GET_BOOKING_STATUS.REQUEST and what does it do? A: A saga uses takeEvery(GET_BOOKING_STATUS.REQUEST, handleGetBookingStatus) to call getBookingStatus and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles FILTER_BOOKINGS.REQUEST and what does it do? A: It uses takeEvery(FILTER_BOOKINGS.REQUEST, handleFilterBookings) to call filterBookings and dispatch FILTER_BOOKINGS.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_ALL_TIMESLOTS.REQUEST and what does it do? A: It uses takeEvery(GET_ALL_TIMESLOTS.REQUEST, handleGetAllTimeSlots) to call getAllTimeSlots, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_BOOKING_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_BOOKING_DETAIL.REQUEST, handleGetBookingDetail) to call getBookingDetail, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_PAYMENT_STATUS.REQUEST and what does it do? A: It uses takeEvery(GET_PAYMENT_STATUS.REQUEST, handleGetPaymentStatus) to call getPaymentStatus and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles ADD_BOOKING.REQUEST and what does it do? A: It uses takeEvery(ADD_BOOKING.REQUEST, handleAddBooking) to call addBooking, upload files, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles UPDATE_BOOKING.REQUEST and what does it do? A: It uses takeEvery(UPDATE_BOOKING.REQUEST, handleUpdateBooking) to call updateBooking, upload files, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles VALIDATE_RECURRING_BOOKING.REQUEST and what does it do? A: It uses takeEvery(VALIDATE_RECURRING_BOOKING.REQUEST, handleValidateRecurringBooking) to call validateRecurringBooking and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles RECURRING_BOOKING.REQUEST and what does it do? A: It uses takeEvery(RECURRING_BOOKING.REQUEST, handleRecurringBooking) to call recurringBooking and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_AMENITY_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_AMENITY_DETAIL.REQUEST, handleGetAmenityDetail) to call getAmenityDetail, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_AMENITIES.REQUEST and what does it do? A: It uses takeEvery(GET_AMENITIES.REQUEST, handleGetAmenities) to call getAmenities and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_ALL_BOOKING_PURPOSE.REQUEST and what does it do? A: It uses takeEvery(GET_ALL_BOOKING_PURPOSE.REQUEST, handleGetBookingPurpose) to call getBookingPurpose and dispatch SUCCESS or FAILURE."}
{"text": "Reducer & State Management"}
{"text":"Q: What does GET_BOOKING_STATUS.SUCCESS do in the reducer? A: It sets state.statusList = payload, populating booking status options."}
{"text":"Q: How does FILTER_BOOKINGS.REQUEST update the ListModel? A: It calls state.list.setPage(action.payload.page) and deep-clones list to track pagination."}
{"text":"Q: What does FILTER_BOOKINGS.SUCCESS do in the reducer? A: It calls state.list.setData(payload) and deep-clones list to store filtered bookings."}
{"text":"Q: What does GET_ALL_TIMESLOTS.REQUEST do in the reducer? A: It clears state.bookingSlots = [] before new timeslot data arrives."}
{"text":"Q: What does GET_ALL_TIMESLOTS.SUCCESS do in the reducer? A: It sets state.bookingSlots = payload, storing available slots."}
{"text":"Q: What does GET_BOOKING_DETAIL.SUCCESS do in the reducer? A: It sets state.bookingDetail = payload, storing the fetched reservation details."}
{"text":"Q: What does GET_PAYMENT_STATUS.SUCCESS do in the reducer? A: It sets state.paymentStatusList = payload, populating payment status options."}
{"text":"Q: What does RESET_BOOKING_DETAIL do in the reducer? A: It sets state.bookingDetail = null, clearing any displayed reservation detail."}
{"text":"Q: What does GET_AMENITY_DETAIL.REQUEST do in the reducer? A: It sets state.amenityDetail = null to clear previous amenity data before loading."}
{"text":"Q: What does GET_AMENITY_DETAIL.SUCCESS do in the reducer? A: It sets state.amenityDetail = payload, storing the fetched amenity detail."}
{"text":"Q: What does GET_AMENITIES.SUCCESS do in the reducer? A: It filters payload for active items into state.amenityList and tags all items (active/inactive) into state.amenitiesFilter."}
{"text":"Q: What does GET_ALL_BOOKING_PURPOSE.SUCCESS do in the reducer? A: It sets state.bookingPurposes = payload, populating reservation-purpose options."}
{"text":"Q: What is the reducer’s default-case behavior? A: It returns the unchanged state for any unhandled action type, preserving existing data."}
{"text": "Business Logic & Side Effects"}
{"text":"Q: Why upload files after addBooking and updateBooking? A: Because the backend returns a GUID on create/update which is needed to associate uploaded files, so uploads occur only if payload.files exists."}
{"text":"Q: Why clear bookingSlots on GET_ALL_TIMESLOTS.REQUEST? A: To remove stale slot data before fetching fresh availability."}
{"text":"Q: Why reset amenityDetail on GET_AMENITY_DETAIL.REQUEST? A: To prevent previous amenity data from displaying while the new detail is loading."}
{"text":"Q: What transformation does GET_AMENITIES.SUCCESS perform for amenitiesFilter? A: It adds a `tagName: 'INACTIVE'` to inactive items, enabling UI to mark them accordingly."}
{"text":"Q: Why use withLoadingAndErrorHandling for long-running calls? A: To automatically toggle a loading spinner in the UI during operations like file uploads or recurring-booking validation."}
{"text":"Q: How does validateRecurringBooking improve UX before scheduling? A: It lets the backend verify date/rule validity and returns errors before committing a series of bookings."}
{"text":"Q: Why separate validateRecurringBooking and recurringBooking calls? A: To allow pre-flight validation of recurrence rules before actually creating multiple reservations."}
{"text":"Q: Why use withErrorHandling for simple lookups like getBookingStatus? A: Because they only need error dispatching without a global loading spinner, reducing unnecessary UI blocking."}
{"text":"Q: How does resetBookingDetailRequest improve navigation flows? A: Components dispatch it on unmount to clear detail state, preventing stale data when revisiting the booking screen."}
{"text":"Q: Why wrap filterBookings in withErrorHandling rather than manual dispatch? A: To reduce boilerplate by automatically dispatching REQUEST/SUCCESS/FAILURE while still reporting errors to the user."}
{"text":"// ===== TaskManagement ====="}
{"text":"// ===== Custom Hooks & Context ====="}
{"text":"Q: Which hooks provide external data and logic to TaskManagement, and what do they each supply? A: `useTaskManagement` supplies task lists and API methods (`getTaskList`, `getStatusList`, etc.); `useUser` supplies `tenant` and `isControlOffice`; `useTenant` supplies `tenantList` and `getTenantList`."}
{"text":"Q: How does `getTMTeamList` use `isControlOffice` and `ControlOfficePrjId`? A: It checks if the user is control-office or the tenant matches `ControlOfficePrjId`: if true it calls `getCurrentTeamList()`, otherwise calls `getTeamsByTenant({ tenantId })`."}
{"text":"Q: Why encapsulate all API dispatch logic in `useTaskManagement` rather than in the component? A: To separate concerns: the hook handles Redux dispatch/sagas/loading, keeping the component declarative and focused on UI."}
{"text":"// ===== Local Component State ====="}
{"text":"Q: What local state does TaskManagement manage with `useState`, and why? A: `selectedFilter` stores the current filter object; `filterTenantId` tracks which tenant’s teams to fetch; `keyword` holds the search term for live filtering."}
{"text":"Q: How is `defaultFilter` structured and used for reset? A: It contains empty `dateRange`, `multipleOptions`, default `tenantFilter`, and empty `teamIds`/`userIds`. `onClearFilter` resets `selectedFilter` to this baseline."}
{"text":"Q: Why derive `filterTenantId` from `tenant?.id` initially? A: To fetch the correct team list on mount according to the user’s own tenant context."}
{"text":"// ===== Side Effects with useEffect ====="}
{"text":"Q: What three `useEffect` blocks handle data fetching and when do they run? A: (1) On `[teamList]` change: fetch users via `getUsersInTeamByTenants`, (2) On mount (`[]`): fetch statuses, priorities, teams, tenants and subscribe to `ReloadTM`, (3) On `[selectedFilter, keyword]`: re-run `getList` when filters/search change."}
{"text":"Q: How does the mount effect clean up its event listener? A: It returns `() => subscription.remove()`, ensuring the `ReloadTM` listener is removed on unmount."}
{"text":"Q: Why call `getList(1)` in a separate effect at the end? A: To ensure the first page of tasks loads once after all initial setup has run, avoiding duplicate fetches with filters yet to be applied."}
{"text":"// ===== Filter Configuration Pattern ====="}
{"text":"Q: How is `filterData` defined to drive the `Filter` component? A: As an object mapping keys to config objects with `title`, `type`, `options`, async `getList`, `onChange`, and `resetPropsOnChange` fields."}
{"text":"Q: How does the tenant dropdown’s `onChange` interact with filter state? A: It updates `filterTenantId`, calls `getTMTeamList` for the new tenant, and via `resetPropsOnChange` clears `teamId` and `userId` selections."}
{"text":"Q: How would you add a new boolean filter (e.g. “assignedToMe”)? A: Add `assignedToMe` to `defaultFilter`, then add an entry in `filterData` with `type: FilterTypes.CHECKBOX`, include it in `getList` params."}
{"text":"// ===== Data Fetching & Pagination ====="}
{"text":"Q: What parameters does `getList(page, filter)` construct for `getTaskList`? A: `page`, `keyword`, `pageSize: PAGE_SIZE`, plus `statusIds`, `priorityId`, ISO dates for `fromDate`/`toDate`, `isOverdue`, `isPublic`, `tenantId`, `teamIds`, `userIds`."}
{"text":"Q: How does `AppList` know when to load more data? A: Via `listProps` props: `isRefresh`, `isLoadMore`, `currentPage`, `totalPage`, and `loadData: ({page})=>getList(page)`."}
{"text":"Q: Why default `page = 1` in `getList`? A: To reset to the first page on filter or search changes, preventing stale pagination state from persisting."}
{"text":"// ===== Rendering & Navigation ====="}
{"text":"Q: How is each task item rendered and wired to navigation? A: `renderItem` returns `<ItemTask>` with `onPress` that calls `NavigationService.navigate('editTask', {id, isSeries})`."}
{"text":"Q: How is the “Add Task” action implemented? A: `onAddTask` calls `NavigationService.navigate('addTask')`, passed to `BaseLayout.onBtAddPress` via `layoutProps`."}
{"text":"Q: Why separate `Filter` and `AppList` in the JSX tree? A: To modularize the UI: filter controls live in `Filter`, list display and infinite scroll in `AppList`, with TaskManagement handling orchestration."}
{"text":"// ===== Event Listening & Cleanup ====="}
{"text":"Q: What native event does the component listen for and why? A: `'ReloadTM'` via `DeviceEventEmitter`, to trigger `getList()` when external updates to tasks occur."}
{"text":"Q: What could go wrong if you forget to remove the subscription? A: Multiple listeners accumulate, leading to duplicate fetches and memory leaks."}
{"text":"Q: How would you throttle the reload event to prevent spamming? A: Wrap `getList` in `_.throttle` or check a timestamp inside the listener before calling."}
{"text":"// ===== Utility Patterns ====="}
{"text":"Q: How are dates normalized before sending to the API? A: Using `convertDate.stringToISOString(fromDate)` and similarly for `toDate`."}
{"text":"Q: Why use a constant `PAGE_SIZE` instead of a magic number? A: For consistency across screens and easy tuning of pagination behavior in one place."}
{"text":"Q: How is the “overdue” flag determined from filter options? A: By checking `multipleOptions.includes(multipleOptionValue.isOverdue)`, setting `isOverdue` only if selected."}
{"text":"// ===== TaskManagementCommment ====="}
{"text":"// ===== Local Component State ====="}
{"text":"Q: What local state does TaskManagementComment manage with `useState`, and how is each piece used? A: It manages `visible` (controls Modal visibility) and uses `message` from `watch()` internally, while `formMethods` state is handled by React Hook Form."}
{"text":"Q: Why derive `disabled` from `_.size(message) === 0`? A: To disable the send button when there’s no input, preventing empty comments from being submitted."}
{"text":"// ===== Side Effects with useEffect ====="}
{"text":"Q: What does the `useEffect` watching `visible` do, and why? A: When `visible` becomes true, it calls `getComments()` and `getTaskMentionUsers()` to load the latest comments and mention suggestions before showing the modal."}
{"text":"Q: Why is there no cleanup function in this `useEffect`? A: Because the effect only triggers on opening the modal and doesn’t subscribe to external events or create long-lived side effects needing teardown."}
{"text":"// ===== Custom Hooks & Context ====="}
{"text":"Q: Which custom hooks are used and what data or methods do they provide? A: `useTaskManagement` gives `comments`, `mentionUsersDic` and actions `getCommentByTask`, `getMentionUsers`, `addComment`; `useUser` provides `user` and `tenant`; `useCompatibleForm` sets up React Hook Form methods."}
{"text":"Q: How does `getTaskMentionUsers` leverage `getMentionUsers` and caching? A: It checks `mentionUsers.length` and only calls `getMentionUsers(mentionUserParams)` if the cache is empty, avoiding redundant API calls."}
{"text":"// ===== Rendering & Navigation ====="}
{"text":"Q: How is the comment UI toggled and rendered? A: A floating `MessageFloatingButton` toggles `visible`, showing a `Modal` containing the comment list and input when `visible` is true."}
{"text":"Q: How are comments displayed and inverted? A: Using `FlatList` with `inverted={comments.length !== 0}`, so newest comments appear at the bottom and stack upward."}
{"text":"// ===== Form Management ====="}
{"text":"Q: How is React Hook Form integrated, and which methods are used? A: Wrapped in `<FormProvider>`, it uses `watch()` to track `message`, `handleSubmit(onSendMessage)` to submit, and `setValue('message', '')` to reset the field."}
{"text":"Q: How are mention suggestions wired into the form input? A: `FormMentionInput` receives `renderMentionSuggestions` for showing suggestions, and `onChange={getTaskMentionUsers}` to trigger loading suggestions as the user types."}
{"text":"Q: How is the submit action triggered both from the keyboard and the send button? A: The FormMentionInput uses onSubmitEditing={handleSubmit(onSendMessage)} so pressing 'send' on the keyboard invokes the same handleSubmit(onSendMessage) callback as pressing the SendButton."}
{"text":"Q: How does the form ensure the send button is only active when there’s input? A: It derives disabled from _.size(message) === 0 using watch(), and passes this disabled prop to SendButton to gray it out and prevent presses when message is empty."}
{"text":"Q: Why is setValue(‘message’, ‘’) called before sending the comment? A: Clearing the input immediately provides instant UI feedback that the message was submitted, before awaiting the asynchronous addComment operation."}
{"text":"Q: How does the form handle required field validation? A: The FormMentionInput receives the required prop, which React Hook Form enforces, and empty messages disable the send button so users can’t submit blank comments."}
{"text":"Q: What benefit does wrapping the component in  provide? A: It exposes all form methods (watch, handleSubmit, setValue, etc.) via context to nested components like FormMentionInput without prop drilling."}
{"text":"Q: How would you reset the form when the modal closes? A: In the CloseButton onPress handler, after setVisible(false), call formMethods.reset() to restore defaultValues, clearing any unsent input."}
{"text":"Q: How can you display a character count limit for the message input? A: Use watch(‘message’) to get current length and render a Text component showing {message.length}/200. Also add maxLength={200} to FormMentionInput."}
{"text":"Q: How would you integrate async validation (e.g., profanity check) before sending? A: In onSendMessage, before addComment, call an async validator on message; if it fails, use setError(‘message’, { type: ‘manual’, message: ‘Inappropriate content’ }) and abort sending."}
{"text":"Q: How can the input be automatically focused when the modal opens? A: Attach a ref to FormMentionInput, and in the useEffect watching visible, after setting visible true, call inputRef.current.focus() to bring up the keyboard."}
{"text":"Q: How does handleSubmit ensure the onSendMessage callback receives validated data? A: handleSubmit wraps onSendMessage, running validation rules first and only invoking onSendMessage with the form values if validation passes."}
{"text":"// ===== Booking====="}
{"text":"// ===== Context & Data ====="}
{"text":"Q: What custom hook does Booking use and what data/actions does it expose? A: It uses useBooking(), which returns data (statusList, paymentStatusList, amenitiesFilter, amenityList, list) and actions (filterBookings, getBookingStatus, getPaymentStatus, getAmenitiesFilter, getAmenityDetail)."}
{"text":"Q: How are the filter options configured for status, payment status, and amenities? A: The filters object maps statusIds and paymentStatusIds to statusList/paymentStatusList with multiple selection and valKey for codes, and amenityIds to amenitiesFilter with a searchable dropdown via dropdownProps. "}
{"text":"Q: What is the role of multipleOptionValue and how is it used? A: It defines two flags (isIncludeExpired, onlyActiveAmenity) used in defaultFilter.multipleOptions and filters.multipleOptions.options to toggle advanced filter behaviors. "}
{"text":"// ===== State ====="}
{"text":"Q: Which pieces of React state does the Booking component manage and why? A: It manages bookingFilter (initial filter values), selectedFilter (currently applied filters), textSearch (search keyword), and visibleSelectAmenity (controls the amenity modal visibility)."}
{"text":"Q: How is selectedFilter initialized? A: It defaults to bookingFilter via useState(bookingFilter), where bookingFilter is initially set to defaultFilter. "}
{"text":"// ===== Effects ====="}
{"text":"Q: What happens on component mount in the first useEffect? A: It calls getBookingStatus(), getPaymentStatus(), and getAmenitiesFilter() to populate filter options when the screen renders. "}
{"text":"Q: How does the component react to changes in search text or applied filters? A: A useEffect with [textSearch, selectedFilter] dependencies calls getList(1) to reload the first page whenever search or filters change. "}
{"text":"Q: How are external events handled to refresh the booking list? A: Another useEffect registers a DeviceEventEmitter listener for ‘UpdateListBooking’ that invokes getList(1, textSearch, selectedFilter), and removes the listener on unmount. "}
{"text":"// ===== Handlers ====="}
{"text":"Q: What does getList do and which parameters can be passed? A: getList(page, keyword, filter) builds ISO strings for fromDate/toDate, computes isIncludeExpired/onlyActiveAmenity flags, merges filterParams, then calls filterBookings({ page, pageSize: PAGE_SIZE, keyword, …filterParams })."}
{"text":"Q: How does onApplyFilter update the filtering behavior? A: It calls setSelectedFilter(value), which triggers the effect to refresh the list with the new filter. "}
{"text":"Q: What happens when the Add button is pressed (onBtAddPress)? A: It sets visibleSelectAmenity to true, opening the SelectAmenityModal. "}
{"text":"Q: Describe the flow when an amenity is selected in the modal (onAmenitySelect). A: It closes the modal (setVisibleSelectAmenity(false)), calls getAmenityDetail with the selected amenity’s ID, then navigates to ‘addBooking’ via NavigationService.navigate. "}
{"text":"Q: How is search text input handled? A: The Filter component’s onSearch prop calls onTextSearchChange, which updates textSearch state and triggers the list refresh effect. "}
{"text":"Q: How does navigation to a booking’s detail work? A: renderItem passes each item to ItemBooking, whose onPress calls gotoDetail(item), navigating to ‘editBooking’ with the item’s reservationId. "}
{"text":"// ===== Render ====="}
{"text":"Q: Which top-level layout and controls are rendered in Booking? A: BaseLayout with title ‘HOME_TEXT_BOOKING’, bell and add-button handlers; the Filter component; AppList for paginated items; and SelectAmenityModal controlled by visibleSelectAmenity. "}
{"text":"Q: How is pagination and loading state communicated to AppList? A: Via listProps passing data, isRefresh, isLoadMore, currentPage, totalPage, loadData (calls getList), keyExtractor, and renderItem. "}
{"text":"Q: Why is PAGE_SIZE injected into getList? A: To enforce a consistent number of items per page across the app, avoiding hardcoded magic numbers. "}
{"text":"Q: How does the component ensure the correct empty-state icon is shown? A: It passes iconName={icons.jobRequestEmpty} to AppList, so when data is empty, that placeholder icon appears."}
{"text":"// ===== AddOrEditBooking ====="}
{"text":"// ===== Context & Data ====="}
{"text":"Q: What are the initial form values for a new booking defined in initialValues? A: amenityId: null, startEndDate: new Date(), endDate: undefined, status with bookingStatusCode.REQUESTED, paymentStatus with NOT_YET_DEPOSIT, purposeId: null, numberOfPerson: ‘’, remark: ‘’, bookingType: [occupier], company: null, files: [], email: ‘’, depositPrice {raw:0,text:’’}, slots: []"}
{"text":"Q: Which constants provide status and payment status codes? A: bookingStatusCode and bookingPaymentStatusCode imported from @Config/Constants."}
{"text":"Q: Which context hooks does AddOrEditBooking rely on for data and actions? A: useBooking (bookingDetail, statusList, paymentStatusList, etc.), useApp (simpleCompanies, languageId), useUser (securitySetting), useFile (referenceFiles, bookingRuleFiles), and useBookingRecurrence (generateTimeSlots)."}
{"text":"Q: How does the component determine if it’s in 'add' or 'edit' mode? A: It reads useRoute().name, setting isAddNew = name === ‘addBooking’ and isEdit = name === ‘editBooking’."}
{"text":"Q: What external libraries and modules does AddOrEditBooking import, and what roles do they serve? A: It imports React hooks (useEffect, useState, useMemo, useCallback) for lifecycle and memoization; Alert and DeviceEventEmitter from React Native for user alerts and cross-component events; FormProvider from React Hook Form for form context; Yup and useYupValidationResolver for schema validation; moment for date formatting; UI components (BaseLayout, AwareScrollView, Card, Row, Text, Box) for layout; custom form fields (FormInput, FormDropdown, etc.); navigation (useRoute, NavigationService); and context hooks (useBooking, useApp, useUser, useFile, useBookingRecurrence) to fetch data and actions."}
{"text":"Q: How is initialValues structured and why are nested objects used for status, paymentStatus, and depositPrice? A: initialValues is a flat object except for nested fields: status and paymentStatus wrap codes to match dropdown value shapes, and depositPrice uses { raw, text } to separate numeric value from formatted display string, aligning with FormMoneyInput expectations."}
{"text":"Q: What constants from @Config/Constants are used, and how do they define booking behavior? A: bookingStatusCode and bookingPaymentStatusCode set default statuses (e.g., REQUESTED, NOT_YET_DEPOSIT); Modules provides module IDs for chat; bookingTargets defines types (occupier, company, outsider) used in radio groups and payload mapping."}
{"text":"Q: Why does the component import both FormLazyDropdown and FormSuggestionPicker, and when is each used? A: FormLazyDropdown supports server-side pagination for large lists (simpleCompanies), used for company selection; FormSuggestionPicker fetches incremental suggestions for units based on typed keywords, used when bookingType is occupier."}
{"text":"Q: How does useBookingRecurrence integrate into the flow? A: It provides generateTimeSlots, used in the FormSlotView onChange handler to translate a single-day selection into multiple recurring booking times when the user sets recurrence rules."}
{"text":"Q: How is the Yup validation resolver wired into React Hook Form? A: The hook useYupValidationResolver(validationSchema) generates a resolver that is passed to useCompatibleForm, so handleSubmit runs schema validation before submission."}
{"text":"Q: How does useRoute parameters (name, params) get used? A: useRoute() provides the route name and params.id; name decides add/edit mode, params.id fetches the booking detail for editing."}
{"text":"Q: What role does LocaleConfig.formatMoney play in deposit display? A: It formats the numeric deposit into a localized currency string, stored in depositPrice.text for FormMoneyInput."}
{"text":"// ===== State ====="}
{"text":"Q: What UI state variables are declared via useState? A: confirmationVisible (boolean), bookingRequestData (object|null), isDisabledForm (boolean), visibleSelectAmenity (boolean)."}
{"text":"Q: Which form fields are watched using React Hook Form’s watch()? A: startEndDate, bookingType[0], depositPrice, slots, status, unit, recurrence."}
{"text":"Q: How is the formMethods instance obtained and what methods does it provide? A: Via useCompatibleForm({ defaultValues, resolver }), yielding setValue, watch, handleSubmit, reset."}
{"text":"Q: What is the purpose of confirmationVisible and bookingRequestData state variables? A: confirmationVisible toggles the visibility of the BookingConfirmation modal after validating a recurring booking; bookingRequestData holds the result of validateRecurringBooking, including valid and invalid slots and metadata for confirmation display."}
{"text":"Q: How does isDisabledForm interact with booking status codes? A: isDisabledForm is set to true whenever the booking’s status is CANCELED or DECLINED (in the effect watching bookingDetail), disabling all form inputs and preventing further edits."}
{"text":"Q: Why is visibleSelectAmenity managed in both Booking and BookingDetail components? A: It controls the SelectAmenityModal visibility for choosing a different amenity; its independent state ensures the modal opens only when intended without re-rendering the entire form."}
{"text":"Q: How does the component derive the current bookingType, and how is it used in rendering? A: It watches bookingType via watch('bookingType')[0], selecting the first item; this drives conditional rendering of unit/company/email fields and payload mapping in onSave."}
{"text":"Q: What is the role of startEndDate and how is it different from startDate/endDate? A: startEndDate is the form field capturing the selected date for new bookings; startDate/endDate derive from either startEndDate for add mode or from bookingDetail for edit mode, ensuring correct display and slot fetching."}
{"text":"Q: How is reset() from formMethods used when leaving the screen? A: In the cleanup of getInitialValuesForUpdate effect, reset(getInitialValuesForUpdate()) ensures form fields match the bookingDetail when switching bookings."}
{"text":"Q: Why is bookingRequestData initialized as null? A: To differentiate between no confirmation data and an actual validation result, allowing conditional rendering of BookingConfirmation only when non-null."}
{"text":"// ===== Effects ====="}
{"text":"Q: What effect loads booking detail when editing and cleans up on unmount? A: useEffect([id]) calls getBookingDetail(id) if !isAddNew && id, and returns () => resetBookingDetail()."}
{"text":"Q: How are referenceFiles and bookingRuleFiles injected into the form? A: Two effects: one on [_.size(referenceFiles)] calls setValue(‘files’, referenceFiles), another on [bookingRuleFiles, amenityDetail] calls setValue(‘bookingRuleFiles’, bookingRuleFiles)."}
{"text":"Q: Which effect populates dropdown and lookup data on component mount? A: useEffect([]) that calls getBookingStatus(), getPaymentStatus(), getSimpleCompanies({page:1}), getBookingPurpose(), and getAmenities() if amenityList is empty."}
{"text":"Q: How and when are available time slots fetched? A: useEffect([startDate, endDate, amenityDetail]) invokes getBookingTimeSlots(), which calls getAllTimeSlots with formatted fromDate/toDate if amenityDetail exists."}
{"text":"Q: What effect triggers deposit price recalculation? A: useEffect([calculateDepositPrice]) calls calculateDepositPrice() whenever the callback reference changes (i.e., when slots change)."}
{"text":"Q: How does the effect for [id] ensure cleanup of stale detail data? A: On mount when editing, it fetches getBookingDetail(id); on unmount or id change, it invokes resetBookingDetail() to clear previous booking data from context, preventing cross-navigation leakage."}
{"text":"Q: Why is there an effect for [_.size(referenceFiles)] instead of [referenceFiles]? A: Using _.size(referenceFiles) ensures the effect runs only when the number of files changes (add/remove), not on every object identity change, optimizing re-renders."}
{"text":"Q: What initial data loads in the mount effect, and why is getAmenities() gated by an empty list? A: It loads status, payment status, companies, booking purposes, and amenities; getAmenities() runs only if amenityList is empty, avoiding redundant network calls if data is already cached."}
{"text":"Q: How does the effect on [startDate, endDate, amenityDetail] schedule slot retrieval? A: When any of those change (user picks dates or selects a new amenity), it calls getBookingTimeSlots(), which formats dates via moment and fetches available slots for those parameters."}
{"text":"Q: Why is calculateDepositPrice wrapped in useCallback, and how does its effect trigger? A: Wrapping ensures stable reference unless slots change; the effect on [calculateDepositPrice] then recalculates deposit whenever selected slots update, keeping UI in sync."}
{"text":"Q: How does the effect injecting bookingRuleFiles depend on amenityDetail? A: It watches amenityDetail and bookingRuleFiles, so when a new amenity is selected or its rules change, the form field bookingRuleFiles resets to the latest list."}
{"text":"Q: What ensures that bookingSlots populate only for new bookings? A: The effect with [bookingSlots] runs only if isAddNew is true, setting slots initial values only when creating a booking."}
{"text":"// ===== Handlers ====="}
{"text":"Q: What does getInitialValuesForUpdate() do? A: Transforms bookingDetail into a values object for reset(): maps amenityId, dates, status, paymentStatus, purposeId, numberOfPerson, remark, bookingType array, files, depositPrice, and sets unit/company/contact fields based on bookingType."}
{"text":"Q: How is deposit price calculated from selected slots? A: calculateDepositPrice filters slots for isCheck, finds matching amenityTimeRules by dayName and times, then setValue(‘depositPrice’) with that rule’s price formatted via LocaleConfig."}
{"text":"Q: Describe the onSave handler flow. A: Filters out new files, determines slotStartTime/slotEndTime for add, builds payload merging formValues and amenityDetail, maps type-specific fields (occupier/company/outsider), handles recurrence via recurringBooking, then calls updateBooking or addBooking, emits UpdateListBooking, and navigates back."}
{"text":"Q: What does recurringBooking() perform? A: Validates that recurrence.bookingTimes exist, constructs bookingObj with times, calls validateRecurringBooking, sets bookingRequestData on success, and shows the BookingConfirmation modal; on error, shows Alert."}
{"text":"Q: How is amenity selection handled? A: onAmenitySelect sets form value amenityId, calls getAmenityDetail, and closes the SelectAmenityModal."}
{"text":"Q: How does getInitialValuesForUpdate() handle different bookingType cases? A: It starts with a base copy of bookingDetail, then for company type it maps companyName/id, for occupier it sets unit, contactName, contactEmail, contactPhone, and for outsider it maps just email, ensuring form fields reflect existing data."}
{"text":"Q: In calculateDepositPrice, how are day and time matched against amenityTimeRules? A: It uses moment(slot).day() to get weekday index, maps to weekday names, formats times to ‘HH:mm:ss’, then finds a rule where numNextValidDate, startTime, and endTime exactly match, updating the deposit based on that rule’s price."}
{"text":"Q: What validations does validationSchema enforce, and how does it conditionally add slot validation? A: It always validates bookingType array and related fields (unit, company, email) via when clauses; if isAddNew, it adds a custom slots test requiring at least one isCheck===true, ensuring new bookings pick slots."}
{"text":"Q: Describe the sequence in onSave when editing an existing booking without recurrence. A: It filters new files, builds payload with unchanged startDate/endDate from bookingDetail, maps statusCode and type fields, then calls updateBooking(payload), emits UpdateListBooking, and navigates back."}
{"text":"Q: How does recurringBooking() integrate API responses into the confirmation step? A: It builds a bookingObj, calls validateRecurringBooking, then processes the response to extract validSlots and invalidSlots, looks up human-readable status names, stores all in bookingRequestData, and sets confirmationVisible=true to show details before final commit."}
{"text":"Q: Why does onShowSelectAmenity simply set the modal visible, deferring detail fetch to onAmenitySelect? A: To avoid fetching amenity detail prematurely; detail is loaded only when the user explicitly chooses an amenity, optimizing network usage."}
{"text":"Q: How does handleConfirm complete the recurring booking flow? A: It retrieves current form values via formMethods.getValues(), calls onSave with those values to persist bookings, then closes the confirmation modal by setting confirmationVisible to false."}
{"text":"Q: How does the handler ensure only new files are uploaded? A: In onSave, it filters formValues.files by checking for item.path, so only files added by the user (with a local path) are included for upload."}
{"text":"Q: What role does DeviceEventEmitter.emit('UpdateListBooking') play in onSave? A: After a successful add or update, emitting 'UpdateListBooking' notifies other components to refresh their booking lists in response to the changes."}
{"text":"Q: How does the handler differentiate between add and edit modes when constructing the payload? A: onSave uses isAddNew: for adds, it computes slotStartTime/slotEndTime from selected slots; for edits, it reuses bookingDetail.startDate and endDate, then chooses addBooking or updateBooking accordingly."}
{"text":"Q: How does the FormSuggestionPicker onChange handler map a selected unit into form fields? A: It calls setValue for contactId, contactName, contactPhone, and contactEmail based on the selectedUnit, so the read-only fields reflect the chosen unit’s data."}
{"text":"Q: How does the FormLazyDropdown getList handler support pagination and search? A: It invokes getSimpleCompanies({ page, keyword }) on each load (or search), letting the dropdown append new pages of companies as the user scrolls or types."}
{"text":"Q: What guard does getBookingTimeSlots include before fetching slots? A: It returns early if amenityDetail is falsy, preventing API calls when the amenity hasn’t been selected or loaded yet."}
{"text":"Q: How does the FormSlotView onChange handler update recurrence rules? A: It detects if a recurrence object exists, then builds a bookingTimes array from checked slots, passes that along with the recurrence template to generateTimeSlots, and writes back via setValue('recurrence', …)."}
{"text":"Q: How does FormDocumentPicker propagate file selections into form state? A: It automatically updates the `files` field in React Hook Form; later onSave filters those by `item.path` so only newly added files (with local paths) are uploaded."}
{"text":"Q: What does the BookingRecurring onRemove handler do? A: It simply calls setValue('recurrence', null), clearing any existing recurrence configuration from the form when the user opts out of recurring bookings."}
{"text":"Q: How does onSave handle API errors from addBooking/updateBooking? A: It relies on try/catch around those calls (in recurringBooking and onSave), and surfaces failures via Alert.alert with the error message, preventing silent failures."}
{"text":"Q: How is the paymentStatus dropdown enabled or disabled at the right times? A: The render logic checks amenityDetail.isUseDeposited and (isAddNew & status≠REQUESTED) or (edit & bookingDetail.paymentStatus) to include the dropdown only when it makes sense."}
{"text":"Q: What happens if validateRecurringBooking throws validation errors? A: recurringBooking wraps the API call in try/catch and calls Alert.alert('ERROR', error.message), so the confirmation modal never appears on invalid recurrence."}
{"text":"Q: How does the file picker handler remove files? A: FormDocumentPicker integrates with React Hook Form; deletions simply remove items from the `files` array, and onSave filters out only those with a `path`, so removed ones aren’t re-uploaded."}
{"text":"Q: How does onSave prevent submitting when form is disabled? A: BaseLayout’s Save button is rendered via handleSubmit(onSave) but disabled by `isDisabledForm`, so handleSubmit never fires when the form is disabled."}
{"text":"Q: How does the component handle time‐zone consistency when formatting dates? A: getBookingTimeSlots formats dates via `moment(date).format('YYYY/MM/DD')`, ensuring the backend receives dates in a consistent, timezone-neutral string format."}
{"text":"Q: How does onSave handle file uploads for existing files? A: It filters files by item.path; items without path (already uploaded) are omitted from upload payload, preserving existing attachments."}
{"text":"Q: What happens to recurrence state after handleConfirm is called? A: handleConfirm calls onSave then resets confirmationVisible; since onSave may navigate away, recurrence state is cleared as component unmounts."}
{"text":"Q: How does the payload include contact fields for an occupier? A: onSave checks bookingType, then maps unit.buildingId, unit.unitId, fullUnitId, contactName, contactEmail, contactPhone into the payload for occupier bookings."}
{"text":"// ===== Render ====="}
{"text":"Q: Which layout and form wrappers compose the UI tree? A: BaseLayout (with bottomButtons), LoaderContainer, AwareScrollView, FormDisabledProvider, FormProvider, and nested Container/Card components."}
{"text":"Q: How is conditional rendering used for add vs edit modes? A: If isAddNew, renders FormCalendarPicker and FormSlotView; if not, renders TimeWrapper with InfoRow showing existing start/end times."}
{"text":"Q: Which form fields and components are rendered inside the form? A: AmenityButton, FormCalendarPicker, FormSlotView, FormDropdown for status/paymentStatus, FormRadioGroup for bookingType, FormSuggestionPicker/FormLazyDropdown/FormInput based on bookingType, FormDropdown for purposeId, BookingRecurring if allowed, FormInput numberOfPerson, FormMoneyInput for depositPrice, FormDocumentPicker, and BookingPolicyRules."}
{"text":"Q: How are bottom action buttons defined? A: BaseLayout bottomButtons prop contains a single Save button with title COMMON_SAVE, primary type, onPress=handleSubmit(onSave), disabled according to isDisabledForm."}
{"text":"Q: How are modals and overlays included? A: At the root return:  controlled by visibleSelectAmenity,  shown when editing and amenityDetail exists, and  controlled by confirmationVisible."}
{"text":"Q: How does FormDisabledProvider interact with isDisabledForm to disable all nested inputs? A: It wraps the form, passing disabled={isDisabledForm} so child form controls automatically respect the disabled state, uniformly preventing edits when true."}
{"text":"Q: Why is BookingRecurring only shown when amenityDetail.isAllowRecurring is true and not in edit mode? A: Recurrence configuration applies only to new bookings (isAddNew) and only if the amenity supports recurring reservations, preventing recurrence edits on existing bookings."}
{"text":"Q: How are conditional form sections rendered based on bookingType? A: Via inline JSX: if bookingType===occupier, show unit picker and contact info; if company, show company dropdown; if outsider, show email input, keeping the form dynamic."}
{"text":"Q: What is the purpose of LoaderContainer around the form? A: It displays a loading spinner (BookingLoading) while amenityDetail is undefined, preventing form interaction until required data loads."}
{"text":"Q: How do bottom buttons in BaseLayout reflect form state? A: The Save button’s disabled prop binds to isDisabledForm, graying out and blocking submission if the booking is canceled/declined or data isn’t ready."}
{"text":"Q: What overlays are included and how are they triggered? A: SelectAmenityModal opens via visibleSelectAmenity, FloatingConversation appears for edit mode with existing guid, and BookingConfirmation shows after recurring validation when confirmationVisible is true, layering modals over the form."}
{"text":"// ===== BookingPolicyRules ====="}
{"text":"// ===== State ====="}
{"text":"Q: What piece of state does BookingPolicyRules manage and what does it control? A: It manages the boolean open state via useState(false), which determines whether the policy sections are expanded or collapsed."}
{"text":"// ===== Handlers ====="}
{"text":"Q: How does the SectionHeader onPress handler toggle the visibility of the policy rules? A: It calls setOpen(!open), inverting the open boolean to either show or hide the sections."}
{"text":"Q: How are the visible sections determined before rendering? A: It builds a sections array with show flags, then computes visible = sections.filter(s => s.show) to include only sections whose show condition is truthy."}
{"text":"Q: How does the component decide to render the docs picker? A: In the sections array, the docs entry uses show: _.size(bookingRuleFiles) > 0, so it’s only visible when there are one or more rule files."}
{"text":"// ===== Render ====="}
{"text":"Q: How is the section header displayed and styled? A: It renders a SectionHeader containing bold text ‘BOOKING_POLICY_RULE’ and an Ionicon showing ‘chevron-up’ if open is true or ‘chevron-down’ if false."}
{"text":"Q: What happens when there are no sections to show? A: If visible.length is zero, the component returns null, rendering nothing."}
{"text":"Q: How are individual sections rendered inside the expanded card? A: When open is true, it renders a Card and maps each visible section to a View showing its optional bold label followed by the output of its render() function."}
{"text":"Q: How are amenity time rules formatted and displayed in the ‘rules’ section? A: It renders a table with header cells ‘COMMON_DATE’ and ‘BOOKED_TIME’, then for each amenityTimeRules slot, formats startTime and endTime from ‘HH:mm:ss’ to ‘HH:mm’ using moment().format before displaying them."}
{"text":"// ===== BookingRecurringConfirmation ====="}
{"text":"// ===== State ====="}
{"text":"Q: What state does BookingRecurringConfirmation manage and what structure does it hold? A: It manages `localData`, initialized with empty arrays and strings, storing `validSlots`, `invalidSlots`, `requestedBy`, `amenityName`, `createdDate`, and `status`."}
{"text":"// ===== Effects ====="}
{"text":"Q: What effect synchronizes localData with incoming bookingRequestData? A: A useEffect with [bookingRequestData] dependency calls setLocalData(buildConfirmationObj(bookingRequestData)), ensuring state reflects the latest prop data."}
{"text":"// ===== Handlers ====="}
{"text":"Q: How does buildConfirmationObj transform bookingRequestData into localData? A: It deep-clones bookingData, maps `bookingTimes` to include `isAvailable` and `timeRange` via getTimeRange, then filters into `validSlots` and `invalidSlots`, and carries over metadata fields."}
{"text":"Q: What does the useEffect on bookingRequestData do? A: When `bookingRequestData` changes, it invokes buildConfirmationObj and updates `localData` with the structured slots and metadata."}
{"text":"Q: How does handleRemoveSlot prompt and remove a slot? A: It shows an Alert with cancel/remove options; on confirm, it filters out the specified index from `localData.validSlots` and calls setLocalData to update state."}
{"text":"Q: What sequence does handleConfirmBooking follow? A: It clones bookingRequestData, replaces `bookingTimes` with the filtered `validSlots`, deletes `validSlots`/`invalidSlots`, calls `recurringBooking`, then on success closes the modal, navigates back, and emits 'UpdateListBooking'."}
{"text":"// ===== Render ====="}
{"text":"Q: How are invalid slots displayed to the user? A: If `localData.invalidSlots` is non-empty, it renders a red Text component listing each invalid timeRange preceded by a bullet, prefixed by 'CANNOT_BOOKING_ON'."}
{"text":"Q: How does the component render booking metadata labels and values? A: It uses the `LabelValue` subcomponent to display bolded labels (via I18n.t) and corresponding values for requestedBy, amenityName, createdDate (formatted), and status."}
{"text":"Q: How is the list of valid slots presented and interactive? A: A `SlotList` FlatList renders `localData.validSlots`, each row via `renderSlot`, showing a numbered label, timeRange, and a trash icon button to remove the slot."}
{"text":"Q: How are the Cancel and Confirm actions rendered? A: In a `ButtonsRow`, it always shows a Cancel `Button` calling `onClosePress`, and if there are valid slots, shows a primary rounded Confirm `Button` calling `handleConfirmBooking`."}
{"text":"// ===== ConfigRecurrenceModal ====="}
{"text":"// ===== Context & Data ====="}
{"text":"Q: What external data and constants does ConfigRecurrenceModal rely on? A: It uses frequencyOptions from FREQUENCY_TYPES, everyDailyTypes from DAILY_TYPE_KEYS, onTypes from ON_TYPE_KEYS, dayOfWeeksOptions from WEEK_DAY_KEYS, monthDaysOptions array, initialValues object, validationSchema via Yup, and hooks useYupValidationResolver, useCompatibleForm, useBookingRecurrence for slot generation."}
{"text":"Q: How does initialValues and validationSchema shape the form behavior? A: initialValues sets default form fields (frequency, every, dayOfWeeks, onType, onDay, dates) and validationSchema enforces required startDate/endDate and conditional 'every' rules for monthly frequency."}
{"text":"// ===== State ====="}
{"text":"Q: What state does ConfigRecurrenceModal manage and how is form state accessed? A: It does not use local useState; form state is managed by React Hook Form via formMethods, and watch(['frequency','onType']) provides reactive values frequency and onType for conditional rendering."}
{"text":"Q: How is defaultWeeklyDays computed and used? A: It calculates todayWeekdayId from new Date().getDay()+1, filters dayOfWeeksOptions to select the default day for weekly recurrence, used in initialValues.dayOfWeeks."}
{"text":"// ===== Handlers ====="}
{"text":"Q: What does onSubmit do with the form values and reservation data? A: It closes the modal, calls generateTimeSlots(params, reservation) to compute explicit slots, resets the form with updated params, and invokes onSubmitForm callback with the params containing bookingTimes."}
{"text":"Q: How does onChangeFrequencyVal reset and adjust form fields based on frequency? A: It clears 'every', then sets defaults: for daily frequency sets 'every' to '1' and resets 'onType'; for weekly leaves 'every' empty; for monthly sets 'every' to '1', resets 'onType', and clears 'onDay'."}
{"text":"Q: How does handleRemove confirm and remove recurrence settings? A: It shows an Alert asking to cancel or confirm removal; on confirm it calls onRemove, resets the form to initialValues, and closes the modal."}
{"text":"Q: What is the purpose of the term() function and onChangeDay handler? A: term() strips trailing chars; onChangeDay prevents users from entering '.' or ',' in numeric fields by trimming those characters before updating the field via setFieldValue."}
{"text":"Q: How does getTimeZone extract a UTC offset from a date string? A: It checks if the value is truthy and a string, then returns the substring at positions 19–25; otherwise it falls back to '+07:00'."}
{"text":"Q: What does the term(str, char) helper do? A: It drops the last character of `str` and appends `char`, used to strip forbidden punctuation from numeric inputs."}
{"text":"Q: How is each slot’s display string built in BookingRecurringConfirmation? A: getTimeRange formats the date via formatDate + LocaleConfig, then applies moment(...).format('HH:mm') to start/end (with tz), joining them with ' –'."}
{"text":"Q: What does withModal(wrapper, key) add to a component? A: It injects `visible` and `onClosePress` props and wraps the content in a Modal keyed by the provided string, standardizing show/hide behavior."}
{"text":"Q: Why extract UI wrappers via styled-components? A: It centralizes styling, keeps JSX readable, and respects the theme colors and layout rules across multiple sections."}
{"text":"Q: How is defaultWeeklyDays computed? A: It takes today’s weekday index via `new Date().getDay()+1`, then filters the day-of-week options to default the weekly recurrence selector to the current day."}
{"text":"Q: What happens if bookingRequestData.bookingTimes is undefined? A: buildConfirmationObj guards with `data.bookingTimes || []`, so no runtime crash occurs and empty slot lists render gracefully."}
{"text":"// ===== Render ====="}
{"text":"Q: How is conditional rendering implemented for frequency types? A: It uses watch to derive isDaily, isWeekly, isMonthly flags, then shows/hides the 'every' input, 'onType' and 'onDay' dropdowns, and 'dayOfWeeks' multiple dropdown based on these flags."}
{"text":"Q: How are the form controls laid out within the modal? A: Inside a <Modal>, it renders a Header, then <Wrapper> with <FormProvider> and <AwareScrollView> containing FormDropdowns and FormDate fields, followed by a Button row with optional Remove and Accept actions."}
{"text":"// ===== Form Management ====="}
{"text":"Q: How is React Hook Form integrated and initialized in ConfigRecurrenceModal? A: It wraps the inputs in <FormProvider {...formMethods}>, where formMethods comes from useCompatibleForm with defaultValues and resolver, enabling form context for nested FormDate, FormDropdown, and FormInput components."}
{"text":"Q: How are field value changes handled for numeric inputs? A: FormInput for 'every' uses onChangeText={(text) => onChangeDay(text, 'every')} to sanitize input (removing dots/commas) before calling setFieldValue on the form context."}
{"text":"Q: How does handleSubmit connect form validation and submission? A: The primary Accept Button uses onPress={handleSubmit(onSubmit)}, so handleSubmit runs validation via the Yup resolver and then calls onSubmit with valid form values."}
{"text":"Q: How are error messages displayed for validation failures? A: FormDate and FormDropdown components receive the `required` prop and the Yup resolver supplies error messages (e.g., translated 'FORM_THIS_FIELD_IS_REQUIRED') to display beneath inputs."}
{"text":"Q: How is dynamic enabling/disabling of controls managed? A: The Remove button is conditionally rendered by `onRemove`, and frequency-specific inputs (e.g., onDay dropdown) are shown based on reactive flags isDaily/isWeekly/isMonthly derived via watch(['frequency','onType'])."}
{"text":"Q: How is form reset performed after submission or removal? A: onSubmit resets the form to the submitted params via formMethods.reset(params), and handleRemove calls formMethods.reset(initialValues) to clear fields when recurrence is removed."}
{"text":"Q: How are testIDs and accessibility props applied to form elements? A: The Modal receives testID, and individual inputs (e.g., Modal testID, FormDate testID, RemoveBtn testID) ensure elements can be targeted in tests."}
{"text":"// ===== useBookingRecurrence Hook ====="}
{"text":"// ===== Context & Data ====="}
{"text":"Q: What does `useBookingRecurrence` export and when would you use it? A: It exports `generateTimeSlots`, a function that creates reservation slot dates based on recurrence parameters and an initial reservation object."}
{"text":"Q: Which helper functions support `generateTimeSlots` and what are their roles? A: Helpers include `getDatesWithInterval` (fixed-interval dates), `generateWeekDays` (specific weekdays), `generateDatesInMonths` (specific day-of-month across months), `generateWeekInMonths` (nth or last weekday in months), and `copyTime` (merge date with original reservation time)."}
{"text":"// ===== Handlers ====="}
{"text":"Q: How does `getDatesWithInterval(start, end, interval)` compute dates? A: It parses `interval` to an integer step, then loops from `start` to `end`, adding `step` days each iteration to collect each date."}
{"text":"Q: How does `generateWeekDays(start, end, dayOfWeeks)` work? A: It creates a list of dates between `start` and `end` where the weekday (1=Sunday) matches any `id` in `dayOfWeeks`, advancing one day at a time."}
{"text":"Q: How does `generateDatesInMonths(start, end, dayOfMonth, months)` handle 'L' and out-of-range days? A: For 'L' selects the last day of each month; otherwise checks if `dayOfMonth` exists in that month, and only includes valid dates within the range, advancing by `months` each loop."}
{"text":"Q: How do `getLastWeekdayOfMonth` and `getNthWeekdayOfMonth` operate? A: `getLastWeekdayOfMonth` finds the last occurrence of a given weekday; `getNthWeekdayOfMonth` calculates the date of the nth occurrence of a given weekday, returning `null` if it exceeds month length."}
{"text":"Q: What does `generateWeekInMonths(start, end, week, weekDay, interval)` do? A: It iterates by month intervals, computing either the nth or last weekday of each month, including dates within the start-end window."}
{"text":"Q: How does `copyTime(sourceIso, targetDate)` merge date and time? A: It builds a date string from `targetDate` (YYYY-MM-DD) and appends the time part extracted from `sourceIso` (after 'T'), creating a combined ISO string."}
{"text":"Q: How does `generateTimeSlots(params, reservation)` choose which helper to call? A: It reads `frequency.id`, sets `bases` via weekly, monthly, or fixed-interval helpers, then maps each base date to a slot object with `startDate` and `endDate` via `copyTime`."}
{"text":"Q: How is `endOfDay` computed for slot generation? A: It uses `moment(endDate).endOf('day').toDate()` to include events up to the final millisecond of the end date."}
{"text":"Q: Why use `parseInt(every, 10)` in monthly and interval logic? A: To convert the user-entered string to an integer interval for month or day steps, ensuring correct arithmetic."}
{"text":"// ===== SelectAmenityModal ====="}
{"text":"// ===== Context & Data ====="}
{"text":"Q: What props does SelectAmenityModal accept and what are their roles? A: It accepts `visible` (boolean to show/hide the modal), `data` (array of amenity objects), `onClose` (callback invoked to close the modal), and `onSelect` (callback invoked with the selected amenity)."}
{"text":"Q: How is the raw data transformed for grouping? A: It uses `data.reduce` to partition amenities into `groups` (keyed by `amenityGroup.bookingAmenityGroupId`) and `ungrouped` arrays for items without a group."}
{"text":"// ===== State ====="}
{"text":"Q: Which local state does GroupedAmenities manage and what is its purpose? A: It manages `isExpanded` (boolean) to track whether the group is open or closed, and `animation` (Animated.Value) to drive the expand/collapse animation (rotation and opacity)."}
{"text":"// ===== Handlers ====="}
{"text":"Q: How does the `toggleExpand` handler animate the group toggle? A: It flips `isExpanded`, then calls `Animated.spring` on `animation` with `toValue` 1 or 0, `tension: 40`, `friction: 8`, using the native driver for smooth rotation and opacity changes."}
{"text":"Q: How is the arrow icon rotation configured? A: `rotateIcon` is defined by `animation.interpolate` mapping inputRange [0,1] to outputRange ['0deg','180deg'], applied to the `Animated.Text` containing the arrow symbol."}
{"text":"Q: What occurs when an `AmenityItem` is pressed? A: Its `onPress` calls `onSelect(item)`, passing the selected amenity back to the `SelectAmenityModal` parent for further handling."}
{"text":"Q: How does the close button trigger modal dismissal? A: The `CloseButton` component has `onPress={onClose}`, invoking the parent-provided callback to hide the Modal."}
{"text":"// ===== Render ====="}
{"text":"Q: How is the modal and its content structured in the JSX? A: It renders a `Modal` with `animationType='slide'`, inside a `Wrapper` containing `SafeAreaView`, `HeaderWrapper` (with close button and title), and `ContentWrapper` with a `ScrollView` of grouped and ungrouped items."}
{"text":"Q: How are grouped amenities rendered? A: It maps `Object.entries(groupedData.groups)` to `<GroupedAmenities>` components, passing `group`, `items`, `isFirst` (for extra top margin), and `onSelect`."}
{"text":"Q: How are ungrouped amenities rendered? A: It maps `groupedData.ungrouped` to `<AmenityItem>` components directly within the `ScrollView`."}
{"text":"Q: How is the animated expansion of items controlled visually? A: The items for an expanded group are wrapped in an `Animated.View` with `style={{ opacity: animation }}`, so they fade in/out in sync with the rotation animation."}
{"text":"// ===== SlotView & FormSlotView ====="}
{"text":"// ===== Context & Data ====="}
{"text":"Q: What props does SlotView expect and what do they represent? A: `slots` (array of slot objects with isAvailable, isCheck, isFlag, startTime, endTime), `onSlotsChange` (callback to update selected slots), and `numberSlot` (max selectable slots before flag behavior)."}
{"text":"Q: How is form integration handled in FormSlotView? A: It uses `useCommonFormController(name)` to get `value`, `setFieldValue`, and `error`, wraps `SlotView` in `FormControl`, and updates form state in `onSlotsChange`."}
{"text":"// ===== State ====="}
{"text":"Q: Which derived values does SlotView compute via useMemo? A: `totalSelected` (count of slots where isCheck is true) and `showFlag` (boolean true when some but not all slots are selected)."}
{"text":"// ===== Handlers ====="}
{"text":"Q: How does getSlotColor determine each slot’s background color? A: If max slots selected and slot not checked returns grey (#E9EBEE); if checked returns primary color; otherwise returns azure."}
{"text":"Q: What does formatSlotTime do? A: It formats `startTime` and `endTime` strings via `moment(...).format('HH:mm')` and concatenates with '-' for display."}
{"text":"Q: How does onSelectSlot toggle selection and update flags? A: It finds the clicked slot, clears all checks if selecting an unchecked non-flag, toggles its isCheck, then iterates slots to set isFlag true for any unchecked slot adjacent to a checked slot, and calls `onSlotsChange` with updated array."}
{"text":"// ===== Render ====="}
{"text":"Q: How are available and unavailable slots rendered? A: Maps over `slots`: if `isAvailable`, renders `TimeSlot` with onPress, disabled based on `numberSlot` and `isCheck`, colored by `getSlotColor`, and shows `SlotFlag` when appropriate; if not available, renders `UnavailableSlot`."}
{"text":"Q: How is the empty slots state handled? A: If `slots` array is empty, renders `EmptySlotMessage` containing a `SlotText` with text 'BK_NEW_SLOT_EMPTY'."}
{"text":"Q: How does AddOrEditBooking determine whether it’s adding a new booking or editing an existing one? A: It reads `useRoute().name`, setting `isAddNew = (name==='addBooking')` and `isEdit = (name==='editBooking')`, which drives data loading, form defaults, and conditional rendering."}
{"text":"Q: What form controls and warnings are only rendered in “add new” mode? A: When `isAddNew` is true it shows `<FormCalendarPicker>` for date selection, a `BookingWarningText` if outside booking periods, and `<FormSlotView>` to choose time slots—none of which appear in edit mode."}
{"text":"Q: How does the component populate form values when editing? A: In the effect for `[bookingDetail]`, it calls `reset(getInitialValuesForUpdate())`, where `getInitialValuesForUpdate()` maps fields from `bookingDetail`—including nested `status`, `paymentStatus`, `depositPrice`, `unit`/`company`/`email` based on `bookingType`—into the form’s default values."}
{"text":"Q: What differences exist in the payload built by `onSave` for add vs edit? A: For adds, it computes `slotStartTime` and `slotEndTime` from selected slots and includes them; for edits, it uses the original `bookingDetail.startDate`/`endDate`. Both include `amenityId`, `statusCode`, `bookingType`, and conditional `paymentStatus`, file, and contact/company fields before calling `addBooking` or `updateBooking`."}
{"text":"Q: How is validation schema adjusted for add vs edit modes? A: The Yup schema conditionally adds a `slots` test only if `isAddNew` is true, requiring at least one slot selected for new bookings; edit mode skips slot validation entirely."}
{"text":"Q: Which side effects run only when editing an existing booking? A: The effect on `[id]` invokes `getBookingDetail(id)` and returns `resetBookingDetail()` on cleanup; another effect watches `bookingDetail` to fetch files, amenity details and toggle `isDisabledForm` based on status codes."}
{"text":"Q: How does the form become disabled for canceled or declined bookings? A: In the `useEffect([bookingDetail])`, after resetting the form it checks `bookingDetail.status.statusCode`; if it equals `CANCELED` or `DECLINED`, it sets `isDisabledForm=true`, which disables all inputs via `<FormDisabledProvider>`."}
{"text":"Q: What is the purpose of `bookingWarningMessage` and when is it computed? A: It warns the user if the current time is outside the allowed booking period; it's computed in a useMemo based on `bookingPeriods` and `amenityDetail` using `getTimePeriod` and `getTime`."}
{"text":"Q: How does `getTimePeriod(period.from, period.fromTime)` work? A: It combines a date string and a time string into a JavaScript `Date` object representing the full timestamp for period boundaries."}
{"text":"Q: Why does the code guard `if (!bookingPeriods || !amenityDetail) return null;` in the bookingWarningMessage useMemo? A: To avoid errors when data isn't loaded, returning null until both periods and amenity details are available."}
{"text":"Q: How is `bookingWarningMessage` displayed in the UI? A: It renders a `<BookingWarningText>` component with the warning string, styled in warning color, only in add mode when a message exists."}
{"text":"Q: What does the `LoaderContainer` wrapper provide in AddOrEditBooking? A: It displays a loading spinner (`BookingLoading`) while `amenityDetail` is falsy, preventing the form from rendering until data is ready."}
{"text":"Q: How does `SelectAmenityModal` integrate into the AddOrEditBooking workflow? A: It opens when `visibleSelectAmenity` is true (via `onShowSelectAmenity`), allowing the user to choose an amenity and populate the form field via `onAmenitySelect`."}
{"text":"Q: What is the role of `FloatingConversation` in edit mode? A: When editing, it renders a chat floating button tied to the booking’s `guid`, enabling conversation context for the existing booking."}
{"text":"Q: How is the `bookingPeriods` data sourced and why is it needed? A: It's fetched by `useBooking()` hook and used to determine allowed booking windows, driving the bookingWarning logic."}
{"text":"Q: How does `FormDisabledProvider` disable the whole form? A: It wraps the form and passes `disabled={isDisabledForm}` from state, causing all nested form controls to render in a disabled state automatically."}
{"text":"Q: How does the `getTitle()` function decide the screen title? A: It returns the localized string for 'ADD_BOOKING' if `isAddNew` is true, otherwise 'EDIT_BOOKING' for edit mode."}
{"text":"Q: How are `bookingDetail.guid` and `bookingDetail.id` used differently? A: `bookingDetail.id` is used for routing to edit and in FloatingConversation's title prop; `guid` is used by `getFileByReferenceId` and for chat module identification."}
{"text":"Q: Why use `_.size(referenceFiles)` as the effect dependency for setting files? A: To trigger the effect only when the number of `referenceFiles` changes, avoiding unnecessary resets on array identity changes."}
{"text":"Q: How do `getFileByReferenceId` and `getByReferenceIdAndModuleNames` supply file data? A: They fetch reference files for the booking and rule files for the amenity, populating `referenceFiles` and `bookingRuleFiles` for the form fields."}
{"text":"Q: What is the significance of `amenityDetail.isUseDeposited` in payment logic? A: It controls whether the paymentStatus dropdown appears and sets a default paymentStatus for new bookings if deposits are used."}
{"text":"Q: How is `bookingSlots` integrated for new bookings? A: In an effect watching `bookingSlots`, if `isAddNew`, it sets form field `slots` to the fetched `bookingSlots` to initialize available time slots."}
{"text":"Q: How does the `useEffect([startDate, endDate, amenityDetail])` ensure correct slot fetching? A: Whenever the date or amenity changes, it calls `getBookingTimeSlots()` which fetches available slots for the new range and amenity."}
{"text":"Q: Why format `fromToDate` with `moment(startDate).format('YYYY/MM/DD')`? A: To match the backend’s expected date string format when calling `getAllTimeSlots` API."}
{"text":"Q: How does the `calculateDepositPrice` function avoid recalculating unnecessarily? A: It's wrapped in `useCallback` with `[slots]` dependency, and an effect watches the stable function reference, so deposit only recalculates when slots change."}
{"text":"Q: Why does `calculateDepositPrice` exit early when `!amenityDetail` or no `checkedSlots`? A: To prevent errors and unnecessary calculations until both amenity rules exist and at least one slot is selected."}
{"text":"Q: How are weekday names mapped to numeric day indices in deposit calculation? A: It uses `weekday[moment(startDateSlot).day()]` where `weekday` is an array mapping 0–6 to day name strings matching `amenityTimeRules.numNextValidDate`."}
{"text":"Q: What does `matchingRule` represent in deposit calculation? A: It’s the amenity time rule object whose `numNextValidDate`, `startTime`, and `endTime` match the selected slot’s day and times, providing the price for deposit."}
{"text":"Q: How are `price` values applied to the form after finding a matching rule? A: It calls `setValue('depositPrice', { rawValue: price, text: formatted })`, updating both the numeric and display parts of the deposit field."}
{"text":"Q: How is the recurring booking flow triggered in AddOrEditBooking? A: If `formValues.recurrence` exists, `onSave` delegates to `recurringBooking` instead of `addBooking`/`updateBooking`, launching the validation and confirmation modal sequence."}
{"text":"Q: How does `recurringBooking` handle empty `bookingTimes` arrays? A: It shows an alert 'NO_RECURRING_SLOT_AVAILABLE' and returns early, preventing further processing."}
{"text":"Q: How does `recurringBooking` build `bookingObj` and why delete `startDate`/`endDate`? A: It spreads `bookingParams`, sets `amenityId`, deletes date fields because `bookingTimes` array replaces them for multi-slot bookings in the recurring flow."}
{"text":"Q: How is the human-readable `status` name looked up in `recurringBooking`? A: It finds the matching status object in `statusList` by `statusCode` and uses `item.name` for display in confirmation data."}
{"text":"Q: What triggers the BookingConfirmation modal to appear? A: After successful `validateRecurringBooking`, `setBookingRequestData` fills data and `setConfirmationVisible(true)` opens the modal."}
{"text":"Q: How does `handleConfirm` differ from `onSave`? A: `handleConfirm` calls `onSave(formMethods.getValues())` to perform the actual booking API call after the user confirms the recurring slots, then closes the confirmation modal."}
{"text":"Q: How does `onAmenitySelect` update the form when the user picks a new amenity? A: It calls `setValue('amenityId', selectedAmenity.amenityId)`, `getAmenityDetail(...)`, and closes the modal, triggering effects to load related data."}
{"text":"Q: Why use `useMemo` for `displayStatus`? A: To compute the list of status options only when `statusList` or `isAddNew` changes, filtering out canceled/declined codes for new bookings."}
{"text":"Q: How does the component ensure the Save button always triggers validation? A: The Save button’s `onPress` is `handleSubmit(onSave)`, so React Hook Form runs its resolver before calling `onSave`."}
{"text":"Q: How would you integrate testIDs for automated tests in AddOrEditBooking? A: Add `testID` props to key components: `FormCalendarPicker`, slot picker, dropdowns, Save button, and Modal close, enabling E2E selectors."}
{"text":"Q: What guard ensures `onSave` only runs when the form is valid? A: `handleSubmit` wraps `onSave`, only invoking it if validation passes; invalid forms never call `onSave`."}
{"text":"Q: How are errors surfaced to the user on API failure? A: In `recurringBooking`, catch blocks call `Alert.alert('ERROR', error.message)`; similarly, you could wrap `addBooking/updateBooking` in try/catch for alerts."}
{"text":"Q: How could you add character limits to the `remark` input? A: Pass `maxLength={200}` to `<FormInput name=\"remark\" />` and optionally display `{watch('remark').length}/200` below the field."}
{"text":"Q: How do you reset form state when closing the modal? A: In the `onCloseSelectAmenity` or `handleConfirm` paths, call `formMethods.reset(initialValues)` to clear any unsaved changes."}
{"text":"Q: How is the `requiredMessage` shared across validation rules? A: It’s computed once via `I18n.t('FORM_THIS_FIELD_IS_REQUIRED')` and reused in the Yup schema for consistent error text."}
{"text":"Q: What side effect ensures `bookingRuleFiles` are loaded for the selected amenity? A: The effect on `[bookingRuleFiles, amenityDetail]` calls `setValue('bookingRuleFiles', bookingRuleFiles)` whenever either changes."}
{"text":"Q: How would you extend the code to support multi-day bookings? A: Change `FormCalendarPicker` to a date-range picker, update `startEndDate` to hold two dates, and adjust `getBookingTimeSlots` to fetch slots across the range."}
{"text":"Q: How does the component manage multiple asynchronous data sources? A: By sequential useEffect hooks for detail, files, slots, etc., each gated by dependencies to load only when prerequisites are met."}
{"text":"Q: What accessibility considerations are built in? A: Use of `testID`, proper `label` props on form fields, and consistent `role` semantics via Buttons and Modals help automated tools and screen readers."}
{"text":"// ===== Slot & Deposit Logic Prompts ====="}
{"text":"Q: What hook dependency ensures deposit recalculation runs at the correct time? A: The effect depends on the `calculateDepositPrice` callback, which itself depends on `slots`, so deposit updates whenever slots change."}
{"text":"Q: Why is `calculateDepositPrice` wrapped in `useCallback`? A: To memoize the function reference so the effect only reruns when its `slots` dependency changes, avoiding unnecessary recalculations."}
{"text":"Q: How does the code guard against missing `amenityDetail` before running deposit logic? A: It early-returns from `calculateDepositPrice` if `!amenityDetail`, preventing null dereferences."}
{"text":"Q: How are checked slots determined for deposit calculation? A: `slots.filter(item => item.isCheck)` gathers all user-selected slots into `checkedSlots`."}
{"text":"Q: How is the start time for deposit calculated? A: It uses the `startTime` of the first element in `checkedSlots` array."}
{"text":"Q: How is the end time for deposit calculated? A: It uses the `endTime` of the last element in `checkedSlots` array."}
{"text":"Q: How are weekday names mapped for matching time rules? A: The `weekday` array maps moment().day() index to a name string matching `amenityTimeRules.numNextValidDate`."}
{"text":"Q: What format does `moment(startDateSlot).format('HH:mm:ss')` produce? A: A string like '14:30:00' for exact match with rule definitions."}
{"text":"Q: Why match rule times exactly as ‘HH:mm:ss’? A: To ensure precise rule selection since rules store times in that exact format."}
{"text":"Q: How does the code find the matching amenity time rule? A: It calls `amenityDetail.amenityTimeRules.find` with predicates comparing `numNextValidDate`, `startTime`, and `endTime` to the selected slot values."}
{"text":"Q: What happens if no matching rule is found? A: The function exits without calling `setValue`, leaving the deposit unchanged."}
{"text":"Q: How does `setValue('depositPrice', {...})` update form state? A: It writes both `rawValue` and `text` fields for the deposit input, triggering a re-render of `FormMoneyInput`."}
{"text":"Q: Why is `LocaleConfig.formatMoney(price)` used? A: To convert numeric price into a localized currency string for user display."}
{"text":"Q: How can you prevent negative prices? A: Add a guard `if (price < 0) return;` before calling `setValue`."}
{"text":"Q: Why clear previous deposit before recalculation? A: Implicitly done by `setValue` replacing old data; ensures stale values aren’t shown."}
{"text":"Q: How could rounding issues be handled? A: Use `Math.round(price * 100) / 100` before formatting to avoid floating point artifacts."}
{"text":"Q: What React Hook Form method resets deposit on slot deselect? A: `setValue` is called only when a matching rule exists; on deselect, deposit remains prior until slots change again."}
{"text":"Q: How to force deposit reset on no selection? A: Add `if (checkedSlots.length===0) setValue('depositPrice', {rawValue:0,text:'0'});` in `calculateDepositPrice`."}
{"text":"Q: Why choose `moment` for date operations? A: It simplifies formatting and timezone handling compared to vanilla JS `Date` methods."}
{"text":"Q: How is timezone handled when computing day of week? A: `moment(startDateSlot).day()` uses local timezone by default, matching user context."}
{"text":"Q: What side effect triggers slot-to-deposit recalculation? A: The effect `useEffect(()=>{calculateDepositPrice()}, [calculateDepositPrice])` runs on callback changes."}
{"text":"Q: How can you debounce deposit calculations? A: Wrap `calculateDepositPrice` in a `useDebounce` hook or throttle calls inside the effect."}
{"text":"Q: Why not calculate deposit in the slot-change handler? A: Separation of concerns: handler updates slots; effect centralizes deposit logic, improving readability."}
{"text":"Q: What unit tests would you write for deposit logic? A: Test various slot arrays against known rules and assert `setValue` called with correct price and formatted text."}
{"text":"Q: How would you mock `amenityTimeRules` for testing? A: Provide a fake `amenityDetail` with a static `amenityTimeRules` array and simulate `slots` updates."}
{"text":"Q: How does early return improve performance? A: It avoids unnecessary computation when prerequisites (amenityDetail or slots) are missing."}
{"text":"Q: How does `slots.filter` handle undefined? A: `watch('slots')||[]` ensures `slots` is always an array, preventing filter errors."}
{"text":"Q: How does useCallback memoize the function? A: It returns the same function instance unless its dependency `slots` changes."}
{"text":"Q: How can you visualize deposit changes in the UI? A: Add a debug `<Text>{depositPrice.text}</Text>` next to the field to confirm updates."}
{"text":"Q: How to support multiple deposit rules per day? A: Modify logic to handle multiple matching rules, e.g., summing all applicable rule prices."}
{"text":"Q: How to internationalize deposit rules? A: Store prices in smallest currency units and use `Intl.NumberFormat` instead of `LocaleConfig`."}
{"text":"Q: What error could occur if `amenityDetail.amenityTimeRules` is undefined? A: `find` on undefined would throw; guard using `?.find` to prevent crashes."}
{"text":"Q: How might you handle daylight-saving shifts? A: Convert all times to UTC before matching, or use moment timezone plugin."}
{"text":"Q: How do you prevent multiple `setValue` calls? A: Use a flag or compare old vs new deposit value before calling `setValue`."}
{"text":"Q: Why not compute deposit inline in JSX? A: It would re-run on every render, hurting performance; effect approach runs only on relevant changes."}
{"text":"Q: How does deposit logic differ for recurring bookings? A: Recurring uses separate flow, deposit for single-day only in add mode; ensure separation between flows."}
{"text":"Q: How would you log deposit calculations for debugging? A: Insert `console.log` statements inside `calculateDepositPrice` to trace matching rules and prices."}
{"text":"Q: What UX feedback could accompany deposit updates? A: Show a spinner or disabled state on deposit field while calculating for slow rules lookup."}
{"text":"Q: How to handle missing `numNextValidDate` in rules? A: Default to first rule or skip deposit if none match, alerting the user as needed."}
{"text":"Q: How could rule matching be optimized? A: Index rules in a map by `dayName` and `startTime-endTime` pairs for O(1) lookup instead of O(n) scan."}
{"text":"Q: When should deposit logic be refactored into a custom hook? A: If used across multiple components or flows, encapsulate in `useDepositCalculation` for reuse."}
{"text":"Q: How to handle different slot durations? A: Multiply rule price by number of hours or use prorated pricing rules based on slot length."}
{"text":"Q: How does the code ensure deposit updates after slot edits? A: `useEffect` on `calculateDepositPrice` sees new `slots` array reference and recalculates automatically."}
{"text":"===== Recurring-booking Flow Prompts ====="}
{"text":"Q: What triggers the recurring booking flow instead of a simple save? A: The presence of `formValues.recurrence` in `onSave` causes the code to call `recurringBooking` and skip the standard API call."}
{"text":"Q: How does `recurringBooking` prepare the booking object? A: It spreads `bookingParams`, sets `amenityId`, deletes `startDate`/`endDate`, and maps `rec.bookingTimes` into the payload."}
{"text":"Q: Why remove `startDate` and `endDate` for recurring bookings? A: Recurrence uses an array of `bookingTimes` instead of a single date range, avoiding conflicts."}
{"text":"Q: How are invalid slots handled in the flow? A: `invalidSlots` from API response are stored in `bookingRequestData` and shown in the confirmation modal."}
{"text":"Q: How does `validateRecurringBooking` differ from `addBooking`? A: It checks availability of all requested slots without persisting, returning a status and lists of valid/invalid times."}
{"text":"Q: What UI is shown after a successful recurring validation? A: The `BookingConfirmation` modal opens, showing valid and invalid slots, metadata, and Confirm/Cancel buttons."}
{"text":"Q: How is the confirmation modal populated with data? A: `setBookingRequestData` stores API response plus `amenityName`, `requestedBy`, `createdDate`, and status name."}
{"text":"Q: How does the modal let the user remove invalid slots? A: In `BookingConfirmation`, each valid slot row has a trash icon that calls `handleRemoveSlot(index)`."}
{"text":"Q: What does `handleRemoveSlot` do? A: It shows an Alert, and on confirmation filters out that index from `localData.validSlots`."}
{"text":"Q: How are time ranges formatted in the confirmation list? A: `getTimeRange` uses `formatDate` and `moment.utcOffset` to produce 'YYYY/MM/DD HH:mm – HH:mm' strings."}
{"text":"Q: How does the component compute timezone offsets? A: The helper `getTimeZone(slot.startDate)` extracts offset substring or falls back to '+07:00'."}
{"text":"Q: How does the user finalize recurring bookings? A: They press Confirm in the modal, triggering `handleConfirmBooking`, which re-maps `validSlots` into `bookingTimes` and calls `recurringBooking` API."}
{"text":"Q: Why call `recurringBooking` again in `handleConfirmBooking`? A: To persist the filtered slots as an actual booking after user confirmation."}
{"text":"Q: How does `handleConfirmBooking` clean up state? A: It calls `onClosePress()` to close the modal, then navigates back and emits an update event on success."}
{"text":"Q: How are errors surfaced during recurring booking? A: In `recurringBooking`, catch blocks call `Alert.alert('ERROR', error.message)` to notify the user."}
{"text":"Q: What is included in the confirmation metadata? A: `requestedBy`, `amenityName`, `createdDate`, and human-readable `status` name for context."}
{"text":"Q: How does `bookingRequestData` shape the modal? A: It contains arrays `validSlots`/`invalidSlots` and fields for labels, which `BookingRecurringConfirmation` uses to render lists and messages."}
{"text":"Q: How is the ‘cannot-booking-text’ displayed? A: It renders a red `Text` listing each invalid slot time prefixed with bullets, testID’d for testing."}
{"text":"Q: What happens if user cancels in the confirmation modal? A: `onClosePress` closes the modal, and since no save occurs, the form remains open with original `slots`."}
{"text":"Q: How does the code prevent accidental full-booking? A: It requires user confirmation on filtered valid slots before final API call, avoiding booking unavailable times."}
{"text":"Q: How does the event emitter update other screens? A: `DeviceEventEmitter.emit('UpdateListBooking')` notifies listeners (e.g. Booking screen) to refresh data."}
{"text":"Q: Why deep-clone data in `buildConfirmationObj`? A: To avoid mutating props directly and ensure state isolation within the confirmation component."}
{"text":"Q: How can you cancel the recurring booking flow? A: Press Cancel in the modal, triggering `onClosePress` without calling the save API."}
{"text":"Q: How is the order of valid slots maintained? A: `bookingTimes.map` preserves the chronological order passed from recurrence generator."}
{"text":"Q: What side effect updates the confirmation when `bookingRequestData` changes? A: A `useEffect` in `BookingRecurringConfirmation` rebuilds `localData` via `buildConfirmationObj`."}
{"text":"Q: How are invalid slot bullets generated? A: In `cannotBookingText`, map over `invalidSlots` to prefix each with '• ' and join with newlines."}
{"text":"Q: How do you test recurring flow logic? A: Write unit tests mocking `validateRecurringBooking` to return mixed valid/invalid slots, then assert that modal shows correct lists."}
{"text":"Q: How could you optimize slot removal? A: Instead of full array filter, mark slots as removed in state and skip showing them, improving performance for large lists."}
{"text":"Q: How to handle very large recurrence sets? A: Paginate the confirmation list or summarize ranges instead of listing every slot."}
{"text":"Q: How does fetch-period validation differ from save-period validation? A: Recurrence uses real-time availability checks via `validateRecurringBooking`, whereas add uses single-day slot fetch."}
{"text":"Q: Why separate validation and persistence into two API calls? A: To let users adjust selections before committing, reducing failed save attempts and enhancing UX."}
{"text":"Q: How can you add a ‘Select All’ valid slots feature? A: In the modal, provide a button that calls `setLocalData({…validSlots: allValidSlots, invalidSlots})`."}
{"text":"Q: How does the code ensure time consistency across DST changes? A: Uses `moment.utcOffset` with extracted offset when formatting times, though deeper timezone fixes may be needed."}
{"text":"Q: What accessibility props should the confirmation modal include? A: `accessibilityLabel` on buttons, clear focus management when the modal opens, and descriptive text for invalid slot warnings."}
{"text":"Q: How does `onRemoveSlot` maintain state immutability? A: It creates a new `newValidSlots` array via `filter` and uses `setLocalData` with a new object."}
{"text":"Q: How might you extract confirmation logic into a custom hook? A: Encapsulate `buildConfirmationObj`, `handleRemoveSlot`, and `handleConfirmBooking` in `useBookingConfirmation` for reuse."}
{"text":"Q: How would you automatically scroll to the first invalid slot? A: Use a `ref` to the FlatList and call `scrollToIndex({index:0})` when invalid slots exist."}
{"text":"Q: How does the modal distinguish between valid and invalid slots? A: Different lists (`validSlots` for removal, `invalidSlots` for warning) with separate render logic."}
{"text":"Q: How are confirmation buttons styled differently? A: ‘Cancel’ is default; ‘Confirm’ is `primary rounded` to highlight the action."}
{"text":"Q: What event cleans up confirmation state on unmount? A: When the modal unmounts, component state resets; you could add `useEffect(()=>() => setBookingRequestData(null), [])` to clear data."}
{"text":"Q: How do you integrate analytics for recurring bookings? A: In `handleConfirmBooking`, send telemetry events with number of slots and patterns before API call."}
{"text":"Q: Why use a separate `BookingRecurringConfirmation` component? A: To isolate confirmation UI/logic from the main form, improving maintainability and reusability."}
{"text":"Q: How can you localize date/time formats in the modal? A: Use `I18n.t` keys for date formats and `LocaleConfig` to format dates per user locale."}
{"text":"Q: How can the modal show a summary of recurrence rules? A: Display `recurrence` object details (frequency, every, onType, onDay) at the top of the modal."}
{"text":"Q: What tests ensure full flow coverage? A: E2E tests simulating slot selection, recurrence setup, modal review, removal, and final confirm with mocked API."}
{"text":"Q: How would you provide undo for removed slots in confirmation? A: Add an ‘undo’ snackbar that re-inserts the removed slot back into `localData.validSlots`."}
{"text":"Q: How is modal layering handled with React Navigation? A: `withModal` HOC uses a `Modal` at the root, independent of navigation stack, ensuring it overlays correctly."}
{"text":"Q: How does the component avoid memory leaks on event listeners? A: No external listeners in confirmation; the main form cleans up `DeviceEventEmitter` subscriptions elsewhere."}
{"text":"Q: How does final save integrate recurring and single-slot flows? A: Both flows eventually call `addBooking` or `updateBooking` with the constructed payload—single-slot via `onSave`, recurring via `handleConfirmBooking`."}
{"text":"Q: How can you disable the Confirm button if no valid slots remain? A: Use `{validSlots.length > 0 && <ConfirmButton>}` logic, which already hides it when empty."}
{"text":"Q: What logging would help troubleshoot recurring errors? A: Log API request payload, server response, and any exceptions in `catch` blocks."}
{"text":"Q: How might you batch multiple booking requests for performance? A: If the API supports bulk, gather `bookingTimes` arrays and call a batch endpoint instead of multiple calls."}
{"text":"Q: How can you display a progress indicator during validation? A: Set a `isValidating` state before calling `validateRecurringBooking` and show a spinner in the modal overlay."}
{"text":"Q: How would you refactor both logic blocks into separate hooks? A: Extract deposit into `useDepositPrice(slots, rules)` and recurring flow into `useRecurringBooking(recParams, onSuccess)`."}
{"text":"Q: How can you ensure idempotency of recurring bookings? A: Include a unique client-generated ID in payload to prevent duplicate bookings on retries."}
{"text":"Q: What cleanup is needed when the component unmounts? A: Cancel any pending API requests (e.g., via AbortController) and clear form state if desired."}
{"text":"Q: How does the `SlotView` component determine how many slots have been selected? A: It uses `useMemo` to count `slots.filter(item => item.isCheck).length` and stores it in `totalSelected`, recomputing only when `slots` changes."}
{"text":"Q: What condition makes the “flag” icon appear on a slot? A: `showFlag` becomes true when `totalSelected > 0 && totalSelected < numberSlot`, and each unselected slot adjacent to a selected one gets `isFlag=true`, causing `<SlotFlag/>` to render."}
{"text":"Q: How is the background color of a slot computed? A: `getSlotColor(slot)` returns gray `#E9EBEE` if max slots reached and slot unchecked, primary if `slot.isCheck`, or azure otherwise."}
{"text":"Q: What happens when the user taps a slot? A: `onSelectSlot(index)` toggles `isCheck` for that slot, clears other checks if selecting a non-flag new slot, then recomputes `isFlag` for neighbors before calling `onSlotsChange([...slots])`."}
{"text":"Q: Why does selecting a non-flag slot clear previous selections? A: To ensure contiguous selection, tapping outside the current flagged range resets all `isCheck` flags when the new slot has `isFlag===false`."}
{"text":"Q: How does `onSelectSlot` decide which slots get flagged? A: After toggling, it iterates slots: if an unchecked slot has a checked neighbor (previous or next), it sets `isFlag=true`, marking it as part of a contiguous range."}
{"text":"Q: How are unavailable slots rendered? A: If `item.isAvailable` is false, `SlotView` shows an `<UnavailableSlot>` styled with a grey background and no touch handler, displaying time text only."}
{"text":"Q: How is the time label on each slot formatted? A: `formatSlotTime(start,end)` uses `moment(start,'YYYY-MM-DD HH:mm').format('HH:mm')` for both times, joining them with `-`, e.g. `09:00-10:00`."}
{"text":"Q: What does the `disabled` prop on `<TimeSlot>` do? A: It prevents selecting more than `numberSlot` slots: when `totalSelected===numberSlot` and this slot isn’t checked, `disabled` is true, blocking taps."}
{"text":"Q: How does `FormSlotView` integrate `SlotView` into React Hook Form? A: It uses `useCommonFormController(name)` to get `value`/`setFieldValue`, wraps `SlotView` in `<FormControl>`, and in `onSlotsChange` calls `setFieldValue(newSlots)` plus any `onChange` prop."}
{"text":"Q: How is the maximum number of selectable slots enforced? A: Through the `numberSlot` prop: once `totalSelected` equals `numberSlot`, all other unchecked slots become disabled and greyed out."}
{"text":"Q: What does the empty state look like when there are no slots? A: `SlotView` checks `_.size(slots) > 0`; if false, it renders `<EmptySlotMessage>` with text key `BK_NEW_SLOT_EMPTY`."}
{"text":"Q: How are flags cleared when deselecting slots? A: In `onSelectSlot`, after toggling a slot off, it iterates all slots resetting `isFlag` to false unless they adjoin a checked slot, ensuring flags always reflect current adjacency."}
{"text":"Q: Why does `SlotView` copy the `slots` array before calling `onSlotsChange`? A: To provide a new reference (`[...slots]`) so React Hook Form detects the update and re-renders the form field."}
{"text":"Q: How would you modify the logic to allow non-contiguous slot selection? A: Remove the block in `onSelectSlot` that clears all checks when selecting a non-flag slot, and skip adjacency-based `isFlag` toggling."}
{"text":"Q: How does `SlotView` initialize the display of flags when slots data first loads? A: Flags are initially false; only after a user selection does `onSelectSlot` calculate and set `isFlag` on adjacent slots."}
{"text":"Q: Why does `onSelectSlot` clear all `isCheck` flags when selecting an unchecked, non-flag slot? A: To enforce a single contiguous block selection: tapping outside the current block resets selection to start a new block at that slot."}
{"text":"Q: How does the code ensure that flags always reflect current adjacency after toggling a slot? A: After toggling, it loops through all slots, checking each unchecked slot’s neighbors and setting `isFlag=true` if either neighbor is checked, otherwise clearing it."}
{"text":"Q: What would happen if the flag logic block in `onSelectSlot` were removed? A: Slots adjacent to checked ones would no longer be visually distinguished, breaking the UI cue for contiguous selection."}
{"text":"Q: How is the `numberSlot` prop used to limit user selection? A: It defines the maximum `isCheck` count; once reached, all other unchecked slots are disabled and greyed until the user deselects one."}
{"text":"Q: How could you extend `SlotView` to support a minimum contiguous block size? A: Add a prop `minSlot`; in `onSelectSlot`, prevent toggling off until at least `minSlot` contiguous `isCheck` slots remain, showing an error otherwise."}
{"text":"Q: How does `FormSlotView` propagate external `onChange` behavior? A: It calls the optional `onChange(newSlots)` callback after `setFieldValue`, allowing parent components to react (e.g., updating recurrence logic)."}
{"text":"Q: In `AddOrEditBooking`, how does changing slots trigger recurrence updates? A: The `onChange` passed to `FormSlotView` recomputes `bookingTimes` via `generateTimeSlots` when `recurrence` exists, updating the `recurrence.bookingTimes` field."}
{"text":"Q: Why does `FormSlotView` use `useCommonFormController` instead of `useFormContext().watch` directly? A: `useCommonFormController` encapsulates form registration, value retrieval, setter, and error handling for a given field name, simplifying integration."}
{"text":"Q: How does disabling of slots interact with the disabled form state? A: When `isDisabledForm` is true (edit of canceled/declined), `_commonFormController` likely passes `disabled` into `SlotView`, preventing all taps."}
{"text":"Q: How would you add keyboard accessibility to slot selection? A: Add `accessible` and `accessibilityRole='button'` props to `TimeSlot`, handling `onAccessibilityAction` for selection, and updating `isCheck` accordingly."}
{"text":"Q: What visual feedback could be added when a slot is tapped? A: Add a short `Animated.spring` scale effect on the tapped `TimeSlot`, leveraging the existing `Animated` API used elsewhere in the UI."}
{"text":"Q: How does the design ensure that slot state remains in sync with form state? A: `FormSlotView`’s `value` prop (from `useCommonFormController`) is bound to `slots`, so any external form reset updates the displayed slots immediately."}
{"text":"Q: How could you unit-test the slot adjacency logic? A: Write tests that feed arrays of slots with `isCheck` patterns into `onSelectSlot`, then assert the resulting `isFlag` flags both before and after toggles."}
{"text":"Q: How are stale slot references avoided when updating state? A: By using `onSlotsChange([...slots])`, a new array is created; combined with React Hook Form’s new `value` reference, stale closures are prevented."}
{"text":"Q: What is the significance of checking `idx < slots.length - 2` when flagging next slots? A: Ensures indexing safety: it checks only up to the second-to-last slot (so `idx+1` exists), avoiding out-of-bounds errors."}
{"text":"Q: How does the code handle simultaneous rapid taps on multiple slots? A: Since state updates synchronously in `onSelectSlot`, rapid taps will queue handlers; you may need to debounce `onSelectSlot` to avoid race conditions."}
{"text":"Q: Why use `moment(startTime, 'YYYY-MM-DD HH:mm')` instead of plain JS `Date` parsing? A: `moment` ensures consistent parsing across platforms and locales, matching the backend format precisely for user display."}
{"text":"Q: How could you display tooltips for each slot’s exact ISO timestamp? A: Wrap `SlotText` in a `Tooltip` component, showing the original `startTime` and `endTime` on long press or hover."}
{"text":"Q: What happens to slot selections when the date changes? A: In `AddOrEditBooking`, changing `startEndDate` triggers `getBookingTimeSlots`, which calls `setValue('slots', bookingSlots)` resetting selections to the new date’s slots."}
{"text":"Q: How does the effect `useEffect([bookingSlots])` ensure new slots are loaded for add mode? A: It watches `bookingSlots` from context; when they update (from API), it calls `formMethods.setValue('slots', bookingSlots)` for fresh data."}
{"text":"Q: How is `bookingSlots` fetched in the first place? A: `useBooking()` hook’s `getAllTimeSlots` is called in `useEffect([startDate,endDate,amenityDetail])`, populating `bookingSlots` via context/saga."}
{"text":"Q: How would you optimize rendering for large numbers of slots? A: Use `FlatList` instead of mapping over arrays, with `initialNumToRender`, `windowSize`, and `getItemLayout` for performance on hundreds of slots."}
{"text":"Q: How does slot selection affect deposit recalculation? A: `calculateDepositPrice` effect depends on `slots`; any change (via `onSlotsChange`) triggers deposit logic to update form field `depositPrice`."}
{"text":"Q: Why doesn’t `calculateDepositPrice` run directly in `onSelectSlot`? A: Separation of concerns: selection handler only updates slots; a dedicated effect recalculates deposit, keeping side effects centralized."}
{"text":"Q: How would you display a loading state while slots are fetched? A: Introduce an `isLoadingSlots` flag in context, render a spinner overlay in `SlotView` when true, hiding slot buttons until ready."}
{"text":"Q: How can you preserve slot selection when switching between add and edit modes? A: Store `slots` in component state or context keyed by booking ID, re-inject via `formMethods.reset` in `getInitialValuesForUpdate` for edit mode."}
{"text":"Q: How do you handle timezone differences in slot times? A: Ensure `getBookingTimeSlots` and `formatSlotTime` both use the same timezone context (via `moment.tz`), so labels match the user’s local zone."}
{"text":"Q: How can `numberSlot` be dynamically computed based on amenity rules? A: Pass `numberSlot={amenityDetail.numOfExtendTimeSlot + 1}` into `FormSlotView`, as current code fetches via `_.get` in JSX."}
{"text":"Q: What visual change indicates the slot limit has been reached? A: Unchecked slots turn grey and `disabled`, preventing taps; flags and selected slots remain colored to show active block."}
{"text":"Q: How would you add multi-touch support to extend selection? A: On touch-move across slots, detect drag gestures and call `onSelectSlot` for each slot under the finger, enabling click-and-drag selection."}
{"text":"Q: How could you allow deselecting the first slot of a block? A: Modify the clear-all logic: if the tapped slot is at the block edge (`isFlag===true`), allow toggling it off without clearing the whole block."}
{"text":"Q: What accessibility label would you assign to slots? A: Use `accessibilityLabel={Slot from ${formatSlotTime(start,end)} ${slot.isCheck? selected : unselected}}` on each `TimeSlot`."}
{"text":"Q: How does the component handle stale `recurrence` when slots change? A: The passed `onChange` resets `recurrence.bookingTimes` via `generateTimeSlots`, keeping recurrence in sync with slot selection."}
{"text":"Q: How to prevent slot selection when form is disabled? A: Wrap `SlotView` in `<FormDisabledProvider>` so `useCommonFormController` passes `disabled` prop, disabling all touch handlers conditionally."}
{"text":"Q: How does the slot component clean up memory on unmount? A: No subscriptions in `SlotView`; once unmounted, its state and handlers are garbage-collected automatically."}
{"text":"Q: How to extend slot logic for variable-length bookings? A: Add a `duration` prop per slot; in `onSelectSlot`, allow selection of non-adjacent slots if their durations sum to the requested total."}
{"text":"Q: How do you integrate real-time slot availability updates? A: Subscribe to a WebSocket feed for slot changes; on messages update `bookingSlots` in context, triggering form reset in `FormSlotView`."}
{"text":"Q: How can you test end-to-end slot booking flows? A: Write E2E tests that navigate to add-booking screen, select date, wait for slots, tap contiguous and non-contiguous slots, verify flags, save, and assert booking success."}
{"text":"Q: How to handle daylight savings transitions in slot times? A: Use `moment.tz` with fixed timezone for both fetching and formatting, ensuring slot intervals shift correctly on DST change days."}
{"text":"Q: Why does the component avoid using slot index as the key in lists? A: It uses `index.toString()`, which is acceptable here as slot order doesn’t change dynamically; for dynamic lists, a unique ID would be safer."}
{"text":"Q: How would you internationalize slot time formats? A: Replace `moment.format('HH:mm')` with `moment.locale(I18n.locale).format('LT')`, using locale-specific 12/24-hour conventions."}
{"text":"Q: How could you visualize available vs unavailable slots differently? A: Add opacity or an icon overlay to unavailable slots, beyond just grey background, improving user clarity."}
{"text":"Q: How to optimize `formatSlotTime` for large arrays? A: Precompute and cache formatted strings on slot fetch, storing alongside each slot, rather than recalculating on every render."}
{"text":"Q: How does the code ensure `slots` always has a default? A: The prop default `slots = []` in function signature prevents undefined errors in mapping and filtering operations."}
{"text":"Q: How would you add swipe-to-clear functionality across selected slots? A: Detect horizontal swipe gestures on `TimeSlotBox` and clear all `isCheck` by calling `onSlotsChange([])` on swipe end."}
{"text":"Q: What improvements could be made for long-press selection? A: Long-press a slot to select a range: on long-press start record index, on long-press end select all slots between start and end indices."}
{"text":"Q: How to handle server-side slot booking conflicts after local selection? A: After user taps Save, revalidate slots via API; on conflict, highlight conflicted slots and prompt user to adjust selection."}
{"text":"Q: How can you add visual grouping by hour or day? A: In `SlotView`, group `slots` by date/hour, render headings between groups in the map, improving readability for multi-day slots."}
{"text":"Q: How does state immutability ensure predictable updates? A: By creating new arrays (`[...slots]`) and objects for flags/checks, React’s change detection reliably triggers re-renders and avoids mutation bugs."}
{"text":"Q: How does the AddOrEditBooking component decide whether to create a new booking or update an existing one? A: It reads `useRoute().name` and sets `isAddNew = name==='addBooking'`; in `onSave`, it calls `addBooking(payload)` if `isAddNew` is true, otherwise `updateBooking(payload)`."}
{"text":"Q: Which core data fields must be included in the payload for both add and edit operations? A: `amenityId`, `startDate`, `endDate`, `status` (statusCode), `bookingType`, `files` (only new uploads), and optionally `paymentStatus` if deposits are used."}
{"text":"Q: How are `startDate` and `endDate` computed for a new booking? A: They derive from the first and last checked slot’s `startTime` and `endTime` respectively, inside `onSave` when `isAddNew` is true."}
{"text":"Q: How are `startDate` and `endDate` handled for editing? A: When `isAddNew` is false, the payload reuses `bookingDetail.startDate` and `bookingDetail.endDate` without modification."}
{"text":"Q: How does the code filter out already-uploaded files before sending the payload? A: It runs `formValues.files.filter(item => item.path)` to include only files with a local `path` property for upload."}
{"text":"Q: How is the `status` field represented in the payload? A: It takes `formValues.status.statusCode` and assigns it to the `status` key in `payload`."}
{"text":"Q: When should the `paymentStatus` field be included in the payload? A: Only if `amenityDetail.isUseDeposited` is true; it sets `payload.paymentStatus = formValues.paymentStatus.paymentStatusCode`."}
{"text":"Q: How does the handler include occupier-specific fields in the payload? A: For `bookingType===occupier`, it adds `buildingId`, `unitId`, `fullUnitId`, `userId`, `name`, `userName`, `phone`, `email`, and `emailAddress` from the `unit` and contact form values."}
{"text":"Q: How does the handler include company-specific fields? A: For `bookingType===company`, it sets `payload.companyId=formValues.company.id`, `payload.name=formValues.company.companyName`, and `payload.email=formValues.company.primaryEmail`."}
{"text":"Q: How does the handler include outsider-specific fields? A: For `bookingType===outsider`, it simply sets `payload.email = formValues.email`."}
{"text":"Q: What logic handles recurring bookings inside `onSave`? A: If `formValues.recurrence` exists, `onSave` calls `await recurringBooking(formValues, payload)` and returns early, skipping the single-date API call."}
{"text":"Q: How does `recurringBooking` build its payload differently? A: It deletes `startDate`/`endDate`, maps `rec.bookingTimes` into `bookingObj.bookingTimes`, and calls `validateRecurringBooking` instead of `addBooking/updateBooking`."}
{"text":"Q: How are API errors handled during add/update operations? A: Currently errors in `recurringBooking` are caught and show `Alert.alert('ERROR', error.message)`; similar try/catch could wrap `addBooking/updateBooking` to alert the user."}
{"text":"Q: What happens after a successful add or update? A: It emits `DeviceEventEmitter.emit('UpdateListBooking')` to refresh other screens, then calls `navigation.goBack()` to return."}
{"text":"Q: Why is `files.filter(item => item.path)` used instead of sending all files? A: To avoid re-uploading files already stored on the server, sending only new local files with a `path`."}
{"text":"Q: How does the form’s validation schema enforce slot selection for new bookings? A: It adds a Yup `slots` array test when `isAddNew` is true, requiring at least one element with `isCheck===true`."}
{"text":"Q: How is the deposit price recalculated after slot changes? A: A `useEffect` watching `calculateDepositPrice` (which depends on `slots`) updates the `depositPrice` form field via `setValue`."}
{"text":"Q: How does the component disable form inputs when editing a canceled or declined booking? A: In the `bookingDetail` effect, it checks status codes and sets `isDisabledForm=true`, which `<FormDisabledProvider>` uses to disable all controls."}
{"text":"Q: What role does `reset(getInitialValuesForUpdate())` play when editing? A: It populates the form with the existing booking’s values, including nested fields, ensuring the payload matches current data if unchanged."}
{"text":"Q: How does `getInitialValuesForUpdate` handle nested fields for different booking types? A: It conditionally adds `unit`, `company`, or `email` fields based on `bookingDetail.bookingType`, matching the shape expected by form controls."}
{"text":"Q: How is `validateRecurringBooking` result integrated back into the UI? A: The success response populates `bookingRequestData`, triggers the confirmation modal, and displays valid/invalid slots before final save."}
{"text":"Q: How does the code ensure `onSave` is only called after form validation? A: The Save button’s `onPress` is `handleSubmit(onSave)`, which runs React Hook Form’s resolver before invoking `onSave`."}
{"text":"Q: How can you handle API timeouts or network errors in `onSave`? A: Wrap the `addBooking/updateBooking` call in try/catch and show an `Alert.alert('Error', error.message)` on failure."}
{"text":"Q: How would you extend error handling to retry failed saves? A: In the catch block, present the user with an option to retry by calling `onSave(formMethods.getValues())` again if they confirm."}
{"text":"Q: Why does the code use both `bookingDetail` and `formValues` when building the edit payload? A: To preserve any unchanged fields (dates, contact info) while applying only modified form values."}
{"text":"Q: How is form state reset after a successful save? A: Currently navigation.goBack unmounts the component; to reset in-place, call `reset(initialValues)` on success instead of navigating."}
{"text":"Q: How can you surface server-side validation errors to users? A: Catch errors from `addBooking/updateBooking`, parse `error.response.data`, and pass specific messages into `Alert.alert` or inline form errors via `setError`."}
{"text":"Q: How does the UI reflect that a booking is being saved? A: You could add an `isSaving` state, disable the Save button, and show a spinner in the button until the promise resolves."}
{"text":"Q: How does the payload handle custom booking properties like `purposeId` and `numberOfPerson`? A: These are spread from `formValues` into `payload`, ensuring optional fields are included if filled."}
{"text":"Q: What ensures consistency between the form’s `bookingType` array and the payload’s `bookingType` scalar? A: The code reads `const bookingType = watch('bookingType')[0]` then includes that in `payload.bookingType`."}
{"text":"Q: How would you validate `files` before uploading? A: Add a Yup test on `files` in the validation schema to check file size/type, preventing uploads of invalid files."}
{"text":"Q: What event triggers reloading the booking list elsewhere in the app? A: `DeviceEventEmitter.emit('UpdateListBooking')` notifies listeners (e.g., booking list screen) to refresh data."}
{"text":"Q: How can you unit-test the add/edit logic in `onSave`? A: Mock `addBooking` and `updateBooking`, provide known formValues, call `onSave`, and assert correct payload passed and navigation/emitter calls executed."}
{"text":"Q: How is the `navigation` prop used after saving? A: It calls `navigation.goBack()` to return to the previous screen, reflecting the updated booking list."}
{"text":"Q: How could you centralize payload construction to avoid duplication? A: Extract a `buildPayload(formValues, bookingDetail, isAddNew)` helper that returns a new or updated payload object."}
{"text":"Q: How does the component decide between “Add” and “Edit” mode at startup? A: It reads useRoute().name and sets isAddNew = (name==='addBooking'), isEdit = (name==='editBooking'). This controls which effects run, which UI elements display, and whether addBooking or updateBooking is called."}
{"text":"Q: Why is id = params?.id important, and how is it used? A: In edit mode, id tells the component which booking to fetch via getBookingDetail(id). Without it, there’s no context for populating the form with existing data."}
{"text":"Q: Which pieces of data must be loaded before rendering the form, and how is loading handled? A: amenityDetail (to know available slots, deposit rules), bookingSlots (initial slot availability), and reference files. A <LoaderContainer> wraps the form, showing <BookingLoading> until amenityDetail is truthy."}
{"text":"Q: How are default form values provided for a new booking? A: Via initialValues, including defaults for status (REQUESTED), payment (NOT_YET_DEPOSIT), bookingType ([occupier]), empty slots, files, etc."}
{"text":"Q: How does getInitialValuesForUpdate() shape the form for editing? A: It maps fields from bookingDetail into the same shape as the form’s defaultValues, including nested unit/company/email objects based on bookingType."}
{"text":"Q: Which UI sections are only shown in “Add” mode? A: <FormCalendarPicker> date selector, the slot picker (<FormSlotView>), and booking warning text (when outside the booking period)."}
{"text":"Q: Which UI elements are suppressed in “Edit” mode? A: Date picker, slot selector, and recurrence controls—because editing cannot change the reservation’s time slots or recurrence pattern."}
{"text":"Q: How does the component show the existing booking time in edit mode? A: It renders <InfoRow> components showing a clock icon with “HH:mm – HH:mm” and a calendar icon with the booking date."}
{"text":"Q: How are available time slots initially populated? A: On mount or date/amenity changes, getBookingTimeSlots() calls getAllTimeSlots({amenityId,fromDate,toDate}), and an effect sets formValues.slots = bookingSlots."}
{"text":"Q: When is the deposit price recalculated? A: In a useEffect that watches the calculateDepositPrice callback, which depends on slots. Thus, any slot change triggers recalculation."}
{"text":"Q: How is the correct deposit rule matched? A: It filters selected slots, extracts the first and last slot’s day and time, then finds a matching rule in amenityDetail.amenityTimeRules by numNextValidDate, startTime, and endTime."}
{"text":"Q: How does the “Recurring” feature integrate into the Add form? A: If amenityDetail.isAllowRecurring is true, <BookingRecurring> renders. Its onSubmitForm sets formValues.recurrence, toggling the recurring flow."}
{"text":"Q: How does onSave branch for recurring bookings? A: If formValues.recurrence exists, it calls await recurringBooking(formValues, payload) and returns early, deferring the actual API call until after confirmation."}
{"text":"Q: What does validateRecurringBooking do? A: It checks all requested slots for availability without creating bookings, returning validSlots and invalidSlots for user confirmation."}
{"text":"Q: What happens when the user confirms the recurring booking? A: handleConfirmBooking remaps validSlots to bookingData.bookingTimes, calls recurringBooking(bookingData), then navigates back and emits UpdateListBooking."}
{"text":"Q: How can the user remove invalid or unwanted slots? A: In <BookingRecurringConfirmation>, each valid slot row has a trash icon; tapping triggers handleRemoveSlot, which filters out that slot."}
{"text":"Q: How are default and new files handled in the payload? A: onSave filters formValues.files for items with a local path property, so only new uploads are sent; existing files remain untouched."}
{"text":"Q: How does the component disable form inputs for canceled/declined bookings? A: After fetching bookingDetail, it checks if statusCode is CANCELED or DECLINED and sets isDisabledForm=true, which <FormDisabledProvider> uses to disable all fields."}
{"text":"Q: How does the payload handle custom booking properties like `purposeId` and `numberOfPerson`? A: These are spread from formValues into payload, ensuring optional fields are included if filled."}
{"text":"Q: What ensures consistency between the form’s `bookingType` array and the payload’s `bookingType` scalar? A: The code reads const bookingType = watch('bookingType')[0] then includes that in payload.bookingType."}
{"text":"Q: How would you validate `files` before uploading? A: Add a Yup test on `files` in the validation schema to check file size/type, preventing uploads of invalid files."}
{"text":"Q: How can you unit-test the add/edit logic in `onSave`? A: Mock addBooking and updateBooking, provide known formValues, call onSave, and assert correct payload passed and navigation/emitter calls executed."}
{"text":"Q: What event triggers reloading the booking list elsewhere in the app? A: DeviceEventEmitter.emit('UpdateListBooking') notifies listeners (e.g., booking list screen) to refresh data."}
{"text":"Q: How is the navigation prop used after saving? A: It calls navigation.goBack() to return to the previous screen, reflecting the updated booking list."}
{"text":"Q: What is the purpose of the `BookingRecurringConfirmation` component? A: To display a modal summarizing the results of a recurring booking validation, showing valid and invalid slots, metadata (requestedBy, amenityName, createdDate, status), and allowing the user to remove slots or confirm the booking."}
{"text":"Q: How does `buildConfirmationObj` transform `bookingRequestData` into `localData`? A: It deep-clones `bookingRequestData`, maps each `bookingTimes` slot to include an `isAvailable` boolean and a formatted `timeRange`, then separates them into `validSlots` and `invalidSlots`, and copies over metadata fields (`requestedBy`, `amenityName`, `createdDate`, `status`)."}
{"text":"Q: Why is `cloneDeep` used in `buildConfirmationObj` and `handleConfirmBooking`? A: To avoid mutating the original `bookingRequestData` object, ensuring immutability and state isolation when filtering and remapping slots."}
{"text":"Q: How is the `isAvailable` flag determined for each slot? A: By checking `slot.isAvailable !== false` (treating undefined or true as available) and storing the result in the mapped slot object."}
{"text":"Q: What format does `getTimeRange` produce for each slot? A: It returns a string like `YYYY/MM/DD HH:mm - HH:mm`, using `formatDate(slot.startDate)` for the date and `moment.utcOffset(tz).format('HH:mm')` for start and end times, where `tz` is derived from the ISO string offset."}
{"text":"Q: How does `getTimeZone` extract the timezone offset from a date string? A: If the input is a string, it takes characters 19–25 of the string (`YYYY-MM-DDTHH:mm:ss+07:00`) to get `+07:00`; otherwise defaults to `+07:00`."}
{"text":"Q: Why wrap `BookingRecurringConfirmation` with `withModal`? A: To inject `visible` and `onClosePress` props and automatically render the component inside a `<Modal>` with the specified modal key, standardizing show/hide behavior."}
{"text":"Q: How does the component initialize its state when `bookingRequestData` changes? A: A `useEffect` hook watches `bookingRequestData` and calls `setLocalData(buildConfirmationObj(bookingRequestData))`, ensuring the UI always reflects the latest data."}
{"text":"Q: What UI element shows invalid slots to the user? A: A red `<Text>` above the metadata, rendering `CANNOT_BOOKING_ON: ` followed by the joined `invalidSlots.timeRange` values."}
{"text":"Q: How are valid slots rendered in the list? A: Via a `<SlotList>` FlatList with `data={localData.validSlots}`, `keyExtractor={(item,i)=>String(i)}`, and `renderItem={renderSlot}` showing each slot’s index and timeRange."}
{"text":"Q: Describe the JSX structure of each slot row. A: `<SlotRow>` with a `<Row>` showing `#${index+1}` and the slot’s `timeRange`, followed by a `<RemoveBtn>` containing a trash icon that calls `handleRemoveSlot(index)`."}
{"text":"Q: What confirmation does `handleRemoveSlot` present to the user? A: An `Alert.alert` with title `REMOVE_BOOKING_CONFIRMATION`, Cancel and Remove buttons; the Remove button’s `onPress` filters out the slot at the given index from `localData.validSlots`."}
{"text":"Q: How does removing a slot affect the confirmation flow? A: It updates `localData.validSlots`; if the user later presses Confirm, only the remaining slots are sent in the final booking request."}
{"text":"Q: What happens when the user presses the Confirm button? A: `handleConfirmBooking` deep-clones `bookingRequestData`, replaces `bookingTimes` with the filtered `validSlots`, deletes `validSlots`/`invalidSlots`, calls `recurringBooking(bookingData)`, then `onClosePress()`, navigates back and emits `UpdateListBooking` if successful."}
{"text":"Q: Why delete `validSlots` and `invalidSlots` before calling the API? A: Because the API expects only `bookingTimes` array; extra keys would be ignored or cause payload validation errors."}
{"text":"Q: How does the component navigate away after confirmation? A: After `recurringBooking` resolves truthily, it calls `NavigationService.goBack()` to exit the modal/screen and `DeviceEventEmitter.emit('UpdateListBooking')` to refresh the booking list."}
{"text":"Q: How are the Cancel and Confirm buttons rendered conditionally? A: In `<ButtonsRow>`, Cancel always appears; Confirm is shown only if `localData.validSlots.length > 0`, preventing confirmation with no slots."}
{"text":"Q: What local state shape is stored in `localData`? A: An object with arrays `validSlots`, `invalidSlots`, and strings `requestedBy`, `amenityName`, `createdDate`, `status`."}
{"text":"Q: How are dates formatted for `COMMON_CREATED_DATE`? A: `new Date(localData.createdDate).toLocaleString()` is used in `<LabelValue>` to display the human-readable creation timestamp."}
{"text":"Q: What is the role of the `LabelValue` subcomponent? A: To render bold label text (`I18n.t(labelKey)`) followed by the corresponding `value`, used for metadata fields."}
{"text":"Q: Why map over `bookingTimes || []` instead of assuming it’s always defined? A: To handle cases where `bookingTimes` is undefined or null, preventing runtime errors by defaulting to an empty array."}
{"text":"Q: How could you handle a failure in `recurringBooking` inside `handleConfirmBooking`? A: Wrap the API call in try/catch, show `Alert.alert('ERROR', error.message)` on catch, and avoid closing the modal until success."}
{"text":"Q: What Lodash functions are used and why? A: `cloneDeep` for immutability, `map` for transforming arrays, `filter` for separating valid/invalid slots, and `size` to count `invalidSlots` before rendering the warning."}
{"text":"Q: How is `size(localData.invalidSlots) > 0` used? A: To conditionally render the invalid-slots warning text only when there is at least one invalid slot."}
{"text":"Q: How would you add a “Select All” button for valid slots? A: Include a `<Button title='Select All' onPress={() => setLocalData({...localData, validSlots:buildConfirmationObj(bookingRequestData).validSlots})}/>` above the `<SlotList>`."}
{"text":"Q: How can you provide an “Undo” for removed slots? A: Maintain a separate `removedSlots` array in state, push removed slots there, and add an “Undo” button that restores the last removed slot to `validSlots`."}
{"text":"Q: What accessibility props should be added to the modal buttons? A: `accessibilityLabel` (e.g., 'Confirm Recurring Booking'), `accessibilityRole='button'`, and `accessible={true}` for better screen reader support."}
{"text":"Q: How would you unit-test `buildConfirmationObj`? A: Provide a mock `bookingRequestData` with mixed `bookingTimes` having `isAvailable` flags, call `buildConfirmationObj`, and assert correct `validSlots`/`invalidSlots` arrays and metadata outputs."}
{"text":"Q: Why does `getTimeRange` use `utcOffset(tz)` on both start and end times? A: To interpret the ISO timestamp correctly in the intended timezone, ensuring displayed times match the server’s offset."}
{"text":"Q: How could you memoize `buildConfirmationObj` to optimize re-renders? A: Wrap it in `useCallback` or use `useMemo(() => buildConfirmationObj(data), [data])` to avoid rebuilding arrays unnecessarily."}
{"text":"Q: How do you ensure the modal’s list scrolls when there are many slots? A: The `SlotList` FlatList has a `max-height:200px` style and is scrollable by default, so overflow scrolls inside the modal container."}
{"text":"Q: How can you highlight invalid slots visually? A: Change the warning text color or add an icon beside each invalid `timeRange` in the warning message to draw attention."}
{"text":"Q: What could go wrong if `bookingRequestData` changes while the modal is open? A: The `useEffect` will overwrite `localData`, potentially losing user-removed slots; consider ignoring updates if `localData` has been modified."}
{"text":"Q: How does the component prevent memory leaks on unmount? A: There are no subscriptions created in `BookingRecurringConfirmation`; the `useEffect` setter is safe and no cleanup is needed."}
{"text":"Q: How would you add a “Review Recurrence Rules” section above the slot list? A: Insert a `<Text>` summarizing `bookingRequestData.frequency`, `every`, and `onType` fields before the warning, using `LabelValue` or custom formatting."}
{"text":"Q: How can you ensure `handleConfirmBooking` only fires once? A: Use an `isSubmitting` ref or state to ignore subsequent presses until the first promise resolves, preventing duplicate API calls."}
{"text":"Q: Why delete both `validSlots` and `invalidSlots` before sending the final request? A: To avoid sending extraneous data to the API and ensure the payload matches the expected schema (only `bookingTimes`)."}
{"text":"Q: How can you add loading indicators to the Confirm button? A: Pass a `loading={isSubmitting}` prop to `<Button>` (if supported) or conditionally render an `<ActivityIndicator>` alongside the button text."}
{"text":"Q: How would you internationalize the slot time format? A: Replace `formatDate` and `moment.format('HH:mm')` with `moment.locale(I18n.locale).format('L LT')` to use locale-specific date/time patterns."}
{"text":"Q: How is `onClosePress` implemented by `withModal`? A: `withModal` injects a function that hides the modal by toggling a `visible` prop in the parent HOC’s state."}
{"text":"Q: How could you refactor `BookingRecurringConfirmation` to accept a custom slot renderer? A: Add a `renderSlotItem` prop and replace `renderItem={renderSlot}` with `renderItem={renderSlotItem || renderSlot}` to allow injection."}
{"text":"Q: What best practice does splitting out `LabelValue` illustrate? A: DRY UI code: reuse a small component for consistent label-value pairs, reducing duplication and ensuring uniform styling."}
{"text":"Q: How would you extend the component to show reasons for invalid slots? A: Have the API return `invalidSlots` objects with a `reason` field, then render each as `item.timeRange + ' (' + item.reason + ')'`."}
{"text":"Q: How do you test the Alert in `handleRemoveSlot`? A: Use Jest mocking of `Alert.alert` to capture the callback array, simulate pressing the remove button by calling the `onPress` function, and assert `localData.validSlots` updates."}
{"text":"Q: How does the component handle confirmation if all slots become invalid? A: Since `localData.validSlots.length === 0`, the Confirm button is hidden, forcing the user to cancel or adjust their selection."}
{"text":"Q: What cleanup might be needed if `recurringBooking` is canceled mid-request? A: Cancel the API request (e.g., via AbortController) and reset any `isSubmitting` flags in a finally block to restore UI interactivity."}
{"text":"Q: How can you integrate analytics for user actions in this modal? A: Call an event tracking function inside `handleRemoveSlot` and `handleConfirmBooking`, logging slot counts and user decisions."}
{"text":"Q: How would you add keyboard navigation for the slot list? A: Use React Native’s `onFocus` and `onKeyPress` handlers on each `<RemoveBtn>`, managing focus order and activating removal with the Delete key."}
{"text":"Q: How does the modal’s styling ensure readability on small screens? A: The `Container` has padding and the `SlotList` a max-height, scrolling internally, so content doesn’t overflow off-screen."}
{"text":"Q: How could you extract duplicate metadata logic into a hook? A: Create `useConfirmationData(bookingRequestData)` returning `{localData, handleRemoveSlot, handleConfirmBooking}` to share with other confirmation screens."}
{"text":"Q: What are the key differences between single and recurring booking confirmation flows? A: Single bookings skip this modal and call `addBooking` directly; recurring bookings require validation, user slot pruning, and two-step API calls."}
{"text":"Q: What is the role of the `Booking` component? A: It displays a paginated list of bookings, provides filtering and search capabilities, and allows navigating to add or edit booking screens."}
{"text":"Q: How does the component fetch initial filter data? A: In the first `useEffect([])`, it calls `getBookingStatus()`, `getPaymentStatus()`, and `getAmenities()` from the `useBooking` hook to populate dropdown options."}
{"text":"Q: What is `defaultFilter` and how is it structured? A: An object with keys `dateRange`, `statusIds`, `isIncludeExpired`, `paymentStatusIds`, `amenityIds`, and `multipleOptions`, providing the baseline filter values on mount."}
{"text":"Q: How is `dateRange` initialized by default? A: Using `getDefaultDateRange()`, which returns start and end dates for the current default period (e.g., current week or month)."}
{"text":"Q: How are multiple-options filters handled? A: `multipleOptions` is an array containing flags `onlyActiveAmenity` and `isIncludeExpired`, allowing toggling those behaviors in the API call."}
{"text":"Q: What is the `filters` object and how does it drive the `<Filter>` UI? A: It maps filter keys (e.g., `statusIds`, `paymentStatusIds`, `amenityIds`, `multipleOptions`) to configuration objects with titles, options, and metadata for the Filter component to render appropriate controls."}
{"text":"Q: How does the `amenityIds` filter differ from the others? A: It uses `type: FilterTypes.DROPDOWN`, passes `amenitiesFilter` options, and includes `dropdownProps` (e.g., `showSearchBar: true`) to enable searching within the dropdown."}
{"text":"Q: What state variables manage filter behavior? A: `bookingFilter` holds the default filter and is not used further; `selectedFilter` holds the current filter and drives API calls; both initialized to `defaultFilter`."}
{"text":"Q: Why is `setSelectedFilter = setBookingFilter` in the `useState` signature? A: It appears to be a typo; normally `const [selectedFilter, setSelectedFilter] = useState(bookingFilter)` is used to allow updating the filter."}
{"text":"Q: How is text search implemented? A: A `textSearch` state drives the keyword passed to `getList`; updating `textSearch` triggers a new fetch via the `useEffect([textSearch, selectedFilter])` hook."}
{"text":"Q: How does the component react to filter or search changes? A: In `useEffect([textSearch, selectedFilter])`, it calls `getList(1)` to reload the first page whenever either changes."}
{"text":"Q: How does the component subscribe to external list updates? A: In `useEffect([])`, it adds a `DeviceEventEmitter` listener for `'UpdateListBooking'` that calls `getList(1)` when triggered, and removes the listener on unmount."}
{"text":"Q: Why remove the subscriber on cleanup? A: To avoid memory leaks and duplicate event handling when the component unmounts or remounts."}
{"text":"Q: What parameters does `getList` accept and default to? A: `(page = 1, keyword = textSearch, filter = selectedFilter)`; page resets to 1 for new searches/filters, keyword and filter come from state."}
{"text":"Q: How are date filters converted before API calls? A: `fromDate` and `toDate` from `filter.dateRange` are converted via `convertDate.stringToISOString` if they exist, matching the backend format."}
{"text":"Q: How are boolean flags derived in `getList`? A: `isIncludeExpired` and `onlyActiveAmenity` are derived by checking if their respective values exist in `filter.multipleOptions`, or set to `null` if not."}
{"text":"Q: What sorting order is applied by default? A: `'createdAt desc'` is added to `filterParams` to sort bookings by creation date descending."}
{"text":"Q: How does the component trigger the API call? A: It calls `filterBookings({ page, pageSize: PAGE_SIZE, keyword, ...filterParams })` provided by `useBooking`."}
{"text":"Q: What is `PAGE_SIZE` and why is it used? A: A constant defining how many items to fetch per page, ensuring consistent pagination across screens."}
{"text":"Q: How is pagination handled in the UI? A: Via the `AppList` component receiving `isRefresh`, `isLoadMore`, `currentPage`, `totalPage`, and `loadData` props for infinite scroll or load-more behavior."}
{"text":"Q: What is the structure of `list` from `useBooking`? A: An object containing `data` (array of bookings), `isRefresh`, `isLoadMore`, `currentPage`, and `totalPage`."}
{"text":"Q: How is the “Add Booking” action wired? A: The BaseLayout’s `onBtAddPress` prop is set to `onBtAddPress`, which sets `visibleSelectAmenity = true`, opening the amenity selection modal."}
{"text":"Q: How does `SelectAmenityModal` integrate? A: Rendered at the bottom of the JSX, controlled by `visibleSelectAmenity`, with `onSelect` calling `getAmenityDetail` and navigating to 'addBooking' screen."}
{"text":"Q: What steps occur when an amenity is selected? A: `onAmenitySelect` sets the modal invisible, calls `getAmenityDetail(amenity.amenityId)` to prefetch details, then `NavigationService.navigate('addBooking')` to open the add screen."}
{"text":"Q: Why prefetch `getAmenityDetail` before navigation? A: To speed up the AddBooking screen load by having amenity data ready in the context when the screen mounts."}
{"text":"Q: How does the component navigate to edit mode? A: In `renderItem`, the `ItemBooking` receives an `onPress={() => gotoDetail(item)}`, and `gotoDetail` calls `NavigationService.navigate('editBooking', { id: item.reservationId })`."}
{"text":"Q: What is the shape of each `item` in the list? A: A booking object containing at minimum `reservationId` (for detail navigation) and other fields for display by `ItemBooking`."}
{"text":"Q: How is `renderItem` implemented and why wrap in a function? A: As `const renderItem = (item) => <ItemBooking item={item} onPress={...} />` then passed via `renderItem={({ item }) => renderItem(item)}` to keep code clean."}
{"text":"Q: How does the component ensure unique keys? A: By using `keyExtractor: (item) => ${item.id}` where `item.id` is assumed to be unique for each booking."}
{"text":"Q: How can the user trigger a search manually? A: The `<Filter>` component’s `onSearch={onTextSearchChange}` prop updates `textSearch` state when the search input changes."}
{"text":"Q: How are filter changes applied? A: The `<Filter>` component’s `onCompleted={onApplyFilter}` prop calls `setSelectedFilter(value)`, triggering the effect to reload `getList(1)`."}
{"text":"Q: How does the Filter component know current selections? A: It receives `selectedFilter={selectedFilter}` and `defaultFilter={defaultFilter}` to manage its internal UI state."}
{"text":"Q: What placeholder does the search input show? A: The string `BOOKING_SEARCH_PLACEHOLDER` which is internationalized by I18n in the Filter component."}
{"text":"Q: Why use `useMemo` anywhere in this component? A: None in this snippet; one could memoize `filters` or `getList` definition to avoid unnecessary re-renders, but usage is minimal."}
{"text":"Q: How would you debounce the search input? A: Wrap `onTextSearchChange` in a debounced function (e.g., using `lodash.debounce`) so `getList` isn’t called on every keystroke immediately."}
{"text":"Q: How can you display a default empty state icon? A: The `AppList` receives `iconName: icons.jobRequestEmpty`, showing it when `data.length===0`."}
{"text":"Q: How is pull-to-refresh handled? A: `AppList` uses its `isRefresh` and `loadData` props to trigger `getList(1)` when the user pulls down on the list."}
{"text":"Q: How is load-more on scroll handled? A: `AppList` also uses `isLoadMore`, `currentPage`, `totalPage`, and calls `loadData({ page: currentPage+1 })` when the user scrolls near the bottom."}
{"text":"Q: How can you show a loading spinner during initial load? A: `AppList` or `BaseLayout` could show an activity indicator; in this component, no explicit loader is shown, assuming `AppList` handles its own loading UI."}
{"text":"Q: What event should be emitted after adding or editing a booking? A: `DeviceEventEmitter.emit('UpdateListBooking')` should be called by the Add/Edit screens to refresh this list via the subscriber."}
{"text":"Q: How is the list refreshed after returning from Add/Edit? A: The `DeviceEventEmitter` listener triggers `getList(1)` when the event fires, ensuring the latest data appears."}
{"text":"Q: What potential memory leaks exist and how to fix them? A: Failing to remove the DeviceEventEmitter listener could leak; this component correctly calls `subscriber.remove()` in the cleanup function."}
{"text":"Q: How would you add a “Refresh” button in the header? A: Pass a `rightButtons` prop to `BaseLayout` with a refresh icon that calls `getList(1)` when pressed."}
{"text":"Q: How can you persist filter state across navigations? A: Store `selectedFilter` in context or URL params, and initialize state from that when the component mounts."}
{"text":"Q: How would you add a “Clear Filters” button? A: Provide a button that calls `setSelectedFilter(defaultFilter)` and resets `textSearch` to `''`."}
{"text":"Q: How could you disable the Add button conditionally? A: Use `showAddButton={!someCondition}` or replace `onBtAddPress` with a no-op if the user lacks permissions."}
{"text":"Q: What should you be careful about when calling `getList` inside effects? A: Always include dependencies `[textSearch, selectedFilter]` so stale closures don’t use old filter or search values."}
{"text":"Q: How can you add analytics for filter usage? A: In `onApplyFilter`, call an analytics tracking function with the new filter values to capture user behavior."}
{"text":"Q: How would you handle API errors from `filterBookings`? A: Add error handling in the hook or pass an `onError` callback to show an `Alert.alert` on failure."}
{"text":"Q: How can you ensure keyboard dismissal after search? A: In `onTextSearchChange`, call `Keyboard.dismiss()` after setting `textSearch` to hide the keyboard on mobile."}
{"text":"Q: How to make `getList` stable across renders? A: Wrap it in `useCallback` with dependencies `[textSearch, selectedFilter]` so it doesn’t get redefined unnecessarily."}
{"text":"Q: What accessibility labels should be added? A: Add `accessibilityLabel` to the Add button, search input, filter controls, and each `ItemBooking` for better screen reader support."}
{"text":"Q: How to handle deep link navigation to a filter state? A: Parse query params from the deep link, set `selectedFilter` and `textSearch` accordingly in an initial `useEffect`, then call `getList(1)`."}
{"text":"Q: How can you optimize performance for large filter option lists? A: Use virtualization (e.g., FlatList) within the Filter dropdowns, and memoize option arrays with `useMemo`."}
{"text":"Q: How would you implement server-side search debounce? A: In the hook `filterBookings`, debounce calls by keyword or implement caching to throttle server requests."}
{"text":"Q: What considerations exist for offline handling? A: Cache the last fetched `list` and `amenityList` in local storage, display cached data when offline, and queue filter or search updates to retry when back online."}
{"text":"Q: How to unit-test the Booking component? A: Mock `useBooking` hook to provide fake data and spies on `filterBookings`, render the component, simulate filter changes and search input, and assert that `filterBookings` was called with correct args."}
{"text":"Q: How do you extend the component to show booking counts? A: Use `useMemo` to calculate `data.length` and display a `<Text>` like \"Showing {data.length} of {totalPage*PAGE_SIZE}\" above the list."}
{"text":"Q: How would you handle localization of date filters? A: Pass localized date formats to `getDefaultDateRange()` and display current range in the UI via I18n and `formatDate`."}
{"text":"Q: How can you integrate user permissions for filtering? A: Fetch user roles from context, and conditionally include/exclude certain `filters` entries (e.g., hide `paymentStatusIds` if not authorized)."}
{"text":"Q: What refactoring could reduce complexity in `getList`? A: Extract filter param building into a helper like `buildBookingFilterParams(selectedFilter, textSearch, page)` to simplify the component."}
{"text":"Q: How do you ensure filter and search state reset on unmount? A: In a cleanup effect `useEffect(() => { return () => { setTextSearch(''); setSelectedFilter(defaultFilter); } }, [])` to clear state if needed."}
{"text":"Q: How would you show a “No network” banner? A: Use NetInfo subscription to detect connectivity, and render a `<Banner>` above the list when offline."}
{"text":"Q: How can you debounce filter application? A: Wrap `setSelectedFilter` in a debounced function so rapid filter changes don’t call `getList` too frequently."}
{"text":"Q: How to implement a date range picker for `dateRange` instead of defaults? A: Replace `dateRange` filter UI with a `<DateRangePicker>` component, mapping its start and end into `selectedFilter.dateRange`."}
{"text":"Q: How to add inline loading indicators per card? A: Pass `isLoading` prop to `ItemBooking` and show a spinner overlay on each item during updates."}
{"text":"Q: How to handle focus when the amenity modal opens? A: Use React Native’s `autoFocus` prop on the modal’s search input and call `setVisibleSelectAmenity(true)` with a slight delay."}
{"text":"Q: How to add a “Back to top” button when scrolled far down? A: Track scroll position in `AppList` via `onScroll`, and conditionally render a floating button that calls `scrollToOffset({y:0})` on the FlatList ref."}
{"text":"Q: How would you support filtering by creator or user? A: Add a new filter key `createdByIds` with a multi-select dropdown pulling from a users list via `getUsers` hook, then include in `filterParams`."}
{"text":"Q: How can you theme filter and list components? A: Pass theme props (colors, fonts) into `<Filter>` and `<AppList>` or use styled-components’ ThemeProvider for consistent styling."}
{"text":"Q: What is the importance of passing `keyword` to `filterBookings`? A: It enables server-side searching by booking name/ID, ensuring the backend filters results rather than client-side post-fetch filtering."}
{"text":"Q: How can you add a “Clear Search” icon? A: In the `<Filter>` component’s search input, render an `X` icon when `textSearch` is non-empty, with `onPress={() => setTextSearch('')}` to clear."}
{"text":"Q: How would you support bookmarking favorite bookings? A: Add a “star” toggle in `ItemBooking` that updates a favorites list in context or local storage, and add a filter toggle `onlyFavorites`.   "}
{"text":"Q: How do you handle large data volumes? A: Use pagination (`PAGE_SIZE`), server-side filters, and avoid fetching all data at once; optionally implement infinite scroll thresholds."}
{"text":"Q: How would you implement optimistic UI for add/edit? A: Immediately insert the new/updated booking into `data` array via context update before the API responds, then reconcile on success/failure."}
{"text":"Q: How can you instrument performance logging? A: Measure start/end timestamps around `filterBookings` calls and list renders, log via `console.time` or an analytics SDK."}
{"text":"Q: What considerations exist when adding new filter types? A: Ensure the `filters` object provides the correct `type`, `options`, `valKey`, and UI props; update `defaultFilter` and `getList` to include the new key."}
{"text":"Q: How can you centralize filter logic for reuse? A: Create a custom hook `useBookingFilters` that returns `filters`, `defaultFilter`, `selectedFilter`, `setSelectedFilter`, and `buildFilterParams`."}
{"text":"Q: How does the component handle deep linking to a specific booking? A: On navigation params (e.g., `navigate('Booking', { highlightId: xxx })`), check `route.params.highlightId` and scroll to that booking in the list via FlatList’s `scrollToIndex`."}
{"text":"Q: How to add a “Group by amenity” view? A: Transform `data` into grouped sections by `amenityName` and pass to a `<SectionList>` instead of `<FlatList>`."}
{"text":"Q: What best practice does splitting this component illustrate? A: Separation of concerns: data fetching in `useBooking`, list UI in `AppList`, filter controls in `Filter`, and modal in `SelectAmenityModal`, leading to maintainable and testable code."}
{"text":"Q: What is the purpose of the `initialValues` object? A: It defines the default form values for a new booking, including null amenityId, current date for startEndDate, default status/paymentStatus codes, empty arrays/strings for purposeId, numberOfPerson, remark, bookingType set to occupier, and empty files/depositPrice/slots."}
{"text":"Q: Why include both `startEndDate` and `endDate` in initialValues? A: `startEndDate` is used for the date picker in add mode; `endDate` exists to match the Angular shape but is unused for new bookings (the actual end date comes from slots)."}
{"text":"Q: How does `validationSchema` enforce conditional requirements for `unit`, `company`, and `email`? A: It uses Yup’s `.when('bookingType')` to require `unit` when bookingType is occupier, `company` when company, and `email` (with valid format) when outsider."}
{"text":"Q: What additional test is added to `slots` when `isAddNew` is true? A: A Yup `.test('at-least-one-selected')` ensures at least one slot has `isCheck===true`, enforcing slot selection for new bookings."}
{"text":"Q: How is the Yup schema memoized? A: Wrapped in `useMemo` with `[isAddNew]` dependency so the schema recomputes only when add/edit mode changes."}
{"text":"Q: How does `useCompatibleForm` integrate React Hook Form and Yup? A: It calls `useForm` with `defaultValues` and a resolver from `useYupValidationResolver(validationSchema)`, wiring validation and defaults together."}
{"text":"Q: How does `watch('bookingType')[0]` extract the selected booking type? A: `bookingType` is an array; watching it returns e.g. `[1]`, so `[0]` yields the numeric value for conditional rendering and payload."}
{"text":"Q: Why guard `const slots = watch('slots') || [];`? A: Ensures `slots` is always an array, avoiding undefined when the form is resetting or before initialValues is applied."}
{"text":"Q: How is `startDate` chosen differently for add vs edit? A: If `isAddNew`, `startDate = startEndDate`; otherwise it’s taken from `bookingDetail.startDate` loaded from API."}
{"text":"Q: What triggers the effect `useEffect([id])`? A: Whenever the route params id changes, which happens when navigating to edit a different booking, it calls `getBookingDetail(id)` to fetch data."}
{"text":"Q: Why is `resetBookingDetail` commented out? A: Possibly to avoid clearing bookingDetail on unmount before context consumers complete; might be toggled based on broader app reset logic."}
{"text":"Q: How are `referenceFiles` used in edit mode? A: An effect on `[_.size(referenceFiles)]` calls `setValue('files', referenceFiles)` to prefill document picker with existing attachments."}
{"text":"Q: What is the role of `bookingRuleFiles`? A: Files containing policy/rule documents for the amenity; an effect on `[bookingRuleFiles, amenityDetail]` sets them into the form for rules display."}
{"text":"Q: How are simpleCompanies fetched and used? A: On mount, `getSimpleCompanies({page:1})` loads company options; used by `FormLazyDropdown` when bookingType is company."}
{"text":"Q: Why check `_.size(amenityList) === 0` before calling `getAmenities()`? A: To avoid refetching amenity list if it’s already loaded, improving performance."}
{"text":"Q: How does the effect on `[bookingSlots]` work? A: When `bookingSlots` updates from API, if `isAddNew`, it sets the form field `slots` to that new array so the slot picker shows available times."}
{"text":"Q: Why is `getInitialValuesForUpdate()` separated into its own function? A: Encapsulates mapping of bookingDetail into form shape, handling nested objects per bookingType, keeping effects cleaner."}
{"text":"Q: How does `reset(getInitialValuesForUpdate())` work? A: Completely replaces form state with values returned from that function, resetting inputs, dropdowns, and slot arrays for edit mode."}
{"text":"Q: What determines `isDisabledForm`? A: After loading bookingDetail, if statusCode is CANCELED or DECLINED, setIsDisabledForm(true) disables all form inputs via FormDisabledProvider."}
{"text":"Q: How does FormDisabledProvider disable nested form controls? A: It likely provides a form context flag that each `<FormInput>`, `<FormDropdown>`, etc. checks to render in disabled/editable mode."}
{"text":"Q: Why fetch `bookingRuleFiles` only in add mode? A: To show amenity policy before booking; in edit mode the rules are static or not needed since booking is existing."}
{"text":"Q: How is `getBookingTimeSlots` triggered? A: In a useEffect with dependencies `[startDate, endDate, amenityDetail]`, whenever the selected date or amenity changes."}
{"text":"Q: Why format dates as `YYYY/MM/DD`? A: Matches backend API expectations for fromDate/toDate parameters in getAllTimeSlots."}
{"text":"Q: How is `calculateDepositPrice` memoized? A: Wrapped in `useCallback` depending only on `slots`, so the reference changes only when slots array changes."}
{"text":"Q: Why does `calculateDepositPrice` check `!amenityDetail` first? A: Prevents errors if rules aren’t loaded yet; deposit logic runs only when amenity rules exist."}
{"text":"Q: How are `checkedSlots` determined? A: By filtering `slots.filter(item => item.isCheck)`, capturing only selected time intervals."}
{"text":"Q: How is `weekday` used for deposit logic? A: Array mapping numeric day to string, so `weekday[moment(startDateSlot).day()]` yields e.g. 'WEDNESDAY' to match rule.numNextValidDate."}
{"text":"Q: Why format times with `'HH:mm:ss'`? A: amenityTimeRules store times in that format, enabling exact match comparisons."}
{"text":"Q: What happens if multiple rules match? A: `.find` returns the first; business logic likely ensures rules are unique per day/time slot combination."}
{"text":"Q: How does the effect `useEffect([calculateDepositPrice])` trigger? A: When the callback reference changes (i.e. when slots change), it invokes deposit recalculation."}
{"text":"Q: How does `recurringBooking` sanitize `bookingParams`? A: Spreads in values, then deletes startDate/endDate to avoid sending conflicting fields when using bookingTimes array."}
{"text":"Q: How are `bookingTimes` validated? A: If empty, shows an alert NO_RECURRING_SLOT_AVAILABLE and returns without proceeding."}
{"text":"Q: How does `validateRecurringBooking` integrate with statusList? A: Call returns `res.status` code; matchedStatus found via statusList.find to get human-readable name for confirmation modal."}
{"text":"Q: What fields are set in `bookingRequestData`? A: API response spread (`res`), plus amenityName, requestedBy, createdDate, status (name), validSlots (bookingTimes), invalidSlots (from res)."}
{"text":"Q: Why call `setConfirmationVisible(true)`? A: To show the BookingConfirmation modal with the prepared data for user review."}
{"text":"Q: How does `handleConfirm` differ from final confirmation? A: `handleConfirm` simply calls `onSave` again to persist after user confirms in the modal, then closes the modal."}
{"text":"Q: Why use `formMethods.getValues()` in `handleConfirm`? A: To get current form state (including any unchanged fields) when re-invoking save logic after confirmation."}
{"text":"Q: How are `uploadFiles` determined? A: Filtering `files.filter(item => item.path)` picks only new local files to upload; existing server files lack a `path` and are skipped."}
{"text":"Q: Why compute `slotStartTime`/`slotEndTime` only for add mode? A: Edit mode uses existing bookingDetail times; new bookings derive times from slot selection."}
{"text":"Q: How does the payload map contact fields for occupier? A: Reads from `formValues.unit` and contact fields set by FormSuggestionPicker, ensuring userId, name, email, phone are included."}
{"text":"Q: How does `BookingRecurring` component communicate back to parent? A: It calls `onSubmitForm(rec)` with recurrence rules, and `onRemove()` to clear recurrence when user toggles off."}
{"text":"Q: What logic sets the paymentStatus default for new bookings? A: In `[amenityDetail]` effect, if `amenityDetail.isUseDeposited`, it sets `paymentStatus` form field to 'NotYetDeposit'."}
{"text":"Q: How is `bookingWarningMessage` calculated and displayed? A: Not in this file, but similar pattern: useMemo compares now with period.from/to via getTimePeriod, showing warning via BookingWarningText styled in warning color."}
{"text":"Q: Why wrap the entire form in `<LoaderContainer>`? A: To show a loading spinner until amenityDetail loads, preventing incomplete UI render and avoiding form interactions before data is ready."}
{"text":"Q: How does selecting a new amenity work in add mode? A: Tapping AmenityButton opens SelectAmenityModal; on select, `setValue('amenityId')`, calls `getAmenityDetail`, and closes modal, triggering related effects."}
{"text":"Q: How is `displayStatus` list built? A: useMemo filters out canceled/declined status codes when `isAddNew` is true, ensuring user cannot pick invalid statuses for new bookings."}
{"text":"Q: Why use `showValue={false}` on status and payment dropdowns? A: Likely to display localized labels via I18n keys rather than raw code strings, enabling custom rendering inside dropdown."}
{"text":"Q: How is the Save button disabled? A: `disabled={isDisabledForm}` from state; if form disabled, Save is unclickable and grayed out by BaseLayout button props."}
{"text":"Q: How are `common_save` and other labels localized? A: Through `I18n.t('COMMON_SAVE')` and similar keys, ensuring multi-language support."}
{"text":"Q: What is the impact of missing dependency arrays in effects? A: Potential stale props or infinite loops; code correctly lists dependencies for each effect to ensure accurate updates."}
{"text":"Q: How does the component avoid race conditions between slot fetch and amenityDetail change? A: Effects have amenityDetail in dependencies so slot fetch runs only when amenityDetail is loaded/changed, avoiding precondition errors."}
{"text":"Q: How are errors communicated to the user? A: Via `Alert.alert` calls with localized error messages, e.g., `Alert.alert(I18n.t('ERROR'), error.message)`."}
{"text":"Q: What is the purpose of `FloatingConversation`? A: Renders a chat widget in edit mode for ongoing conversation about that booking, passing moduleId and guid for message context."}
{"text":"Q: Why conditionally render `FloatingConversation` only when `!isAddNew`? A: Chat is only relevant for existing bookings with a GUID; new bookings have no chat history yet."}
{"text":"Q: How are policy rules displayed? A: `<BookingPolicyRules>` component inside a Container, given `amenityDetail` and `bookingRuleFiles` to render rules and documents."}
{"text":"Q: How is the overall layout structured? A: BaseLayout wraps header, form scroll area, and bottom Save button; AwareScrollView handles keyboard avoidance; Containers group fields visually."}
{"text":"Q: Why use styled-components for `Container` and `TimeWrapper`? A: Encapsulates styling (padding, margins) in JS, promoting reusable layout primitives consistent with theme."}
{"text":"Q: How does `InfoRow` enhance code reuse? A: Renders icon + text row for time/date display, avoiding duplication of Row + Ionicon + Text across date/time UI."}
{"text":"Q: Why import both `useEffect` and `useMemo`/`useCallback`? A: `useEffect` handles side-effects (data fetch, form resets); `useMemo`/`useCallback` optimize expensive calculations and stable references."}
{"text":"Q: How could you improve performance in this component? A: Memoize expensive subcomponents, split into smaller child components, debounce heavy effects, and avoid unnecessary resets via precise dependencies."}
{"text":"Q: What testing strategies apply here? A: Unit-test mapping functions (`getInitialValuesForUpdate`, `calculateDepositPrice`, `buildConfirmationObj`), integration test form flows with React Testing Library, and E2E for add/edit screens."}
{"text":"Q: How would you refactor to reduce file size? A: Extract large sections (recurrence flow, deposit logic) into custom hooks (e.g., `useDeposit`, `useRecurringLogic`) to separate concerns."}
{"text":"Q: How can you ensure form cleanup on unmount? A: Call `resetBookingDetail()` or `formMethods.reset(initialValues)` in a cleanup effect to clear context and form state when leaving screen."}
{"text":"Q: How would you handle partial success on updateBooking? A: If API returns partial failures, show inline errors via `setError` on specific fields or `Alert.alert` with details, and avoid navigation.goBack."}
{"text":"Q: What considerations exist for offline booking creation? A: Queue payload in local storage, show offline indicator, and sync when network returns; disable slot fetch and show cached slots in offline mode."}
{"text":"Q: How can you internationalize numberOfPerson input? A: Use locale-specific number pad and format via `Intl.NumberFormat` for display while typing, and parse using `parseInt` on submit."}
{"text":"Q: How would you handle form validation messages display? A: Pass `error` props from React Hook Form to each `<FormInput>`/`<FormDropdown>` to show inline validation errors below fields."}
{"text":"Q: How can you dynamically show/hide fields based on business logic? A: Use conditional rendering tied to `bookingType`, `amenityDetail.isUseDeposited`, and `amenityDetail.isAllowRecurring` to keep UI reactive."}
{"text":"Q: What is the significance of `languageId` from useApp? A: Used to pick the correct remark text from `amenityDetail.remarks` array by matching `languageName === languageId`."}
{"text":"Q: How is `amenityRemark` computed? A: In JSX, using `_.size(amenityDetail.remarks)` and `find` to get the remark value for the current language, defaulting to empty string."}
{"text":"Q: Why display `amenityRemark` as a disabled FormInput? A: To show static policy notes or instructions tied to the selected amenity, without allowing user edits."}
{"text":"Q: How is the `company` dropdown implemented differently from `status`? A: Uses `<FormLazyDropdown>` with server-side search (`getSimpleCompanies`) for large company lists, whereas status uses a simple static dropdown."}
{"text":"Q: Why pass `mode='small'` to most form controls? A: To use a compact UI variant suitable for mobile screens, reducing padding/font sizes for dense layouts."}
{"text":"Q: How would you implement a “Help” tooltip for each field? A: Wrap field labels in a `InfoTooltip` component that shows contextual help text on tap or hover."}
{"text":"Q: How does the component handle accessibility for custom components? A: Ensure each form control has `accessibilityLabel`, `accessible`, and role attributes; wrap composite controls in `FormControl` with appropriate props."}
{"text":"Q: How would you add analytics for user interactions? A: In each `onPress`, `onChange`, and `handleSubmit`, call tracking functions logging event names and field values (anonymized) for UX analysis."}
{"text":"Q: What patterns enable easier maintenance of this screen? A: Modularization of logic into hooks, small reusable UI components, centralized validation schema, and consistent naming conventions for form fields."}
{"text":"Q: How can you enforce consistency between form field names and payload keys? A: Define a constants file mapping form names to payload keys and use it in both form setup and payload building, reducing typos."}
{"text":"Q: How might you support dark mode? A: Use theme context via styled-components, reference Colors from theme for backgrounds/text, and ensure all hardcoded colors use theme variables."}
{"text":"Q: How does the component manage memory leaks from async calls? A: Could use `let isMounted = true` in effects and cancel state updates if unmounted, or use AbortController to cancel fetches when unmounting."}
{"text":"Q: How to extract common form field array logic into a custom hook? A: Create `useFormArray(name)` for watching, setting, and validation of array fields like slots, companies, or files, reducing boilerplate."}
{"text":"Q: What are the key scenarios to test manually? A: Add booking happy path, slot selection edge cases (max slots, non-contiguous), deposit calculation, cancel/decline edit mode, file upload, recurring booking full flow."}
{"text":"Q: How does the component handle time zone differences? A: Uses `moment` for parsing/formatting with local defaults; to handle multiple zones, consider using `moment.tz` and passing timeZone context from user settings."}
{"text":"Q: How to integrate feature flags for recurring booking? A: Wrap `<BookingRecurring>` and related logic in `if (featureFlags.recurringBooking)` to enable/disable the feature remotely."}
{"text":"Q: How would you extract currency formatting logic? A: Use `LocaleConfig.formatMoney` inside a custom hook `useCurrency` or context, ensuring consistent formatting and currency symbol placement."}
{"text":"Q: How to prevent stale bookingSlots after amenity change? A: Clear form `slots` (e.g., `setValue('slots', [])`) before fetching new slots in `getBookingTimeSlots` to avoid showing old availability briefly."}
{"text":"Q: How to handle missing bookingPurposes? A: Check `bookingPurposes.length===0` before rendering the dropdown and display a spinner or “No purposes available” message until loaded."}
{"text":"Q: How can you improve user guidance for required fields? A: Add `*` indicators to labels, group required fields together, and show tooltips explaining why certain fields are mandatory."}
{"text":"Q: Why use `navigation.goBack()` instead of `NavigationService`? A: Here `navigation` prop from react-navigation is used; elsewhere `NavigationService` is used for non-hook contexts—both achieve similar navigation actions."}
{"text":"Q: What linter rules would you apply to this file? A: Enforce consistent dependency arrays in hooks, no unused vars (e.g., resetBookingDetail commented), and consistent naming/import order."}
{"text":"Q: How to handle API versioning in payload? A: Include a `version` key in payload or update hook call to `addBookingV2`, allowing backward compatibility as backend evolves."}
{"text":"Q: How does the component ensure idempotency on save? A: Could include a client-generated UUID in payload, preventing duplicate bookings if the user taps Save twice due to lag."}
{"text":"Q: How would you support editing recurring bookings? A: Extend edit mode to load `bookingDetail.recurrence` rules, prefill `<BookingRecurring>` component, and branch on `formValues.recurrence` in onSave."}
{"text":"Q: What approach helps coordinate multiple async calls? A: Use `Promise.all` or sequential `await` inside an async wrapper, handling errors individually or via consolidated catch with context."}
{"text":"Q: How can you centralize I18n keys usage? A: Create a constants file `I18nKeys` exporting keys like `FORM_THIS_FIELD_IS_REQUIRED`, and import them for consistency and refactoring safety."}
{"text":"Q: How to ensure predictable form reset on mode switch? A: In a `useEffect([isAddNew])`, call `reset(initialValues)` when switching from edit to add or vice versa, clearing stale values."}
{"text":"Q: What are potential edge cases in booking flows? A: Booking past dates, selecting slots crossing midnight, handling leap year/feb29, daylight savings transitions, simultaneous edits by multiple users."}
{"text":"Q: How to integrate unit tests for form validation schema? A: Use Yup’s `validateSync` on sample payloads, ensuring required fields, email format, and slot selection tests pass/fail as expected."}
{"text":"Q: How to support automated localization testing? A: Render the component in different locales within tests, snapshot test the UI labels, and verify date/time formats match locale conventions."}
{"text":"Q: How can you profile render performance? A: Use React DevTools Profiler to record renders, identify heavy hooks or re-renders, and optimize via memoization or splitting components."}
{"text":"Q: How to document this component for future developers? A: Add JSDoc comments for key functions (`getInitialValuesForUpdate`, `calculateDepositPrice`, `recurringBooking`), and inline TODOs for known improvements."}
{"text":"Q: What accessibility audit should be performed? A: Use tools like aXe or React Native Accessible to ensure forms have proper labels, focus order, and color contrast for warning text."}
{"text":"Q: How would you internationalize date picker? A: Pass `locale={I18n.locale}` prop to `<FormCalendarPicker>` and ensure it uses `moment.locale(I18n.locale)` under the hood."}
{"text":"Q: How to handle user time zone in deposit logic? A: Include tenant’s time zone in amenityDetail, and use that zone in moment parsing/formatting and rule matching to avoid local discrepancies."}
{"text":"Q: How does the component scale for multiple booking targets? A: Booking targets (occupier, company, outsider) drive conditional fields; adding a new target simply requires adding case in schema and payload logic."}
{"text":"Q: How to externalize field labels for A/B testing? A: Pass label keys as props or define them in an external config so experiments can swap labels without code changes."}
{"text":"Q: How to ensure the modal doesn’t block underlying keyboard shortcuts? A: Use `keyboardShouldPersistTaps='handled'` on ScrollViews and modals to manage focus and tap behavior reliably."}
{"text":"Q: What debugging tools help track form state? A: Use React Hook Form’s `useWatch` in dev mode to log form values on every change, or use the DevTools integration for state inspection."}
{"text":"Q: How to support reactive form loading spinners per section? A: Add local `isLoadingStatus`, `isLoadingPurposes`, `isLoadingSlots` flags from hooks, and render spinners in place of dropdowns/lists when true."}
{"text":"Q: How to handle large attachments in FormDocumentPicker? A: Validate file size in the picker component, show progress indicators for large uploads, and allow cancellation of in-flight uploads."}
{"text":"Q: How would you implement deep error reporting for production? A: Use Sentry or similar to capture exceptions in `recurringBooking`, `onSave`, and other async flows, reporting stack traces and user context."}
{"text":"Q: How to refactor error alerts into a centralized handler? A: Create a `useErrorHandler()` hook that catches and displays errors uniformly, replacing `Alert.alert` calls with `showError(error)`."}
{"text":"Q: How can you integrate a confirmation prompt before discarding changes? A: Use a `useBeforeRemove` listener from react-navigation to show an `Alert.alert` if `formMethods.formState.isDirty` when navigating away."}
{"text":"Q: How to allow users to save drafts without completing booking? A: Introduce a `statusCode: DRAFT`, add a “Save Draft” button calling `addBooking` with draft flag, and surface drafts in the booking list."}
{"text":"Q: How to ensure backward compatibility with older booking APIs? A: Version-check in hook, map new payload shape to legacy API format if required, and maintain both code paths until full migration."}
{"text":"Q: How to handle server-side data shape changes? A: Use TypeScript interfaces or PropTypes to define expected shapes for bookingDetail, amenityDetail, and adjust mapping in `getInitialValuesForUpdate` accordingly."}
{"text":"Q: What metrics should you capture for booking flows? A: Load times for slot fetching, time to first render, validation errors counts, recurring booking success/failure rates, and user abandonment points."}
{"text":"Q: How can you ensure the component is future-proof for new features (e.g., multi-resource booking)? A: Architect with extensible patterns—use maps for targets, abstract slot logic, and externalize business rules to configuration rather than hardcoded arrays."}
{"text":"Q: How do you ensure that the UI remains responsive under slow network conditions? A: Show skeleton loaders for form fields, disable Save until network checks complete, and allow users to interact with cached data optimistically."}
{"text":"Q: What patterns support previewing a booking summary before save? A: Render a read-only `<BookingSummary>` component below the form that updates live from formValues, giving users immediate feedback."}
{"text":"Q: How to implement server-side validation feedback inline? A: After API failure with field errors, call `setError('fieldName', { message: serverMessage })` to display under the relevant input."}
{"text":"Q: How to support multiple locales for currency in depositPrice? A: Store prices in smallest unit (cents), and use `Intl.NumberFormat(I18n.locale, { style:'currency', currency: localeCurrency })` instead of LocaleConfig.formatMoney."}
{"text":"Q: How would you handle legacy browsers or React Native versions without Hooks? A: Provide a class-based equivalent component or use the Hooks-to-HOC polyfill, ensuring backward compatibility gradually phased out."}
{"text":"Q: How to structure this component for micro-frontend architectures? A: Expose `<AddOrEditBooking>` as a standalone module, bundle its dependencies separately, and integrate via dynamic import or WebView in host app."}
{"text":"Q: How to monitor memory usage of this component? A: In development, use memory profiler tools, monitor number of listeners, array sizes (slots, bookingRuleFiles), and clean up any lingering state on unmount."}
{"text":"Q: How to support accessibility contrast testing? A: Use automated tools to check color contrast of BookingWarningText, disabled inputs, and ensure adherence to WCAG guidelines."}
{"text":"Q: What is the significance of styling `<Card>` via styled-components? A: Provides consistent container style (margin, padding, border) with theme integration, simplifying layout adjustments across screens."}
{"text":"Q: How can you centralize slot formatting logic? A: Move `formatSlotTime` and `getTimeRange` into a utility module `slotUtils.js` for reuse between Add and Confirmation components."}
{"text":"Q: How to handle conditional display of paymentStatus dropdown? A: Render it only when `amenityDetail.isUseDeposited` && ((isAddNew && status!==REQUESTED) || (!isAddNew && bookingDetail.paymentStatus)) to match business rules."}
{"text":"Q: How does the component manage multiple contexts (booking, app, user, file)? A: Uses separate hooks (`useBooking`, `useApp`, `useUser`, `useFile`), isolating domain logic and promoting single-responsibility."}
{"text":"Q: How to ensure context state stays in sync across components? A: Use context providers at top-level, keep hook logic idempotent, and consider subscribing to context changes with selectors to minimize re-renders."}
{"text":"Q: How would you implement feature toggle for file uploads? A: Wrap `<FormDocumentPicker>` in `if (featureFlags.fileUploads)` so you can turn off file attachments via remote config."}
{"text":"Q: What improvements could be made to the `InfoRow` component? A: Add `accessibilityRole='text'` and `accessible` props, allow custom icon color via props, and memoize to avoid re-renders with props unchanged."}
{"text":"Q: How to support right-to-left (RTL) layouts? A: Use `I18nManager.isRTL` to flip styled-components (e.g., `margin-right` to `margin-left`) and ensure icon/name order reverses correctly."}
{"text":"Q: How can you add state persistence between sessions? A: Use AsyncStorage or MMKV to save in-progress form data under a key and restore it in `useEffect([])` on mount, prompting the user to resume."}
{"text":"Q: How to handle complex unit suggestion logic? A: Replace FormSuggestionPicker with a virtualized dropdown that pages results via `getSimpleUnits`, and cache results for repeat queries."}
{"text":"Q: How to share deposit logic across multiple components? A: Extract into `useDepositCalculator(slots, amenityTimeRules)` hook returning `{price, formatted}` and use inside Add/Edit and any summary components."}
{"text":"Q: How does the code ensure consistent money formatting? A: Uses `LocaleConfig.formatMoney` central utility; you could switch to `Intl.NumberFormat` for built-in locale support."}
{"text":"Q: How might you centralize date handling? A: Create a `DateUtils` module exporting `formatDate`, `getTimePeriod`, `stringToISO`, and reuse across components to avoid inconsistent formats."}
{"text":"Q: How to handle currency conversion for multi-currency amenities? A: Extend amenityDetail to include currency code, and use `Intl.NumberFormat` with dynamic currency parameter in deposit and total price displays."}
{"text":"Q: How would you support a “preview as PDF” for bookings? A: Build HTML/CSS template of formValues, use a PDF generator library (e.g., react-native-html-to-pdf), and offer a download/share action after Save."}
{"text":"Q: How to ensure developers can easily extend booking fields? A: Use a JSON schema to define form fields, render via a dynamic form builder, and map schema keys to payload automatically."}
{"text":"Q: How to coordinate booking and payment flows? A: After add/edit, navigate to a Payment screen if `amenityDetail.isUseDeposited` and `paymentStatus===NOT_YET_DEPOSIT`, passing bookingId to initiate payment."}
{"text":"Q: How to instrument logs for slot fetch latency? A: In `getBookingTimeSlots`, record timestamps before/after `getAllTimeSlots` and send timing data to analytics or console.trace for debugging."}
{"text":"Q: How to support server-driven UI changes? A: Fetch a form configuration object from API describing which fields to show/validate, and render form controls dynamically based on that config instead of hardcoded JSX."}
{"text":"Q: How to handle multiple bookingRecurrence flows? A: Abstract recurrence logic into `useRecurrence` hook, accepting config and callbacks for validation, confirmation, and final save, enabling reuse in other modules."}
{"text":"Q: What patterns help isolate side effects in hooks? A: Use custom hooks (`useBookingDetail`, `useSlotFetcher`, `useDepositPrice`, `useRecurringBooking`) to keep the component focused on UI composition."}
{"text":"Q: How can you reduce render-blocking work on initial load? A: Lazy-load heavy components (`BookingRecurring`, `BookingPolicyRules`) via React.lazy and Suspense, showing skeletons until loaded."}
{"text":"Q: How to ensure consistent error state reset? A: On successful `addBooking` or `updateBooking`, call `clearErrors()` from React Hook Form to remove any lingering validation messages before navigation."}
{"text":"Q: How to support bi-directional data flow? A: Use controlled components via `value` and `onChange`, but allow programmatic updates via `setValue` in effects, keeping form state authoritative."}
{"text":"Q: How to implement collaborative editing safeguards? A: Subscribe to real-time updates on bookingDetail via WebSocket, show a warning if another user edits the booking concurrently, and optionally lock the form."}
{"text":"Q: How would you integrate a guided tutorial overlay? A: Use a library like react-native-copilot to highlight fields (FormCalendarPicker, SlotView, Save button) with step-by-step instructions for first-time users."}
{"text":"Q: How to audit user changes for compliance? A: Track previous and new values in `onSave`, send a diff to an audit log endpoint, and display change history in the FloatingConversation chat."}
{"text":"Q: What considerations exist for mobile vs tablet layouts? A: Adjust Container width, use multi-column layout for large screens, and increase touch target sizes for better ergonomics on tablets."}
{"text":"Q: How to support voice input for form fields? A: Integrate React Native Voice or built-in speech-to-text APIs for text inputs like `remark` and `purpose`, enhancing accessibility."}
{"text":"File: AddOrEditBooking.js, Q: What does `useBooking()` provide to the AddOrEditBooking component? A: It exposes booking state (`bookingDetail`, `statusList`, `paymentStatusList`, `bookingPurposes`, `amenityDetail`, `bookingSlots`, `amenityList`) and actions (`getBookingDetail`, `addBooking`, `updateBooking`, `getAmenityDetail`, `validateRecurringBooking`, `getBookingStatus`, `getPaymentStatus`, `getBookingPurpose`, `getAmenities`, `getAllTimeSlots`) for managing booking CRUD, lookups, slot fetching, and recurring validation."}
{"text":"File: AddOrEditBooking.js, Q: How is `getBookingDetail` used in edit mode? A: In a `useEffect([id])` hook, when `!isAddNew` and `id` is defined, `getBookingDetail(id)` fetches the existing booking’s details to populate the form."}
{"text":"File: AddOrEditBooking.js, Q: When should `addBooking` be called? A: In the `onSave` handler, if `isAddNew` is true and no `recurrence` is defined, after constructing the payload with selected slots and form values, `addBooking(payload)` persists the new booking."}
{"text":"File: AddOrEditBooking.js, Q: When should `updateBooking` be called? A: In `onSave`, if `isAddNew` is false and no `recurrence`, the component calls `updateBooking(payload)` to save edits to an existing booking, reusing original start/end dates."}
{"text":"File: AddOrEditBooking.js, Q: What role does `getAmenityDetail` play? A: Called when an amenity is selected or when editing an existing booking, it fetches detailed `amenityDetail` (rules, remarks) which drives slot fetching, deposit logic, and policy display."}
{"text":"File: AddOrEditBooking.js, Q: How does `validateRecurringBooking` integrate into the recurring flow? A: In `recurringBooking`, after building a payload with `bookingTimes` array, `validateRecurringBooking(bookingObj)` checks availability of all recurred slots, returning valid/invalid slots for user confirmation."}
{"text":"File: AddOrEditBooking.js, Q: Why call `getBookingStatus`, `getPaymentStatus`, and `getBookingPurpose` on mount? A: To load lookup lists for status codes, payment statuses, and booking purposes into dropdowns, ensuring the form has the correct options before user interaction."}
{"text":"File: AddOrEditBooking.js, Q: How does `getAmenities` interact with `amenityList`? A: On mount, if `amenityList` is empty, `getAmenities()` fetches all available amenities for the selection modal, preventing redundant network requests if already loaded."}
{"text":"File: AddOrEditBooking.js, Q: What does `getAllTimeSlots` do and when is it called? A: It fetches available time slots for a given amenity and date range; invoked in `getBookingTimeSlots()` inside a `useEffect([startDate,endDate,amenityDetail])` to refresh slots whenever the date or amenity changes."}
{"text":"File: AddOrEditBooking.js, Q: Why guard `if (!amenityDetail) return;` before fetching slots? A: To prevent calling `getAllTimeSlots` without a valid `amenityId`, avoiding errors and unnecessary API calls when amenity details haven’t loaded yet."}
{"text":"File: AddOrEditBooking.js, Q: What does `useApp()` provide and how is it used? A: It supplies `getSimpleCompanies` (to fetch company suggestions), `simpleCompanies` data, and `languageId` (for localized amenity remarks), supporting the company booking type and remark localization."}
{"text":"File: AddOrEditBooking.js, Q: How is `getSimpleCompanies` used in the company booking flow? A: Called on mount with `{page:1}` and on-demand by `<FormLazyDropdown>` for paginated search, populating `simpleCompanies.data` for the company selector."}
{"text":"File: AddOrEditBooking.js, Q: Why fetch the first page of companies on mount? A: To ensure initial options are available when the user opens the company dropdown, improving UX by avoiding an empty list on first open."}
{"text":"File: AddOrEditBooking.js, Q: What does `useUser()` supply and why is `securitySetting` relevant? A: It provides user preferences like `securitySetting.isShowEmailAndPhone`, which controls rendering of contact email/phone fields in the occupier booking section."}
{"text":"File: AddOrEditBooking.js, Q: How does `useFile()` support existing file attachments? A: It exposes `getFileByReferenceId` and `referenceFiles` to fetch and populate existing attachments in edit mode, and `getByReferenceIdAndModuleNames`/`bookingRuleFiles` for amenity policy documents."}
{"text":"File: AddOrEditBooking.js, Q: Why use `_.size(referenceFiles)` as a dependency when setting form `files`? A: To trigger `setValue('files', referenceFiles)` only when the count of reference files changes, preventing unnecessary resets if the array identity changes with same length."}
{"text":"File: AddOrEditBooking.js, Q: How are `bookingRuleFiles` fetched and used? A: When `isAddNew` and `amenityDetail` changes, `getByReferenceIdAndModuleNames(amenityDetail.guid,'','bookingRuleFiles')` loads policy docs, which are then displayed via `<BookingPolicyRules>`."}
{"text":"File: AddOrEditBooking.js, Q: How do `bookingSlots` from context and the form field `slots` stay in sync? A: A `useEffect([bookingSlots])` calls `formMethods.setValue('slots', bookingSlots)` when `bookingSlots` updates, ensuring the slot picker displays the latest availability."}
{"text":"File: AddOrEditBooking.js, Q: How is caching of lookups achieved for bookingPurposes and amenityList? A: By checking the context arrays’ lengths (`_.size(amenityList)`) before fetching, the component avoids redundant API calls if data already exists."}
{"text":"File: AddOrEditBooking.js, Q: How do all these hooks orchestrate the add-mode data-fetch sequence? A: On mount load lookups; on amenity select fetch detail → fetch rule files → fetch slots → populate form; on slot or date changes refetch slots → recalc deposit."}
{"text":"File: AddOrEditBooking.js, Q: How do all these hooks orchestrate the edit-mode data-fetch sequence? A: On mount load lookups; effect on `id` fetches bookingDetail → effect on bookingDetail fetches amenityDetail & files → reset form → effect fetch rule files & slots → disable form if canceled."}
{"text":"File: AddOrEditBooking.js, Q: What error handling should wrap these hook calls? A: Each async action (getBookingDetail, getAmenityDetail, getAllTimeSlots, validateRecurringBooking, addBooking, updateBooking) should use try/catch to `Alert.alert(I18n.t('ERROR'), error.message)` and optionally retry or disable UI."}
{"text":"File: AddOrEditBooking.js, Q: How can you debounce rapid amenity changes to prevent excessive API calls? A: Wrap `getAmenityDetail` in a debounced callback inside `onAmenitySelect`, or use a debounced effect on `amenityId` with a short delay to batch rapid changes."}
{"text":"File: AddOrEditBooking.js, Q: How might you unit-test the component’s interactions with these hooks? A: Mock the `useBooking`, `useApp`, `useUser`, and `useFile` hooks to return fake data/functions, then assert that effects call the correct methods and form values update accordingly."}
{"text":"File: AddOrEditBooking.js, Q: How could you refactor hook-driven logic into custom hooks for clarity? A: Extract booking-detail logic into `useBookingDetail(id,isAddNew)`, amenity logic into `useAmenityData(amenityId)`, and slot/deposit logic into `useSlotAndDeposit(slots,amenityRules)` hooks to declutter the component."}
{"text":"File: AddOrEditBooking.js, Q: How does the component determine whether it’s in “Add” or “Edit” mode? A: It calls `useRoute()` to get `name` and `params`; then sets `isAddNew = (name==='addBooking')` and `isEdit = (name==='editBooking')`, driving which effects run, which UI elements render, and whether to call `addBooking` or `updateBooking` on save."}
{"text":"File: AddOrEditBooking.js, Q: What is the significance of the `id` constant and how is it used? A: `id = params?.id` holds the booking identifier passed via navigation; in edit mode (`!isAddNew`), a `useEffect([id])` hook calls `getBookingDetail(id)` to fetch existing booking data for form initialization."}
{"text":"File: AddOrEditBooking.js, Q: Why is `requiredMessage` defined and how is it used? A: `requiredMessage = I18n.t('FORM_THIS_FIELD_IS_REQUIRED')` loads a localized error string; it’s passed into the Yup validation schema to display consistent “field is required” messages for all required form controls."}
{"text":"File: AddOrEditBooking.js, Q: How is the `validationSchema` memoized and why? A: It’s wrapped in `useMemo` with `[isAddNew]` as a dependency, so the schema only recomputes when the add/edit mode changes, avoiding unnecessary re-validations on every render."}
{"text":"File: AddOrEditBooking.js, Q: What are the core fields defined in `baseSchema` and their validations? A: `bookingType` must be a non-empty array of valid booking target codes; `unit` is required when bookingType is occupier; `company` is required when bookingType is company; `email` is required and must be valid when bookingType is outsider; otherwise these fields are nullable."}
{"text":"File: AddOrEditBooking.js, Q: How does the conditional `when('bookingType')` logic work for `unit`, `company`, and `email`? A: Yup’s `.when` checks the first element of `bookingType`; if it matches a target, it applies `.required(requiredMessage)`, otherwise marks the field as nullable."}
{"text":"File: AddOrEditBooking.js, Q: How is the `slots` field validation added only in add-new mode? A: Inside the `if (isAddNew)` block, `baseSchema.slots` is defined as a Yup array that’s required and tested to ensure at least one slot has `isCheck===true`; this block runs only when `isAddNew` is true."}
{"text":"File: AddOrEditBooking.js, Q: What does the custom `.test('at-least-one-selected', ...)` do for `slots`? A: It defines a custom validation named ‘at-least-one-selected’ that fails unless the array contains at least one element with `slot.isCheck === true`, enforcing slot selection for new bookings."}
{"text":"File: AddOrEditBooking.js, Q: Why is `Yup.object().shape(baseSchema)` used at the end? A: It constructs a Yup object schema from the `baseSchema` definition, combining all field rules into a single schema object for form validation."}
{"text":"File: AddOrEditBooking.js, Q: How does `useCompatibleForm` work with the validation schema? A: It calls React Hook Form’s `useForm` under the hood with `defaultValues` and a resolver from `useYupValidationResolver(validationSchema)`, wiring up Yup validation to the form methods."}
{"text":"File: AddOrEditBooking.js, Q: What is the role of `useYupValidationResolver`? A: It converts a Yup schema into a validation resolver that React Hook Form can use, mapping Yup errors to form error objects."}
{"text":"File: AddOrEditBooking.js, Q: Why are `defaultValues` passed into `useCompatibleForm`? A: To initialize form fields with `initialValues`, ensuring the form starts with proper defaults for both add and edit modes before any user input or reset."}
{"text":"File: AddOrEditBooking.js, Q: How would you extend the schema to add a max-length rule on `remark`? A: Add a `remark: Yup.string().max(200, I18n.t('MAX_200_CHAR')).nullable()` entry to `baseSchema` before calling `Yup.object().shape`."}
{"text":"File: AddOrEditBooking.js, Q: What is the role of `requiredMessage` in the Yup schema? A: It holds the localized error text (`I18n.t('FORM_THIS_FIELD_IS_REQUIRED')`) and is applied to all `.required()` and custom tests to ensure consistent “field is required” messaging."}
{"text":"File: AddOrEditBooking.js, Q: How is the `bookingType` field validated? A: Defined as `Yup.array().of(Yup.number().oneOf([...])).required(requiredMessage)`, ensuring it’s a non-empty array containing only allowed numeric target codes."}
{"text":"File: AddOrEditBooking.js, Q: How does the schema enforce that `unit` is required only when bookingType is occupier? A: Uses `.when('bookingType', { is: val => val[0]===bookingTargets.occupier, then: Yup.object().required(requiredMessage), otherwise: Yup.object().nullable() })`."}
{"text":"File: AddOrEditBooking.js, Q: How does the schema enforce that `company` is required only when bookingType is company? A: Similar to `unit`, it uses Yup’s `.when('bookingType')` to require `company` object when `bookingTargets.company` is selected, otherwise nullable."}
{"text":"File: AddOrEditBooking.js, Q: How is outsider email validated? A: The `email` field uses `.nullable().when('bookingType', { is: outsider, then: Yup.string().required(requiredMessage).email(I18n.t('EMAIL_IS_INVALID')), otherwise: Yup.string().nullable() })`, enforcing required + valid email only for outsiders."}
{"text":"File: AddOrEditBooking.js, Q: What conditional validation is applied to the `slots` array? A: Inside `if (isAddNew)`, `slots` is validated as `Yup.array().required(requiredMessage).test('at-least-one-selected', requiredMessage, value => value?.some(slot=>slot.isCheck))`, ensuring at least one slot is checked when adding a booking."}
{"text":"File: AddOrEditBooking.js, Q: Why is `Yup.object().shape(baseSchema)` used? A: It combines all field rules defined in `baseSchema` into a single Yup object schema, which React Hook Form then uses for validation via the resolver."}
{"text":"File: AddOrEditBooking.js, Q: How is the validation schema memoized? A: Wrapped in `useMemo(() => { ... }, [isAddNew])`, so it only recalculates when `isAddNew` changes, avoiding unnecessary schema recreation on every render."}
{"text":"File: AddOrEditBooking.js, Q: What is the significance of `.nullable()` in the schema definitions? A: It allows fields like `unit`, `company`, and `email` to be `null` when they are not required, preventing default Yup `required` behavior for missing values."}
{"text":"File: AddOrEditBooking.js, Q: How would you add a max-length constraint to the `remark` field? A: Extend `baseSchema` with `remark: Yup.string().max(200, 'Max 200 characters').nullable()`, then include it in `.shape(baseSchema)`."}
{"text":"File: AddOrEditBooking.js, Q: How are schema validation errors integrated into the form UI? A: React Hook Form’s resolver uses the Yup schema to return error objects, which each `<FormInput>` and `<FormDropdown>` displays near the field automatically."}
{"text":"File: AddOrEditBooking.js, Q: How does the resolver connect Yup to React Hook Form? A: `useYupValidationResolver(validationSchema)` creates a function that RHF uses to validate form values against the Yup schema on submit and on blur."}
{"text":"File: AddOrEditBooking.js, Q: Why does the schema test for `value && value.some(...)` in the `slots` test? A: To ensure `slots` isn’t `undefined` or empty and contains at least one element where `isCheck===true`, enforcing user selection of time slots for new bookings."}
{"text":"File: AddOrEditBooking.js, Q: What happens if validation fails on submit? A: `handleSubmit(onSave)` prevents `onSave` from running; React Hook Form populates `formState.errors`, and the UI highlights fields with error messages from Yup."}
{"text":"File: AddOrEditBooking.js, Q: How can you make the validation messages more specific per field? A: Replace `requiredMessage` with field-specific messages like `I18n.t('BOOKING_TYPE_REQUIRED')` in each `.required()`, or add `.test` with custom messages."}
{"text":"File: AddOrEditBooking.js, Q: How would you require `purposeId` to be non-null? A: Add `purposeId: Yup.mixed().required(requiredMessage)` to `baseSchema` before `Yup.object().shape`, making the dropdown selection mandatory."}
{"text":"File: AddOrEditBooking.js, Q: How can you validate numeric range for `numberOfPerson`? A: Include `numberOfPerson: Yup.number().min(1, 'At least 1').max(100, 'Max 100').nullable()` in `baseSchema`."}
{"text":"File: AddOrEditBooking.js, Q: How to validate that `bookingType` is exactly one element long? A: Add a `.length(1, 'Select exactly one type')` on the `bookingType` array schema: `Yup.array().length(1).of(...).required(...)`."}
{"text":"File: AddOrEditBooking.js, Q: How can you ensure `email` trimming before validation? A: Use `Yup.string().trim().nullable().when(...)` to automatically remove whitespace before applying `.email()` and `.required()` checks."}
{"text":"File: AddOrEditBooking.js, Q: How can you add custom validation to `unit` based on `securitySetting`? A: Use `.when(['bookingType', 'securitySetting'], (type, setting, schema) => { /* return modified schema */ })` within Yup to conditionally require or transform `unit`."}
{"text":"File: AddOrEditBooking.js, Q: How do you test the validation schema in isolation? A: Import the schema and call `schema.validateSync({ ...values })` or `schema.validate({ ...values })` in unit tests, asserting thrown validation errors for invalid inputs."}
{"text":"File: AddOrEditBooking.js, Q: Why is it important to include `isAddNew` in the memo dependency? A: Because the schema conditionally includes `slots` validation only when adding; omitting it would prevent the schema from updating when switching modes."}
{"text":"File: AddOrEditBooking.js, Q: How would you disable validation on blur? A: Configure React Hook Form’s `mode` option, e.g., `useCompatibleForm({ mode: 'onSubmit', ... })`, so validation runs only on submit, not on blur or change."}
{"text":"File: AddOrEditBooking.js, Q: How can you display validation feedback immediately on field change? A: Set RHF’s `mode:'onChange'` or `onTouched`, causing the resolver to run and update `formState.errors` as the user types or selects."}
{"text":"File: AddOrEditBooking.js, Q: How to handle async validation (e.g., unique email)? A: Use Yup’s `.test()` with an async function returning a Promise, or use RHF’s `validate` prop on fields to call an API and return an error message string."}
{"text":"File: AddOrEditBooking.js, Q: What does `setValue` from `formMethods` do and when is it used? A: `setValue` programmatically sets the value of a form field; it’s called in effects to populate fields (e.g., setting `files`, `bookingRuleFiles`, and when slots or amenityDetail change) without user interaction."}
{"text":"File: AddOrEditBooking.js, Q: How does `watch` from React Hook Form work in this component? A: `watch` subscribes to form field changes and returns their current values; it’s used to read `startEndDate`, `bookingType`, `depositPrice`, `slots`, `status`, `unit`, and `recurrence` so the component can reactively compute UI and side effects."}
{"text":"File: AddOrEditBooking.js, Q: Why is `handleSubmit` destructured from `formMethods`, and how is it used? A: `handleSubmit` wraps the `onSave` handler, running validation before invoking `onSave`; it’s passed to the Save button’s `onPress` to ensure the form is valid before submission."}
{"text":"File: AddOrEditBooking.js, Q: What is the purpose of `reset` in `formMethods`, and when is it called? A: `reset` replaces the entire form state with new values; it’s used in the effect on `[bookingDetail]` to populate the form with existing data when editing."}
{"text":"File: AddOrEditBooking.js, Q: How is `startEndDate` initialized and used? A: `startEndDate = watch('startEndDate')` reads the date picker value for new bookings; it drives slot fetching and populates `startDate`/`endDate` when `isAddNew` is true."}
{"text":"File: AddOrEditBooking.js, Q: Why use `watch('bookingType')[0]` instead of watching `bookingType` directly? A: The form stores `bookingType` as an array of one element; `[0]` extracts the numeric code for conditional rendering of fields and payload construction."}
{"text":"File: AddOrEditBooking.js, Q: Why does the code use `const slots = watch('slots') || []`? A: To ensure `slots` is always an array, guarding against `undefined` when the form is initializing or resetting, preventing runtime errors during filtering and mapping."}
{"text":"File: AddOrEditBooking.js, Q: How do `status`, `unit`, and `recurrence` watches affect the UI? A: `status` controls the display of the payment dropdown; `unit` supplies default contact info in occupier mode; `recurrence` toggles recurring-flow logic in slot updates."}
{"text":"File: AddOrEditBooking.js, Q: How are `startDate` and `endDate` computed for add vs. edit modes? A: If `isAddNew`, both use `startEndDate` (the single selected date); otherwise they come from `bookingDetail.startDate` and `bookingDetail.endDate` loaded from the API."}
{"text":"File: AddOrEditBooking.js, Q: What does the `isDisabledForm` state control? A: `isDisabledForm` toggles `<FormDisabledProvider>`, disabling all inputs when set to true (e.g., for canceled or declined bookings) to prevent edits."}
{"text":"File: AddOrEditBooking.js, Q: How is `isDisabledForm` set in the component? A: In the `[bookingDetail]` effect, it checks `bookingDetail.status.statusCode`; if it’s `CANCELED` or `DECLINED`, it calls `setIsDisabledForm(true)`."}
{"text":"File: AddOrEditBooking.js, Q: What is the role of `visibleSelectAmenity` state? A: It controls the visibility of `<SelectAmenityModal>`; when true, the amenity selector opens, allowing the user to pick an amenity for a new booking."}
{"text":"File: AddOrEditBooking.js, Q: How is `visibleSelectAmenity` toggled? A: `setVisibleSelectAmenity(true)` is called by `onShowSelectAmenity` when the user taps the amenity button; `onCloseSelectAmenity` sets it to false after selection or cancel."}
{"text":"File: AddOrEditBooking.js, Q: Why separate local UI state (`isDisabledForm`, `visibleSelectAmenity`) from form state? A: UI state manages component visibility and interactivity independently of form values, keeping concerns isolated for clarity and maintainability."}
{"text":"File: AddOrEditBooking.js, Q: How does `watch('recurrence')` integrate with slot changes? A: When `recurrence` is non-null, the `onChange` callback on `<FormSlotView>` recalculates `recurrence.bookingTimes` via `generateTimeSlots`, syncing recurrence rules with selected slots."}
{"text":"File: AddOrEditBooking.js, Q: Could you use `formMethods.watch` to observe all fields at once? A: Yes, but destructuring specific watches optimizes performance by re-rendering only when those fields change, rather than the entire form."}
{"text":"File: AddOrEditBooking.js, Q: What would happen if you didn’t default `slots` to `[]`? A: Accessing methods like `.filter` or `.map` on `undefined` trips runtime errors; the fallback ensures safe operations on `slots`."}
{"text":"File: AddOrEditBooking.js, Q: How does `handleSubmit(onSave)` differ from calling `onSave` directly? A: `handleSubmit` first runs the validation schema; if any errors exist, it prevents calling `onSave`, showing field errors instead of submitting invalid data."}
{"text":"File: AddOrEditBooking.js, Q: Why derive `startDate`/`endDate` in render instead of storing in state? A: They’re computed values based on form watches and props; deriving them ensures they always reflect the latest form or bookingDetail values without extra state management."}
{"text":"File: AddOrEditBooking.js, Q: How do the watched fields and local state combine to control side effects? A: Effects depend on `startDate`, `endDate`, `amenityDetail`, `bookingDetail`, and `bookingSlots`; watched values trigger fetches and resets, while UI state like `isDisabledForm` blocks interactions accordingly."}
{"text":"File: AddOrEditBooking.js, Q: What is the purpose of the first `useEffect(() => { if (!isAddNew && id) getBookingDetail(id); }, [id])` hook? A: It fetches the existing booking details when in edit mode; whenever the `id` route parameter changes (i.e., navigating to a different booking), it calls `getBookingDetail(id)` to populate the form."}
{"text":"File: AddOrEditBooking.js, Q: Why does the first effect check `!isAddNew` before calling `getBookingDetail`? A: To ensure booking detail is only fetched in edit mode; in add mode (`isAddNew`), there is no existing booking to load, so the API call is skipped."}
{"text":"File: AddOrEditBooking.js, Q: Why is the dependency array for the first effect `[id]` instead of `[isAddNew, id]`? A: Because `isAddNew` is derived from the route name and never changes during a component’s lifetime, watching `id` alone suffices to trigger re-fetch when editing a different booking."}
{"text":"File: AddOrEditBooking.js, Q: What does the second `useEffect(() => { if (!isAddNew) setValue('files', referenceFiles); }, [_.size(referenceFiles)])` hook do? A: In edit mode, whenever the number of `referenceFiles` changes, it populates the form’s `files` field with the fetched attachments via `setValue('files', referenceFiles)`."}
{"text":"File: AddOrEditBooking.js, Q: Why use `_.size(referenceFiles)` as the dependency instead of `referenceFiles` directly? A: Using the array’s length prevents the effect from re-running on every new array identity; it only runs when the count of files changes, avoiding unnecessary form resets."}
{"text":"File: AddOrEditBooking.js, Q: Why guard `if (!isAddNew)` in the second effect? A: To avoid setting form files for new bookings, since in add mode there are no existing attachments to preload, keeping the form’s `files` field empty."}
{"text":"File: AddOrEditBooking.js, Q: What does the third `useEffect(() => { setValue('bookingRuleFiles', bookingRuleFiles); }, [bookingRuleFiles, amenityDetail])` hook achieve? A: It updates the form’s `bookingRuleFiles` field whenever the fetched policy documents (`bookingRuleFiles`) or the selected amenity (`amenityDetail`) change, ensuring policy rules display stays in sync."}
{"text":"File: AddOrEditBooking.js, Q: Why include both `bookingRuleFiles` and `amenityDetail` in the dependency array? A: Because policy files may change when either the amenity details update or new files are fetched; including both ensures the effect captures both kinds of updates."}
{"text":"File: AddOrEditBooking.js, Q: How does the fourth `useEffect` with an empty array (`[]`) function? A: It runs once on mount to load lookup data: booking statuses, payment statuses, company list (page 1), booking purposes, and optionally amenities if not already loaded."}
{"text":"File: AddOrEditBooking.js, Q: Why call `getBookingStatus`, `getPaymentStatus`, `getSimpleCompanies({page:1})`, and `getBookingPurpose` on mount? A: To fetch all necessary dropdown options before user interaction, ensuring status, payment, company, and purpose selectors have data ready."}
{"text":"File: AddOrEditBooking.js, Q: Why does the mount effect check `if (_.size(amenityList) === 0) getAmenities()`? A: To avoid redundant network calls: if `amenityList` is already populated in context, it skips re-fetching, otherwise it loads the list for the amenity selection modal."}
{"text":"File: AddOrEditBooking.js, Q: What potential issue could arise if the mount effect omitted the check on `amenityList`? A: It would re-fetch amenities on every mount of the component, causing unnecessary API traffic and slower performance if the data was already available."}
{"text":"File: AddOrEditBooking.js, Q: How do these four effects together orchestrate the data loading sequence for add vs. edit? A: On mount, lookups load; in edit mode, bookingDetail fetches → files and amenityDetail fetch → bookingRuleFiles set; in add mode, policy files and initial slots load via other effects."}
{"text":"File: AddOrEditBooking.js, Q: How might you handle errors in these effect-driven API calls? A: Wrap async calls in `try/catch` or use `.catch()` to display `Alert.alert(I18n.t('ERROR'), error.message)` and set error state, to inform users of load failures."}
{"text":"File: AddOrEditBooking.js, Q: How could you prevent race conditions if `id` changes rapidly? A: Use a cancellation mechanism (e.g., AbortController) inside the effect or track a stale-flag so only the latest `getBookingDetail` response updates state."}
{"text":"File: AddOrEditBooking.js, Q: What is the purpose of the `useEffect` that watches `[bookingSlots]` and calls `formMethods.setValue('slots', bookingSlots)` when `isAddNew`? A: It ensures that when the available time slots (`bookingSlots`) are fetched from the API in add mode, the form’s `slots` field is immediately populated with that fresh data, so the slot picker shows current availability."}
{"text":"File: AddOrEditBooking.js, Q: Why is `bookingSlots` included in the dependency array of that effect? A: Including `bookingSlots` makes the effect re-run any time the slot data changes—e.g., after a date or amenity change—keeping the form’s internal `slots` array in sync with the latest availability."}
{"text":"File: AddOrEditBooking.js, Q: How does `getInitialValuesForUpdate()` guard against uninitialized state? A: It immediately returns `{}` if `isAddNew` is true or `bookingDetail` is falsy, preventing accidental overriding of form values in add mode or before the detail has loaded."}
{"text":"File: AddOrEditBooking.js, Q: How does `getInitialValuesForUpdate()` handle different booking types when mapping `bookingDetail`? A: It always spreads common fields, then conditionally adds: a `company` object for `company` bookings, a `unit` plus contact fields for `occupier`, or an `email` for `outsider`, matching the form’s expected shape for each type."}
{"text":"File: AddOrEditBooking.js, Q: In the `[bookingDetail, isAddNew]` effect, why call both `getAmenityDetail(bookingDetail.amenity?.amenityId)` and `getFileByReferenceId(bookingDetail.guid)`? A: To fetch the amenity’s rules/remarks and the existing booking’s attachment files before resetting the form, ensuring all dependent data is available for display in edit mode."}
{"text":"File: AddOrEditBooking.js, Q: What does `reset(getInitialValuesForUpdate())` achieve inside the bookingDetail effect? A: It replaces the entire form state with values derived from the loaded `bookingDetail`, reinitializing inputs, dropdowns, and slots to reflect the existing booking’s data."}
{"text":"File: AddOrEditBooking.js, Q: How does the bookingDetail effect determine when to disable the form? A: After resetting the form, it checks `bookingDetail.status.statusCode` and sets `isDisabledForm=true` if the status is `CANCELED` or `DECLINED`, preventing any further edits on closed bookings."}
{"text":"File: AddOrEditBooking.js, Q: Why include both `bookingDetail` and `isAddNew` in the dependency array of that effect? A: To re-run the initialization logic when either the booking detail loads (change in `bookingDetail`) or when switching between add and edit modes (`isAddNew`), ensuring the correct setup in each scenario."}
{"text":"File: AddOrEditBooking.js, Q: What is the purpose of the `useEffect` that watches `[amenityDetail]` and runs only when `isAddNew`? A: In add mode, once the selected `amenityDetail` loads, it fetches policy documents (`bookingRuleFiles`) and sets the default `paymentStatus` to “NotYetDeposit” if deposits apply, preparing the form for a new booking."}
{"text":"File: AddOrEditBooking.js, Q: Why does that effect check `amenityDetail.isUseDeposited` before setting `paymentStatus`? A: Because payment status only matters for amenities configured to require deposits; for others, the payment dropdown should remain hidden and the field unset."}
{"text":"File: AddOrEditBooking.js, Q: What triggers the effect `[startDate, endDate, amenityDetail]` that calls `getBookingTimeSlots()`? A: Any change to the booking date range (`startDate`, `endDate`) or the selected amenity (`amenityDetail`)—for both add and edit—causes a fresh fetch of available time slots for that day and amenity."}
{"text":"File: AddOrEditBooking.js, Q: Why does `getBookingTimeSlots()` guard with `if (!amenityDetail) return;`? A: To avoid calling the slot API without a valid `amenityId`. It ensures slots are only fetched when amenity details (including ID) are loaded, preventing errors."}
{"text":"File: AddOrEditBooking.js, Q: How are `fromDate` and `toDate` computed inside `getBookingTimeSlots()`? A: Both are set to the formatted `startDate` in `YYYY/MM/DD` format via `moment(startDate).format('YYYY/MM/DD')`, since for single-day bookings the API call needs the same date for start and end."}
{"text":"File: AddOrEditBooking.js, Q: Why call `getAllTimeSlots({ amenityId, fromDate, toDate })` instead of a dedicated “single-day” endpoint? A: The generic `getAllTimeSlots` API accepts a from/to range; passing identical dates requests only that single day’s availability, simplifying the client logic."}
{"text":"File: AddOrEditBooking.js, Q: How could you modify `getBookingTimeSlots()` to support multi-day bookings? A: Change `fromDate` to the start day and `toDate` to the end day (derived from `endDate`), allowing the API to return slots for the entire range, then flatten or group them in the UI."}
{"text":"File: AddOrEditBooking.js, Q: What base values are spread from `bookingDetail` into the form reset object? A: All top-level properties of `bookingDetail` (e.g., reservationId, userName, phone) are shallow-spread into `values`, ensuring any fields not explicitly remapped remain in sync."}
{"text":"File: AddOrEditBooking.js, Q: How is `amenityId` initialized for edit mode? A: `values.amenityId` is set directly to `bookingDetail.amenityId`, so the amenity selector displays the original amenity."}
{"text":"File: AddOrEditBooking.js, Q: How are the form’s date fields seeded on reset? A: `values.startDate` and `values.endDate` are set to `bookingDetail.startDate` and `bookingDetail.endDate`, preserving the original booking window."}
{"text":"File: AddOrEditBooking.js, Q: How does the reset payload preserve status selections? A: `values.status` and `values.paymentStatus` are assigned the full objects from `bookingDetail.status` and `bookingDetail.paymentStatus`, repopulating the dropdowns."}
{"text":"File: AddOrEditBooking.js, Q: How are simple scalar fields mapped? A: `purposeId`, `numberOfPerson`, and `remark` are copied from `bookingDetail.purposeId`, `.numberOfPerson`, and `.remark`, pre-filling those inputs with existing values."}
{"text":"File: AddOrEditBooking.js, Q: How is the booking type restored in the form? A: `values.bookingType` is set to an array containing the single `bookingDetail.bookingType` value, matching the form’s array-based radio-group control."}
{"text":"File: AddOrEditBooking.js, Q: How does the function handle existing file attachments? A: `values.files` is set to `bookingDetail.files` if present, or an empty array otherwise, populating the document picker with current attachments."}
{"text":"File: AddOrEditBooking.js, Q: How is the deposit price formatted for the form? A: `values.depositPrice` is an object with `rawValue: bookingDetail.totalDeposit` and `text: LocaleConfig.formatMoney(bookingDetail.totalDeposit)`, showing both numeric and localized text."}
{"text":"File: AddOrEditBooking.js, Q: How are company booking fields initialized? A: If `bookingDetail.bookingType === bookingTargets.company`, `values.company` is set to `{ companyName: bookingDetail.name, id: bookingDetail.companyId }` for the lazy dropdown."}
{"text":"File: AddOrEditBooking.js, Q: How are occupier booking fields initialized? A: For `bookingTargets.occupier`, `values.unit` is `{ fullUnitCode: bookingDetail.fullUnitId }`, and contact fields `contactName`, `contactEmail`, `contactPhone` are set from `bookingDetail.userName`, `.email`, and `.phone`."}
{"text":"File: AddOrEditBooking.js, Q: How is outsider booking data handled? A: If `bookingDetail.bookingType === bookingTargets.outsider`, `values.email` is set to the outsider’s email from `bookingDetail.email`."}
{"text":"File: AddOrEditBooking.js, Q: Why return an empty object when `isAddNew` or no `bookingDetail`? A: To prevent populating the form with undefined data in add mode or before the detail has loaded, leaving the initial defaults intact."}
{"text":"File: AddOrEditBooking.js, Q: How does the function ensure nested objects match form control shapes? A: It wraps scalar IDs in objects (e.g., `company:{id,…}`, `unit:{fullUnitCode}`) to match the expected value shapes of `FormLazyDropdown` and `FormSuggestionPicker`."}
{"text":"File: AddOrEditBooking.js, Q: How can you extend `getInitialValuesForUpdate` to include `purposeName`? A: After setting `purposeId`, add `values.purposeName = bookingDetail.purpose?.name` if the API returns that field, so the dropdown shows the label correctly."}
{"text":"File: AddOrEditBooking.js, Q: What would you change to prefill a custom `remark` field only for company bookings? A: Inside the `company` branch, set `values.remark = bookingDetail.companyRemark` or a conditional value based on booking type."}
{"text":"File: AddOrEditBooking.js, Q: How is immutability maintained when building `values`? A: Each conditional branch spreads the existing `values` object into a new object, avoiding mutation of the original `bookingDetail` or prior `values` object."}
{"text":"File: AddOrEditBooking.js, Q: How would you include an `emailAddress` field for company bookings? A: In the company-specific block, add `emailAddress: bookingDetail.companyEmail` to `values.company` or at top level, depending on form control shape."}
{"text":"File: AddOrEditBooking.js, Q: Why is the deposit mapping wrapped in a nested object instead of a simple number? A: Because the form uses a `FormMoneyInput` that expects an object with `rawValue` (number) and `text` (formatted string) to display currency."}
{"text":"File: AddOrEditBooking.js, Q: How does `getInitialValuesForUpdate` support the disabled form state? A: By pre-populating all fields with the original values, the disabled provider can still show the data correctly even when inputs are disabled."}
{"text":"File: AddOrEditBooking.js, Q: What is the purpose of the `calculateDepositPrice` function? A: To compute and update the booking deposit based on the selected time slots and the amenity’s predefined time-rule pricing."}
{"text":"File: AddOrEditBooking.js, Q: Why is `calculateDepositPrice` wrapped in `useCallback`? A: To memoize the function and ensure its identity only changes when the `slots` array changes, preventing unnecessary effect re-runs."}
{"text":"File: AddOrEditBooking.js, Q: Why does the function check `if (!amenityDetail) return;` at the start? A: To guard against running when the amenity’s detail (including pricing rules) hasn’t loaded yet, avoiding runtime errors."}
{"text":"File: AddOrEditBooking.js, Q: How are the checked slots determined? A: It filters `slots` for items where `slot.isCheck === true`, collecting only those selected by the user."}
{"text":"File: AddOrEditBooking.js, Q: Why does the function return early if `checkedSlots.length === 0`? A: Because no slots are selected, there is no basis for computing a deposit, so the deposit should remain unchanged."}
{"text":"File: AddOrEditBooking.js, Q: How are `startDateSlot` and `endDateSlot` chosen? A: `startDateSlot` is the `startTime` of the first checked slot; `endDateSlot` is the `endTime` of the last checked slot, representing the full booked period."}
{"text":"File: AddOrEditBooking.js, Q: How is the `dayName` determined and why is it needed? A: It uses `moment(startDateSlot).day()` to get the weekday index, then maps to a string (e.g., 'MONDAY'), matching `amenityTimeRules.numNextValidDate` for rule lookup."}
{"text":"File: AddOrEditBooking.js, Q: Why format times as `'HH:mm:ss'`? A: Because the amenity time rules store `startTime` and `endTime` strings in that exact format, enabling precise string equality matching."}
{"text":"File: AddOrEditBooking.js, Q: How does the code find the matching time-rule? A: It calls `amenityDetail.amenityTimeRules.find(...)`, comparing each rule’s `numNextValidDate`, `startTime`, and `endTime` to the computed day and time strings."}
{"text":"File: AddOrEditBooking.js, Q: What happens if no `matchingRule` is found? A: The function returns without calling `setValue`, leaving the deposit price unchanged; no user feedback is provided in this case."}
{"text":"File: AddOrEditBooking.js, Q: How is the new deposit price applied to the form? A: By calling `setValue('depositPrice', { rawValue: price, text: LocaleConfig.formatMoney(price) })`, updating the `depositPrice` field in React Hook Form."}
{"text":"File: AddOrEditBooking.js, Q: Why call `calculateDepositPrice` inside a `useEffect`? A: To re-run the calculation automatically whenever the function identity changes (i.e., when `slots` change), keeping the deposit in sync with the user’s selection."}
{"text":"File: AddOrEditBooking.js, Q: What dependency array is used for that `useEffect` and why? A: It depends on `[calculateDepositPrice]`, so the effect runs whenever the memoized function changes due to a change in `slots`."}
{"text":"File: AddOrEditBooking.js, Q: How could you modify the code to handle multiple pricing tiers per slot? A: Instead of finding a single `matchingRule`, iterate over all `checkedSlots` and sum each slot’s price, or apply different rules per slot and accumulate `rawValue`."}
{"text":"File: AddOrEditBooking.js, Q: How can you alert the user if no matching rule is found? A: Add an `else` after the `if (matchingRule)` block to call `Alert.alert(I18n.t('ERROR'), I18n.t('NO_PRICING_RULE_FOUND'))`."}
{"text":"File: AddOrEditBooking.js, Q: How would you unit-test `calculateDepositPrice`? A: Mock `amenityDetail.amenityTimeRules` with known rules and a sample `slots` array, call `calculateDepositPrice()`, and assert that `setValue` was called with the expected price."}
{"text":"File: AddOrEditBooking.js, Q: Why not include `amenityDetail` in the dependency array of `useCallback`? A: Because if rules change, recalculation should occur; you may add `amenityDetail` to dependencies to recalc when rules update, though initial code assumes rules static after load."}
{"text":"File: AddOrEditBooking.js, Q: How would you support variable-length slot selection (non-contiguous)? A: Compute deposit by summing each contiguous block’s matching rule price rather than only start/end, mapping each checked slot to a rule."}
{"text":"File: AddOrEditBooking.js, Q: What potential pitfalls exist with timezone differences? A: If `startDateSlot` includes timezone offset, `moment(day).day()` may differ; ensure both rule definitions and slot times use the same timezone context."}
{"text":"File: AddOrEditBooking.js, Q: How could you refactor to improve performance for large slot arrays? A: Precompute a lookup map from `amenityTimeRules` keyed by `dayName|startTime|endTime` to avoid an O(n) find on each calculation."}
{"text":"File: AddOrEditBooking.js, Q: How can you handle partial overlaps where selected slots don’t exactly match rule boundaries? A: Implement logic to find the nearest encompassing rule or split the selection into intervals matching available rules."}
{"text":"File: AddOrEditBooking.js, Q: How would you show a loading indicator while deposit calculation is running? A: Introduce a local `isCalculating` state, set it true at start of `calculateDepositPrice` and false after `setValue`, then display a spinner next to the deposit field."}
{"text":"File: AddOrEditBooking.js, Q: How can you ensure `calculateDepositPrice` doesn’t run too frequently on rapid slot toggles? A: Debounce the function call using `useDebouncedCallback` or throttle in the `useEffect` so updates pause briefly during rapid changes."}
{"text":"File: AddOrEditBooking.js, Q: Why might you move this logic into a custom hook? A: Encapsulating deposit calculation in `useDepositCalculator(slots, amenityTimeRules)` improves reusability and testability, decoupling it from the component’s UI code."}
{"text":"File: AddOrEditBooking.js, Q: What is the primary purpose of the `recurringBooking` function? A: To validate and prepare a recurring series of booking slots before actually saving them, by calling `validateRecurringBooking` and then showing a confirmation modal."}
{"text":"File: AddOrEditBooking.js, Q: Why is `values.recurrence` extracted into `rec` at the start? A: To simplify access to the user-defined recurrence rules (frequency, pattern, and `bookingTimes`) stored in the form’s `recurrence` field."}
{"text":"File: AddOrEditBooking.js, Q: Why does the code create `bookingObj` by spreading `bookingParams` and then adding `amenityId`? A: To combine the general payload fields (`bookingParams`) with the specific `amenityId` required by the recurring API without mutating the original `bookingParams` object."}
{"text":"File: AddOrEditBooking.js, Q: Why are `startDate` and `endDate` deleted from `bookingObj`? A: Because for recurring bookings, the API expects an array of individual `bookingTimes` rather than a single date range, so those fields must be removed to avoid payload conflicts."}
{"text":"File: AddOrEditBooking.js, Q: How is `bookingTimes` validated before proceeding? A: The function checks `if (!bookingTimes.length)`, and if empty, shows `Alert.alert(I18n.t('NO_RECURRING_SLOT_AVAILABLE'))` and returns early, preventing invalid API calls."}
{"text":"File: AddOrEditBooking.js, Q: Why map `rec.bookingTimes` into a new `bookingObj.bookingTimes` array? A: To extract only the necessary `startDate` and `endDate` properties for each slot, shaping the payload to the API’s expected format."}
{"text":"File: AddOrEditBooking.js, Q: What does `validateRecurringBooking` return, and how is its result used? A: It returns an object containing a status code, potentially `invalidSlots`, and other metadata; the code uses this to populate `bookingRequestData` with valid/invalid slot lists for user confirmation."}
{"text":"File: AddOrEditBooking.js, Q: How is `matchedStatus` determined? A: By finding the status object in `statusList` whose `statusCode` matches `res.status`, then using its `.name` for display in the confirmation modal."}
{"text":"File: AddOrEditBooking.js, Q: What fields are set on `bookingRequestData`? A: All returned fields from `res` plus `amenityName`, `requestedBy`, `createdDate`, `status` (human-readable), `validSlots`, and `invalidSlots` (defaulting to empty array if undefined)."}
{"text":"File: AddOrEditBooking.js, Q: Why include `amenityName` in `bookingRequestData`? A: To display the name of the booked amenity in the confirmation modal, helping users verify which resource they are booking."}
{"text":"File: AddOrEditBooking.js, Q: How is `requestedBy` determined? A: It uses either `bookingParams.name` (for occupier/company) or `bookingParams.email` (for outsider) to identify who initiated the booking."}
{"text":"File: AddOrEditBooking.js, Q: Why set `createdDate` to `new Date()`? A: To capture the timestamp when the user initiated the validation flow, and display it in the confirmation modal for context."}
{"text":"File: AddOrEditBooking.js, Q: How are `validSlots` initialized? A: They’re set to the original array of requested slots (`bookingObj.bookingTimes`), assuming the API will mark some invalid if conflicts exist."}
{"text":"File: AddOrEditBooking.js, Q: Why default `invalidSlots` to `res.invalidSlots || []`? A: To ensure `invalidSlots` is always defined as an array, avoiding null checks when rendering the warning message in the modal."}
{"text":"File: AddOrEditBooking.js, Q: What is the effect of `setConfirmationVisible(true)`? A: It opens the `<BookingConfirmation>` modal, allowing users to review and adjust the validated slots before final submission."}
{"text":"File: AddOrEditBooking.js, Q: How does error handling work in `recurringBooking`? A: The `try/catch` block catches API errors from `validateRecurringBooking` and shows an alert with `Alert.alert(I18n.t('ERROR'), error.message)` to inform the user."}
{"text":"File: AddOrEditBooking.js, Q: How could you unit-test `recurringBooking`? A: Mock `validateRecurringBooking` to return a sample response, call `recurringBooking` with stub `values` and `bookingParams`, and assert `setBookingRequestData` and `setConfirmationVisible(true)`."}
{"text":"File: AddOrEditBooking.js, Q: What happens if `validateRecurringBooking` rejects with an error? A: The `catch` block executes and shows an alert with the error message; `bookingRequestData` and the confirmation modal are not updated."}
{"text":"File: AddOrEditBooking.js, Q: How does the function ensure immutability of `bookingParams`? A: By spreading `bookingParams` into a new `bookingObj`, then deleting and adding fields on the copy, preserving the original object unmodified."}
{"text":"File: AddOrEditBooking.js, Q: Why not include `rec` and `bookingParams` in the dependency array of an effect? A: `recurringBooking` is called imperatively on submit rather than via an effect, so dependencies are managed by the call site rather than React’s effect system."}
{"text":"File: AddOrEditBooking.js, Q: How does `recurringBooking` integrate with the `onSave` flow? A: In `onSave`, if `formValues.recurrence` exists, it calls `await recurringBooking(formValues, payload)` and returns early, postponing the final API call until after user confirmation."}
{"text":"File: AddOrEditBooking.js, Q: What improvements could you make to `recurringBooking`? A: Add loading state during validation, debounce multiple clicks, surface detailed conflict reasons, and allow partial booking of valid slots automatically."}
{"text":"File: AddOrEditBooking.js, Q: How could you handle timezone consistency in recurring slots? A: Normalize `slot.startDate` and `slot.endDate` to a common timezone (using `moment.utc` or `moment.tz`) before mapping to the payload."}
{"text":"File: AddOrEditBooking.js, Q: How might you batch recurring validations to reduce API calls? A: If validating many recurrences, accumulate multiple `bookingTimes` into one API call as done, or throttle calls if user adjusts rules rapidly."}
{"text":"File: AddOrEditBooking.js, Q: How can you provide a retry option after a validation error? A: In the `catch` block, show an alert with “Retry” and call `recurringBooking(values, bookingParams)` again if the user chooses to retry."}
{"text":"File: AddOrEditBooking.js, Q: How would you integrate analytics into this flow? A: Track events like `validate_recurring_start`, `validate_recurring_success`, `validate_recurring_fail`, logging slot counts and durations for UX analysis."}
{"text":"File: AddOrEditBooking.js, Q: Why map `bookingTimes` into a minimal `{startDate,endDate}` shape? A: To reduce payload size and send only essential data to the API, avoiding extraneous fields that could cause validation errors."}
{"text":"File: AddOrEditBooking.js, Q: How could you improve user feedback when no slots are available? A: Instead of just an alert, display inline text in the form near the slot picker reading “No recurring slots available for selected pattern.”"}
{"text":"File: AddOrEditBooking.js, Q: What patterns are demonstrated by `recurringBooking`? A: Separation of concerns (validation vs. persistence), immutability (object spread), defensive checks (empty slots), and user confirmation before side effects."}
{"text":"File: AddOrEditBooking.js, Q: What is the role of the `handleConfirm` function? A: To finalize the recurring booking flow by fetching the latest form values, calling `onSave` with them, and then closing the confirmation modal (`setConfirmationVisible(false)`)."}
{"text":"File: AddOrEditBooking.js, Q: Why does `handleConfirm` call `formMethods.getValues()` instead of using a passed-in argument? A: To ensure it uses the most up-to-date form state (including any changes made in the confirmation modal) when re-entering the save logic."}
{"text":"File: AddOrEditBooking.js, Q: What is the first step inside `onSave`? A: Filter `formValues.files` to include only items with a `path` property (`const uploadFiles = formValues.files.filter(item => item.path)`), so only newly added local files are uploaded."}
{"text":"File: AddOrEditBooking.js, Q: How are `slotStartTime` and `slotEndTime` determined for new bookings? A: By finding the first and last checked slots (`formValues.slots.filter(e => e.isCheck)`), and extracting their `startTime` and `endTime` respectively."}
{"text":"File: AddOrEditBooking.js, Q: Why check `if (selectedSlots.length > 0)` before assigning `slotStartTime`/`slotEndTime`? A: To avoid undefined values when no slots are selected, preventing invalid dates in the payload."}
{"text":"File: AddOrEditBooking.js, Q: How is the base `payload` object constructed? A: By spreading `formValues`, then overriding/adding `amenityId`, `startDate`, `endDate`, `status` (statusCode), `bookingType`, `paymentStatus:null`, and the filtered `files` array."}
{"text":"File: AddOrEditBooking.js, Q: How does the code decide `startDate` and `endDate` for add vs. edit modes? A: If `isAddNew` is true, it uses `slotStartTime`/`slotEndTime`; otherwise it reuses `bookingDetail.startDate`/`bookingDetail.endDate` from the existing booking."}
{"text":"File: AddOrEditBooking.js, Q: Why is `paymentStatus` initially set to `null` in the payload? A: To ensure it’s only explicitly set when deposits apply (`amenityDetail.isUseDeposited`), avoiding sending an unintended default status."}
{"text":"File: AddOrEditBooking.js, Q: How and when is `paymentStatus` added to the payload? A: If `amenityDetail.isUseDeposited` is true, the code sets `payload.paymentStatus = formValues.paymentStatus.paymentStatusCode`, including it only when required."}
{"text":"File: AddOrEditBooking.js, Q: What additional fields are included for the 'occupier' booking type? A: `buildingId`, `unitId`, `fullUnitId`, `userId`, `name`, `userName`, `phone`, `email`, and `emailAddress`, all derived from `formValues.unit` and contact fields."}
{"text":"File: AddOrEditBooking.js, Q: Why duplicate `contactName` into both `name` and `userName`? A: To satisfy different API field expectations (e.g., `name` for display and `userName` for user identity) while preserving consistency."}
{"text":"File: AddOrEditBooking.js, Q: What logic handles the 'company' booking type? A: If `bookingType === bookingTargets.company`, it sets `payload.companyId`, `payload.name` (companyName), and `payload.email` (primaryEmail) from `formValues.company`."}
{"text":"File: AddOrEditBooking.js, Q: How does the code handle the 'outsider' booking type? A: By setting `payload.email = formValues.email`, since outsiders only need an email address to book."}
{"text":"File: AddOrEditBooking.js, Q: How are recurrence bookings integrated into `onSave`? A: If `formValues.recurrence` exists, `onSave` calls `await recurringBooking(formValues, payload)` and returns early, deferring the API call until after user confirmation."}
{"text":"File: AddOrEditBooking.js, Q: What does `await recurringBooking(...)` return, and why does `onSave` return immediately? A: It triggers the validation & confirmation modal flow; returning prevents the single-instance booking API call from running until the user confirms."}
{"text":"File: AddOrEditBooking.js, Q: How does `onSave` choose between `addBooking` and `updateBooking`? A: It checks `!isAddNew`: if true (edit mode), calls `updateBooking(payload)`; otherwise calls `addBooking(payload)` for new bookings."}
{"text":"File: AddOrEditBooking.js, Q: Why must `onSave` be `async`? A: To await the booking API call (`addBooking`/`updateBooking`) and to handle asynchronous recurrence flow, ensuring sequential execution and proper UI feedback."}
{"text":"File: AddOrEditBooking.js, Q: What happens after a successful booking API call? A: The code emits `DeviceEventEmitter.emit('UpdateListBooking')` to refresh other screens, then calls `navigation.goBack()` to close the form."}
{"text":"File: AddOrEditBooking.js, Q: How would you handle errors from `addBooking` or `updateBooking`? A: Wrap the API call in `try/catch`, display `Alert.alert(I18n.t('ERROR'), error.message)`, and avoid navigation/emitter on failure."}
{"text":"File: AddOrEditBooking.js, Q: Why is the event name `'UpdateListBooking'` emitted? A: To notify the booking list screen’s subscriber to reload its data, reflecting the new or updated booking immediately."}
{"text":"File: AddOrEditBooking.js, Q: How can you prevent duplicate submissions from rapid Save taps? A: Introduce an `isSubmitting` state to disable the Save button until the promise resolves or rejects."}
{"text":"File: AddOrEditBooking.js, Q: How could you refactor payload construction to improve maintainability? A: Extract a helper `buildBookingPayload(formValues, bookingDetail, isAddNew)` that returns the payload object, centralizing the mapping logic."}
{"text":"File: AddOrEditBooking.js, Q: How might you unit-test `onSave`? A: Mock `addBooking`/`updateBooking` and `recurringBooking`, call `onSave` with sample `formValues`, and assert the correct function is called with the expected payload and that emitter/navigation run."}
{"text":"File: AddOrEditBooking.js, Q: Why does `onSave` filter `files` by `item.path`? A: Because existing server files lack a local `path` property; filtering ensures only new local attachments are included for upload."}
{"text":"File: AddOrEditBooking.js, Q: How can you extend `onSave` to show a loading indicator? A: Set a local `isSaving` state to true before the API call, reset it in `finally`, and pass it to the Save button’s `loading` prop."}
{"text":"File: AddOrEditBooking.js, Q: What is the implication of directly mutating `payload` after spreading `formValues`? A: While spreading creates a shallow copy, further property assignments mutate the new object; consider using a fresh object literal for clarity and immutability."}
{"text":"File: AddOrEditBooking.js, Q: How would you centralize conditional field inclusion? A: Use a mapping object keyed by `bookingType` to specify which extra fields to add, reducing repetitive `if` blocks."}
{"text":"File: AddOrEditBooking.js, Q: Why is `navigation.goBack()` called only after `DeviceEventEmitter`? A: To ensure the list refresh event fires before the screen unmounts, so listeners can react before being torn down."}
{"text":"File: AddOrEditBooking.js, Q: How could you handle partial failures in recurring bookings (some slots invalid)? A: After user removes invalid slots and confirms, call `recurringBooking` again, then in the final API call handle any remaining failures with inline errors or retry options."}
{"text":"File: AddOrEditBooking.js, Q: How can you log the final payload for debugging? A: Insert a `console.debug('Booking payload:', payload)` before the API call, ensuring you remove or gate it behind a dev flag in production."}
{"text":"File: AddOrEditBooking.js, Q: What patterns does `onSave` demonstrate? A: Conditional logic based on mode and type, immutability via object spreading, early return for recurrence flow, and side-effects (API, event emission, navigation) after promise resolution."}
{"text":"File: AddOrEditBooking.js, Q: What is the role of the `handleConfirm` function? A: To finalize the recurring booking flow by fetching the latest form values, calling `onSave` with them, and then closing the confirmation modal (`setConfirmationVisible(false)`)."}
{"text":"File: AddOrEditBooking.js, Q: Why does `handleConfirm` call `formMethods.getValues()` instead of using a passed-in argument? A: To ensure it uses the most up-to-date form state (including any changes made in the confirmation modal) when re-entering the save logic."}
{"text":"File: AddOrEditBooking.js, Q: What is the first step inside `onSave`? A: Filter `formValues.files` to include only items with a `path` property (`const uploadFiles = formValues.files.filter(item => item.path)`), so only newly added local files are uploaded."}
{"text":"File: AddOrEditBooking.js, Q: How are `slotStartTime` and `slotEndTime` determined for new bookings? A: By finding the first and last checked slots (`formValues.slots.filter(e => e.isCheck)`), and extracting their `startTime` and `endTime` respectively."}
{"text":"File: AddOrEditBooking.js, Q: Why check `if (selectedSlots.length > 0)` before assigning `slotStartTime`/`slotEndTime`? A: To avoid undefined values when no slots are selected, preventing invalid dates in the payload."}
{"text":"File: AddOrEditBooking.js, Q: How is the base `payload` object constructed? A: By spreading `formValues`, then overriding/adding `amenityId`, `startDate`, `endDate`, `status` (statusCode), `bookingType`, `paymentStatus:null`, and the filtered `files` array."}
{"text":"File: AddOrEditBooking.js, Q: How does the code decide `startDate` and `endDate` for add vs. edit modes? A: If `isAddNew` is true, it uses `slotStartTime`/`slotEndTime`; otherwise it reuses `bookingDetail.startDate`/`bookingDetail.endDate` from the existing booking."}
{"text":"File: AddOrEditBooking.js, Q: Why is `paymentStatus` initially set to `null` in the payload? A: To ensure it’s only explicitly set when deposits apply (`amenityDetail.isUseDeposited`), avoiding sending an unintended default status."}
{"text":"File: AddOrEditBooking.js, Q: How and when is `paymentStatus` added to the payload? A: If `amenityDetail.isUseDeposited` is true, the code sets `payload.paymentStatus = formValues.paymentStatus.paymentStatusCode`, including it only when required."}
{"text":"File: AddOrEditBooking.js, Q: What additional fields are included for the 'occupier' booking type? A: `buildingId`, `unitId`, `fullUnitId`, `userId`, `name`, `userName`, `phone`, `email`, and `emailAddress`, all derived from `formValues.unit` and contact fields."}
{"text":"File: AddOrEditBooking.js, Q: Why duplicate `contactName` into both `name` and `userName`? A: To satisfy different API field expectations (e.g., `name` for display and `userName` for user identity) while preserving consistency."}
{"text":"File: AddOrEditBooking.js, Q: What logic handles the 'company' booking type? A: If `bookingType === bookingTargets.company`, it sets `payload.companyId`, `payload.name` (companyName), and `payload.email` (primaryEmail) from `formValues.company`."}
{"text":"File: AddOrEditBooking.js, Q: How does the code handle the 'outsider' booking type? A: By setting `payload.email = formValues.email`, since outsiders only need an email address to book."}
{"text":"File: AddOrEditBooking.js, Q: How are recurrence bookings integrated into `onSave`? A: If `formValues.recurrence` exists, `onSave` calls `await recurringBooking(formValues, payload)` and returns early, deferring the API call until after user confirmation."}
{"text":"File: AddOrEditBooking.js, Q: What does `await recurringBooking(...)` return, and why does `onSave` return immediately? A: It triggers the validation & confirmation modal flow; returning prevents the single-instance booking API call from running until the user confirms."}
{"text":"File: AddOrEditBooking.js, Q: How does `onSave` choose between `addBooking` and `updateBooking`? A: It checks `!isAddNew`: if true (edit mode), calls `updateBooking(payload)`; otherwise calls `addBooking(payload)` for new bookings."}
{"text":"File: AddOrEditBooking.js, Q: Why must `onSave` be `async`? A: To await the booking API call (`addBooking`/`updateBooking`) and to handle asynchronous recurrence flow, ensuring sequential execution and proper UI feedback."}
{"text":"File: AddOrEditBooking.js, Q: What happens after a successful booking API call? A: The code emits `DeviceEventEmitter.emit('UpdateListBooking')` to refresh other screens, then calls `navigation.goBack()` to close the form."}
{"text":"File: AddOrEditBooking.js, Q: How would you handle errors from `addBooking` or `updateBooking`? A: Wrap the API call in `try/catch`, display `Alert.alert(I18n.t('ERROR'), error.message)`, and avoid navigation/emitter on failure."}
{"text":"File: AddOrEditBooking.js, Q: Why is the event name `'UpdateListBooking'` emitted? A: To notify the booking list screen’s subscriber to reload its data, reflecting the new or updated booking immediately."}
{"text":"File: AddOrEditBooking.js, Q: How can you prevent duplicate submissions from rapid Save taps? A: Introduce an `isSubmitting` state to disable the Save button until the promise resolves or rejects."}
{"text":"File: AddOrEditBooking.js, Q: How could you refactor payload construction to improve maintainability? A: Extract a helper `buildBookingPayload(formValues, bookingDetail, isAddNew)` that returns the payload object, centralizing the mapping logic."}
{"text":"File: AddOrEditBooking.js, Q: How might you unit-test `onSave`? A: Mock `addBooking`/`updateBooking` and `recurringBooking`, call `onSave` with sample `formValues`, and assert the correct function is called with the expected payload and that emitter/navigation run."}
{"text":"File: AddOrEditBooking.js, Q: Why does `onSave` filter `files` by `item.path`? A: Because existing server files lack a local `path` property; filtering ensures only new local attachments are included for upload."}
{"text":"File: AddOrEditBooking.js, Q: How can you extend `onSave` to show a loading indicator? A: Set a local `isSaving` state to true before the API call, reset it in `finally`, and pass it to the Save button’s `loading` prop."}
{"text":"File: AddOrEditBooking.js, Q: What is the implication of directly mutating `payload` after spreading `formValues`? A: While spreading creates a shallow copy, further property assignments mutate the new object; consider using a fresh object literal for clarity and immutability."}
{"text":"File: AddOrEditBooking.js, Q: How would you centralize conditional field inclusion? A: Use a mapping object keyed by `bookingType` to specify which extra fields to add, reducing repetitive `if` blocks."}
{"text":"File: AddOrEditBooking.js, Q: Why is `navigation.goBack()` called only after `DeviceEventEmitter`? A: To ensure the list refresh event fires before the screen unmounts, so listeners can react before being torn down."}
{"text":"File: AddOrEditBooking.js, Q: How could you handle partial failures in recurring bookings (some slots invalid)? A: After user removes invalid slots and confirms, call `recurringBooking` again, then in the final API call handle any remaining failures with inline errors or retry options."}
{"text":"File: AddOrEditBooking.js, Q: How can you log the final payload for debugging? A: Insert a `console.debug('Booking payload:', payload)` before the API call, ensuring you remove or gate it behind a dev flag in production."}
{"text":"File: AddOrEditBooking.js, Q: What patterns does `onSave` demonstrate? A: Conditional logic based on mode and type, immutability via object spreading, early return for recurrence flow, and side-effects (API, event emission, navigation) after promise resolution."}
{"text":"File: AddOrEditBooking.js, Q: What does the `getTitle` function do? A: It returns the screen title based on mode: if `isAddNew` is true, it returns the localized string for 'ADD_BOOKING'; otherwise it returns 'EDIT_BOOKING', ensuring the header reflects whether the user is adding or editing a booking."}
{"text":"File: AddOrEditBooking.js, Q: How is `getTitle` used in the component? A: It’s passed to `<BaseLayout title={getTitle()} />`, dynamically setting the layout’s title prop so the UI header shows the correct label when the component renders."}
{"text":"File: AddOrEditBooking.js, Q: What triggers the `onAmenitySelect` callback? A: It’s called when the user chooses an amenity from `<SelectAmenityModal>`; `SelectAmenityModal`’s `onSelect={onAmenitySelect}` prop invokes it with the selected amenity object."}
{"text":"File: AddOrEditBooking.js, Q: What steps occur inside `onAmenitySelect`? A: It programmatically sets the form’s `amenityId` via `setValue`, fetches detailed amenity data by calling `getAmenityDetail(selectedAmenity.amenityId)`, and then closes the modal with `onCloseSelectAmenity`."}
{"text":"File: AddOrEditBooking.js, Q: How do `onShowSelectAmenity` and `onCloseSelectAmenity` manage the modal? A: They toggle local state `visibleSelectAmenity` to `true`/`false`, controlling whether `<SelectAmenityModal>` is rendered, enabling and disabling the amenity picker UI."}
{"text":"File: AddOrEditBooking.js, Q: Why call `getAmenityDetail` after setting `amenityId` in `onAmenitySelect`? A: To pre-load the full amenity metadata (rules, slots, remarks) necessary for the booking form immediately after selection, improving UX by reducing wait after navigation."}
{"text":"File: AddOrEditBooking.js, Q: How is `amenityRemark` derived and displayed? A: It checks if `amenityDetail.remarks` has entries, finds the remark whose `languageName` matches `languageId`, and extracts its `.value`; if none, defaults to an empty string, then displays it in a read-only `<FormInput>`."}
{"text":"File: AddOrEditBooking.js, Q: Why guard `_.size(amenityDetail?.remarks)` in `amenityRemark`? A: To ensure `amenityDetail.remarks` is a non-empty array before calling `.find`, preventing errors if `remarks` is undefined or empty."}
{"text":"File: AddOrEditBooking.js, Q: What is the purpose of the `displayStatus` useMemo? A: It filters out unwanted status options: in add mode (`isAddNew`), it removes 'CANCELED' and 'DECLINED' codes so new bookings can’t be created in those states; in edit mode, it returns the full `statusList`."}
{"text":"File: AddOrEditBooking.js, Q: Why memoize `displayStatus` with `useMemo`? A: To recompute the filtered status list only when `statusList` or `isAddNew` changes, avoiding unnecessary recalculation and re-renders on unrelated state updates."}
{"text":"File: AddOrEditBooking.js, Q: How is `displayStatus` used in the form? A: It’s passed as the `options` prop to the status `<FormDropdown>`, ensuring the dropdown shows only valid status choices based on the current mode."}
{"text":"File: AddOrEditBooking.js, Q: What would happen if `displayStatus` omitted the `isAddNew` check? A: In add mode, the dropdown would include 'CANCELED' and 'DECLINED' statuses, allowing users to set an invalid initial state, which could violate business rules."}
{"text":"File: AddOrEditBooking.js, Q: Why is `<FormCalendarPicker name=\"startEndDate\" />` rendered only when `isAddNew` is true? A: Because only new bookings allow the user to select a date; in edit mode the date is fixed and shown via `<InfoRow>` instead."}
{"text":"File: AddOrEditBooking.js, Q: What does `<AmenityButton amenity={amenityDetail} onPress={onShowSelectAmenity} disabled={!isAddNew} />` do? A: It displays the current amenity or a placeholder; when adding, tapping it opens the select-amenity modal, but in edit mode it’s disabled to prevent changing the amenity."}
{"text":"File: AddOrEditBooking.js, Q: How does `<FormSlotView>` integrate with add mode? A: It renders the slot picker (`name=\"slots\"`) with `numberSlot` computed from `amenityDetail.numOfExtendTimeSlot + 1`; its `onChange` callback also updates recurrence data if recurrence is active."}
{"text":"File: AddOrEditBooking.js, Q: Why wrap the slot picker and calendar in `{isAddNew && (...)}`? A: To ensure slot selection and date picking are only available when creating a new booking; editing cannot change times or dates."}
{"text":"File: AddOrEditBooking.js, Q: When is the `<TimeWrapper>` with `<InfoRow>`s rendered? A: Only when `!isAddNew` (edit mode); it shows the existing booking’s time range and date in read-only info rows with icons."}
{"text":"File: AddOrEditBooking.js, Q: How does the first `<InfoRow>` format booking times? A: It uses `formatDate(startDate, timeFormat)` and `formatDate(endDate, timeFormat)` to display “HH:mm – HH:mm” with a clock icon."}
{"text":"File: AddOrEditBooking.js, Q: What purpose does the second `<InfoRow>` serve? A: It displays the booking date formatted via `formatDate(startDate, dateFormat)` with a calendar icon, giving the user a quick date summary."}
{"text":"File: AddOrEditBooking.js, Q: Why is `<FormDropdown required options={displayStatus} name=\"status\" />` always rendered? A: Because every booking—new or existing—needs a status selection; in add mode to pick initial status, in edit to update status."}
{"text":"File: AddOrEditBooking.js, Q: Under what condition does the payment status dropdown render? A: When `amenityDetail.isUseDeposited` is true and either in add mode with status moved off REQUESTED or in edit mode with an existing paymentStatus, enforcing deposit logic only when relevant."}
{"text":"File: AddOrEditBooking.js, Q: What does `<FormRadioGroup name=\"bookingType\" />` control? A: It lets the user choose between occupier, company, or outsider booking types; disabled in edit mode to prevent changing the booking target after creation."}
{"text":"File: AddOrEditBooking.js, Q: How are occupier-specific fields conditionally rendered? A: When `bookingType === bookingTargets.occupier`, it shows a `<FormSuggestionPicker>` for unit selection and readonly contact info fields in a `<Box>`."}
{"text":"File: AddOrEditBooking.js, Q: Why use `<FormSuggestionPicker type={UNIT}>` for occupier? A: To allow users to search and pick a unit from company directory, setting contact details automatically via its `onChange` callback."}
{"text":"File: AddOrEditBooking.js, Q: How is the occupier’s name and contact info displayed? A: After unit selection, readonly `<FormInput>`s show contactName, and if allowed by `securitySetting.isShowEmailAndPhone`, contactEmail and contactPhone fields."}
{"text":"File: AddOrEditBooking.js, Q: How are company-specific fields rendered? A: When `bookingType === bookingTargets.company`, it shows a `<FormLazyDropdown>` that fetches companies on demand, enabling selection from a large list."}
{"text":"File: AddOrEditBooking.js, Q: Why is `<FormLazyDropdown>` used for companies rather than a simple dropdown? A: To support server-side pagination and search in large company lists, improving performance and UX."}
{"text":"File: AddOrEditBooking.js, Q: How does outsider booking differ in the UI? A: When `bookingType === bookingTargets.outsider`, it displays a `<FormInput>` for an email address, required only for outsiders."}
{"text":"File: AddOrEditBooking.js, Q: Why is outsider email input conditionally editable? A: It’s editable in add mode (`isAddNew`) to allow entry; in edit mode it’s disabled to prevent changing the outsider’s contact after booking creation."}
{"text":"File: AddOrEditBooking.js, Q: What does `<FormDropdown name=\"purposeId\" options={bookingPurposes} />` accomplish? A: It allows the user to select a booking purpose from the list loaded on mount, providing contextual metadata for the booking."}
{"text":"File: AddOrEditBooking.js, Q: Under what condition is `<BookingRecurring>` rendered? A: When the amenity allows recurring (`amenityDetail.isAllowRecurring`) and the component is in add mode (`!isEdit`), enabling the user to configure repeat bookings."}
{"text":"File: AddOrEditBooking.js, Q: How does the recurring component communicate back to the parent? A: Via its `onSubmitForm` prop, passing the recurrence object to `setValue('recurrence', rec)`, and `onRemove` to clear it when toggled off."}
{"text":"File: AddOrEditBooking.js, Q: What data is passed as `reservation` to `<BookingRecurring>`? A: The start and end times of the currently selected slots, used by the recurrence UI to anchor the pattern generation."}
{"text":"File: AddOrEditBooking.js, Q: How is the `numberOfPerson` field implemented? A: As a `<FormInput>` with `keyboardType=\"number-pad\"`, allowing optional entry of how many people will attend the booking."}
{"text":"File: AddOrEditBooking.js, Q: When is `<FormMoneyInput name=\"depositPrice\" />` rendered? A: Only when `depositPrice.rawValue > 0`, showing the computed deposit amount in a disabled money input after slot selection."}
{"text":"File: AddOrEditBooking.js, Q: Why disable the deposit price input? A: Because deposit is calculated automatically based on slots and amenity rules, users cannot manually override it."}
{"text":"File: AddOrEditBooking.js, Q: How and why is `amenityRemark` displayed? A: If non-empty, it’s shown in a readonly `<FormInput>` labeled “REMARK” to convey static policy or instructions defined per amenity."}
{"text":"File: AddOrEditBooking.js, Q: What is the purpose of `<FormInput name=\"remark\" multiline />`? A: To allow users to add free-text comments or descriptions about the booking, enhancing context for approvers."}
{"text":"File: AddOrEditBooking.js, Q: How does `<FormDocumentPicker name=\"files\" />` integrate file uploads? A: It provides a UI for attaching documents; in edit mode it’s pre-populated with existing files via an effect, and in add mode users can add new attachments."}
{"text":"File: AddOrEditBooking.js, Q: When is `<BookingPolicyRules>` rendered? A: Whenever `amenityDetail` is truthy, showing policy rules and related documents to ensure users understand booking constraints before saving."}
{"text":"File: AddOrEditBooking.js, Q: What role does `<SelectAmenityModal>` play at the bottom of the JSX? A: It renders the amenity selection modal when `visibleSelectAmenity` is true, allowing users to pick an amenity to book."}
{"text":"File: AddOrEditBooking.js, Q: Why render `<FloatingConversation>` only in edit mode? A: To provide access to the chat widget for existing bookings (identified by `bookingDetail.guid`), enabling discussion after creation; it’s hidden for new bookings."}
{"text":"File: AddOrEditBooking.js, Q: How is `<BookingConfirmation>` integrated? A: It’s rendered unconditionally but shown based on `confirmationVisible`, displaying the recurring confirmation modal when needed."}
{"text":"File: AddOrEditBooking.js, Q: Why wrap the entire form in `<LoaderContainer isLoading={!amenityDetail}>`? A: To show a loading spinner until `amenityDetail` data is available, preventing incomplete UI rendering and user interaction before data loads."}
{"text":"File: AddOrEditBooking.js, Q: What does `<FormDisabledProvider disabled={isDisabledForm}>` do? A: It disables all nested form controls when `isDisabledForm` is true (e.g., for canceled/declined bookings), preventing further edits."}
{"text":"File: AddOrEditBooking.js, Q: How does `isDisabledForm` get set? A: In the bookingDetail effect, if the status code is `CANCELED` or `DECLINED`, `setIsDisabledForm(true)` disables the form when the booking is closed."}
{"text":"File: AddOrEditBooking.js, Q: Why nest `<FormProvider {...formMethods}>` inside `<FormDisabledProvider>`? A: So that disabled state and form context propagate to all form elements, centralizing state management and interactivity control."}
{"text":"File: AddOrEditBooking.js, Q: How is the Save button configured in `<BaseLayout>`? A: It’s provided via `bottomButtons` prop with title “COMMON_SAVE”, type “primary”, `onPress={handleSubmit(onSave)}`, and `disabled={isDisabledForm}` to enforce validation and disable in closed states."}
{"text":"File: AddOrEditBooking.js, Q: Why use `handleSubmit(onSave)` rather than calling `onSave` directly? A: `handleSubmit` runs validation via React Hook Form before calling `onSave`, preventing submission of invalid data."}
{"text":"File: AddOrEditBooking.js, Q: What styling does `containerStyle={{ backgroundColor:'white' }}` on `<BaseLayout>` provide? A: It ensures the screen background is white, matching design guidelines and improving readability against form content."}
{"text":"File: AddOrEditBooking.js, Q: How does `<AwareScrollView>` enhance the form? A: It adjusts its layout to avoid being obscured by the on-screen keyboard, improving usability on mobile devices when filling in fields."}
{"text":"File: AddOrEditBooking.js, Q: Why wrap the form in a scroll view? A: To allow users to scroll through long forms on smaller screens, ensuring all fields remain accessible even on low-resolution devices."}
{"text":"File: AddOrEditBooking.js, Q: How might you add a footer note under the Save button? A: Extend `bottomButtons` prop array with an additional element of type “text” or use `<FooterComponent>` below `<BaseLayout>` children to display static guidance."}
{"text":"File: AddOrEditBooking.js, Q: What accessibility considerations are present in this JSX? A: Components like `<FormInput>`, `<FormDropdown>`, and buttons should include `accessibilityLabel` props; `<TimeWrapper>` icons use semantic `name` attributes for screen readers."}
{"text":"File: AddOrEditBooking.js, Q: How could you refactor this return block to improve readability? A: Split sections into smaller components (e.g., `<BookingFormFields />`, `<BookingSlotSection />`, `<BookingMetaFields />`) to reduce JSX nesting and improve maintainability."}
{"text":"File: AddOrEditBooking.js, Q: How can you enable test IDs for automated testing? A: Add `testID` props to key components (e.g., Save button, slot view, purpose dropdown) to facilitate E2E test selectors in Detox or Appium."}
{"text":"File: AddOrEditBooking.js, Q: How would you conditionally hide the document picker? A: Wrap `<FormDocumentPicker>` in `{!isEdit && <FormDocumentPicker ... />}` to only allow attachments on new bookings, if business rules require."}
{"text":"File: AddOrEditBooking.js, Q: What best practice does this JSX illustrate? A: Conditional rendering based on mode and data, centralized form state via React Hook Form, and UI gating via providers (loader, disabled), resulting in a robust, user-friendly booking form."}