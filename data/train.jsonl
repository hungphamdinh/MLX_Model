{"text":"File: Booking.js, Q: What does `useBooking()` provide to the Booking screen? A: It returns booking-related state (`statusList`, `paymentStatusList`, `amenitiesFilter`, `amenityList`, `list`) and actions (`filterBookings`, `getBookingStatus`, `getPaymentStatus`, `getAmenities`, `getAmenityDetail`) for populating filters and loading the list."}
{"text":"File: Booking.js, Q: Why call `getBookingStatus`, `getPaymentStatus`, and `getAmenities` in the first `useEffect`? A: To preload all dropdown and filter data (statuses, payment statuses, amenity options) once on mount so the filter UI is ready before any searches."}
{"text":"File: Booking.js, Q: What is the shape and purpose of `defaultFilter`? A: It defines the initial filter state—default date range, empty status/payment/amenity arrays, no expired items, and onlyActiveAmenity turned on—so the list starts with sensible defaults."}
{"text":"File: Booking.js, Q: How does the `filters` object configure the `<Filter>` component? A: It maps each filter key to its UI props: titles, whether multi-select, available options, which field to use as the value (`valKey`), and custom dropdown settings."}
{"text":"File: Booking.js, Q: Why does `amenityIds` use `FilterTypes.DROPDOWN` and `dropdownProps.showSearchBar`? A: Because the amenities list can be large; a searchable dropdown improves UX by letting users quickly find the amenity they want to filter by."}
{"text":"File: Booking.js, Q: What’s the role of `multipleOptionValue`? A: It centralizes the two boolean filter toggles (`onlyActiveAmenity`, `isIncludeExpired`) so both the filter state and UI options reference the same constants."}
{"text":"File: Booking.js, Q: How do `bookingFilter` and `selectedFilter` differ? A: `bookingFilter` holds the current filter state; `selectedFilter` is what’s applied to the list. They start the same, but only when the user “applies” a filter does `selectedFilter` update and trigger data reload."}
{"text":"File: Booking.js, Q: Why is `setSelectedFilter = setBookingFilter` used? A: It looks like a typo: it assigns the setter for `bookingFilter` to `setSelectedFilter`. It should likely be `useState(bookingFilter)` without the `=` alias."}
{"text":"File: Booking.js, Q: How does the text search integrate with filtering? A: The `textSearch` state is updated via `onTextSearchChange`, then included in `getList` params alongside `selectedFilter` to filter by both keyword and UI-selected criteria."}
{"text":"File: Booking.js, Q: What triggers the second `useEffect` that calls `getList(1)`? A: Any change to `textSearch` or `selectedFilter` causes a fresh query of the first page of results, updating the list reactively as the user types or applies new filters."}
{"text":"File: Booking.js, Q: Why does the third `useEffect` subscribe to `'UpdateListBooking'`? A: To respond to external events (e.g. after adding/editing a booking) by reloading the list, keeping the UI in sync across screens."}
{"text":"File: Booking.js, Q: What does the `getList` function do? A: It combines pagination, the current search text, and filter state (with date range converted to ISO strings and boolean flags derived from `multipleOptions`), then calls `filterBookings` to fetch data."}
{"text":"File: Booking.js, Q: How are `isIncludeExpired` and `onlyActiveAmenity` derived? A: From whether their values appear in `filter.multipleOptions`; if absent, they’re passed as `null` to the API to disable that toggle."}
{"text":"File: Booking.js, Q: What’s the significance of spreading `...selectedFilter` into `filterParams`? A: It ensures any filter keys the UI doesn’t explicitly re-map (like `statusIds` or `amenityIds`) get passed through untouched to the API call."}
{"text":"File: Booking.js, Q: Why convert `dateRange.fromDate`/`toDate` with `convertDate.stringToISOString`? A: To send the API a standardized ISO date string, rather than the UI’s locale-formatted date, preventing backend parsing issues."}
{"text":"File: Booking.js, Q: How does `onApplyFilter` work? A: It receives the new filter object from `<Filter>` and calls `setSelectedFilter`, which then triggers the second effect to reload the list."}
{"text":"File: Booking.js, Q: What happens when the Add button is pressed (`onBtAddPress`)? A: It sets `visibleSelectAmenity` to `true`, which opens the `<SelectAmenityModal>` so the user can choose an amenity before creating a new booking."}
{"text":"File: Booking.js, Q: How does `onAmenitySelect` bridge list→detail flow? A: After picking an amenity, it closes the modal, fetches its detail via `getAmenityDetail`, then navigates to the add-booking screen so the new form is preloaded with that amenity."}
{"text":"File: Booking.js, Q: Why pass `amenityList` to `<SelectAmenityModal>`? A: So the modal shows all amenities fetched earlier (via `getAmenities`) as selection options, enabling the user to choose one for booking creation."}
{"text":"File: Booking.js, Q: How is pagination wired up in `AppList`? A: The `list` object from context supplies `data`, `isRefresh`, `isLoadMore`, `currentPage`, `totalPage`, and `loadData(page)` calls `getList(page)` to fetch additional pages as the user scrolls."}
{"text":"File: Booking.js, Q: Why do we call `getBookingStatus()`, `getPaymentStatus()`, and `getAmenities()` inside a `useEffect` with an empty dependency array? A: To fetch all lookup data (booking statuses, payment statuses, and amenity options) exactly once when the component mounts, ensuring the filter UI has its dropdowns populated before the user interacts."}
{"text":"File: Booking.js, Q: What would happen if we omitted the empty array `[]` from the first `useEffect`? A: Without `[]`, the effect would run on every render, repeatedly refetching the same lookup data and causing unnecessary network traffic and UI thrashing."}
{"text":"File: Booking.js, Q: Why do we call `getList(1)` in a separate `useEffect` that depends on `[textSearch, selectedFilter]`? A: To reload the first page of bookings whenever the user updates the search text or applies new filter criteria, keeping the displayed list in sync with user input."}
{"text":"File: Booking.js, Q: Why do we pass `1` as the page argument to `getList` in the second effect? A: Because when search text or filters change, we always want to show results starting from page 1 rather than preserving the old scroll position or pagination state."}
{"text":"File: Booking.js, Q: What is the role of the third `useEffect` that listens for `'UpdateListBooking'` events? A: It subscribes to a global event emitter so that whenever a booking is added or edited elsewhere, the list refreshes automatically by calling `getList(1, textSearch, selectedFilter)`."}
{"text":"File: Booking.js, Q: Why do we return a cleanup function that calls `subscriber.remove()` in the third `useEffect`? A: To unsubscribe from the `UpdateListBooking` event when the component unmounts, preventing memory leaks and stray callbacks triggering on an unmounted component."}
{"text":"File: Booking.js, Q: Why do we re‐call `getList(1, textSearch, selectedFilter)` inside the event listener rather than directly reusing `getList(1)`? A: Because we need to preserve the current `textSearch` and `selectedFilter` values when refreshing the list, so passing them explicitly ensures the reload uses the latest criteria."}
{"text":"File: Booking.js, Q: Should `textSearch` and `selectedFilter` be included in the dependency array of the third `useEffect`? A: No—this effect only needs to be set up once on mount to subscribe to the event. The listener’s callback captures the latest values via closure every time it runs."}
{"text":"File: Booking.js, Q: What potential bug could arise if we forgot the cleanup in the third `useEffect`? A: Without cleanup, multiple listeners would accumulate on repeated mounts (e.g. during Hot Reload), causing duplicate fetches and unexpected UI behavior."}
{"text":"File: Booking.js, Q: How could you debounce calls to `getList` when `textSearch` changes rapidly? A: Wrap the `getList(1)` call in a debounce (e.g. using `lodash.debounce`) inside the second `useEffect` so that rapid keystrokes wait until the user pauses typing before fetching."}
{"text":"File: Booking.js, Q: Why separate concerns into three distinct effects rather than combining them? A: Each effect has a single responsibility—one for initial lookups, one for reactive search/filter changes, and one for external event subscriptions—making the code clearer and easier to maintain."}
{"text":"File: Booking.js, Q: How would you test that the first `useEffect` is called only once? A: In a unit test, mock the hook’s context methods and assert that `getBookingStatus`, `getPaymentStatus`, and `getAmenities` are each called exactly once after mounting and not on subsequent renders."}
{"text":"File: Booking.js, Q: What is the advantage of calling `getList(1)` rather than `filterBookings()` directly in the second effect? A: `getList` centralizes parameter construction (pagination, date conversion, toggles), ensuring all calls—manual or automatic—use the same logic pipeline before invoking `filterBookings`."}
{"text":"File: Booking.js, Q: How could you modify the third effect to listen to multiple event types? A: Create multiple subscribers inside the same `useEffect` (e.g. for `'UpdateListBooking'` and `'DeleteBooking'`), or use `DeviceEventEmitter.addListener` for each event and clean each up in the returned function."}
{"text":"File: Booking.js, Q: What pattern does the third `useEffect` illustrate? A: It demonstrates the “subscribe/unsubscribe” pattern in React—setting up an external listener on mount and tearing it down on unmount to manage side‐effects cleanly."}
{"text":"File: Booking.js, Q: What is the purpose of `onCloseSelectAmenity`? A: It hides the `<SelectAmenityModal>` by setting `visibleSelectAmenity` to `false`, closing the amenity picker UI without side effects."}
{"text":"File: Booking.js, Q: Why does `onAmenitySelect` call `setVisibleSelectAmenity(false)` before other actions? A: To immediately close the modal in the UI, ensuring the next actions (fetching details and navigation) happen on the main screen without overlay interference."}
{"text":"File: Booking.js, Q: What does `getAmenityDetail(amenity.amenityId)` achieve in `onAmenitySelect`? A: It preloads the selected amenity’s full details (rules, remarks) into context so the add-booking screen is populated with the correct data on arrival."}
{"text":"File: Booking.js, Q: Why is `NavigationService.navigate('addBooking')` called after `getAmenityDetail`? A: To move the user to the booking creation screen once the amenity detail has been queued for loading, so the form can initialize with that amenity."}
{"text":"File: Booking.js, Q: Should `onAmenitySelect` `await` `getAmenityDetail` before navigating? A: Possibly—if the add-booking screen requires the detail immediately on mount, awaiting ensures data is ready; otherwise navigation may race ahead causing a loading state."}
{"text":"File: Booking.js, Q: What could go wrong if `setVisibleSelectAmenity(false)` were omitted in `onAmenitySelect`? A: The modal would remain open behind the new screen or briefly flash, creating a confusing UI or blocking interaction on the add-booking screen."}
{"text":"File: Booking.js, Q: How would you unit-test `onAmenitySelect`? A: Mock `getAmenityDetail` and `NavigationService.navigate`, call `onAmenitySelect({ amenityId: '123' })`, then assert `setVisibleSelectAmenity(false)`, `getAmenityDetail('123')`, and `navigate('addBooking')` are called in order."}
{"text":"File: Booking.js, Q: Why is `onAmenitySelect` declared `async` even though it doesn’t `await`? A: It likely anticipated awaiting an async fetch (`getAmenityDetail`), but currently `async` is unnecessary and could be removed until awaiting is implemented."}
{"text":"File: Booking.js, Q: How could you handle errors from `getAmenityDetail` in `onAmenitySelect`? A: Wrap the call in `try/catch`, show an alert on failure, and only navigate on success, preventing navigation when detail loading fails."}
{"text":"File: Booking.js, Q: What UX improvement could follow `NavigationService.navigate`? A: Display a loading spinner or skeleton on the add-booking screen so the user sees progress while amenity details load asynchronously."}
{"text":"File: Booking.js, Q: Why group `onCloseSelectAmenity` and `onAmenitySelect` in the same component? A: They share the modal’s `visible` state logic; one handles cancel, the other handles confirm, keeping modal control localized and consistent."}
{"text":"File: Booking.js, Q: How would you refactor `onAmenitySelect` to avoid race conditions? A: Chain the calls: `await getAmenityDetail(...)` then `setVisibleSelectAmenity(false)` then `navigate`, ensuring each step completes before the next begins."}
{"text":"File: Booking.js, Q: What pattern does `onAmenitySelect` illustrate? A: It follows the “close→fetch→navigate” pattern: dismiss the modal, fetch required data, then route to the next screen in sequence."}
{"text":"File: Booking.js, Q: How can you debounce repeated amenity selections? A: Disable the select button after first tap or wrap `onAmenitySelect` in a debounce so repeated taps within a short window are ignored."}
{"text":"File: Booking.js, Q: How would you extract shared logic between these handlers into a custom hook? A: Create `useSelectAmenity(onSelect)` hook that returns `{ visible, open, close, select }`, centralizing modal control and selection side effects."}
{"text":"File: Booking.js, Q: What does `const { data, isRefresh, isLoadMore, currentPage, totalPage } = list;` accomplish? A: It destructures the `list` object from context into pagination and state variables—`data` holds the current page’s items, `isRefresh` and `isLoadMore` signal loading states, and `currentPage`/`totalPage` track page numbers for infinite scroll."}
{"text":"File: Booking.js, Q: What are the default values for the parameters of `getList`? A: `page` defaults to 1, `keyword` to the current `textSearch` state, and `filter` to the applied `selectedFilter` object, ensuring a sane fallback when values aren’t explicitly passed."}
{"text":"File: Booking.js, Q: How does `getList` extract date boundaries from the filter? A: It reads `fromDate` and `toDate` from `filter.dateRange`, then conditionally transforms them with `convertDate.stringToISOString` if they exist, preparing ISO strings for the API."}
{"text":"File: Booking.js, Q: Why is `|| null` used when computing `isIncludeExpired` and `onlyActiveAmenity`? A: Because the API likely expects `null` instead of `false` to signify an inactive toggle; `includes(...) || null` yields `true` or `null`, never `false`."}
{"text":"File: Booking.js, Q: What does `filter.multipleOptions.includes(multipleOptionValue.isIncludeExpired)` check? A: It determines if the “Include Expired” toggle is active by looking for its constant in the `multipleOptions` array, driving the API’s `isIncludeExpired` flag."}
{"text":"File: Booking.js, Q: Why spread `...selectedFilter` into `filterParams`? A: To carry through any remaining filter keys (like `statusIds`, `paymentStatusIds`, `amenityIds`) untouched, so the API call includes all current filter criteria without manual remapping."}
{"text":"File: Booking.js, Q: What additional key is added to `filterParams` beyond the spread? A: A `sorting: 'createdAt desc'` property, ensuring the results come back ordered by creation date descending regardless of UI state."}
{"text":"File: Booking.js, Q: Why is date conversion applied only if `fromDate`/`toDate` are truthy? A: To prevent converting undefined values and accidentally sending an invalid ISO string; the `&&` short-circuits to `false`, leaving the key undefined in the payload."}
{"text":"File: Booking.js, Q: What role does `PAGE_SIZE` play in the API call? A: It specifies how many items to fetch per page, enabling consistent pagination behavior across calls to `filterBookings`."}
{"text":"File: Booking.js, Q: How does `filterBookings` use the object passed to it? A: It likely triggers a data fetch with the given params—page number, page size, keyword, date range, toggles, sorting, and other filter arrays—updating the `list` state accordingly."}
{"text":"File: Booking.js, Q: Why does `getList` accept `keyword` and `filter` as arguments? A: For flexibility: it can be called with different search terms or filter sets, not just the latest state, supporting both initial loads and programmatic refreshes."}
{"text":"File: Booking.js, Q: How would you modify `getList` to handle multi-day ranges? A: Allow `toDate` to differ from `fromDate`—already handled by the code—so no change needed; the API will return slots between those ISO strings when both are defined."}
{"text":"File: Booking.js, Q: What happens if `filter.dateRange` is empty? A: `fromDate` and `toDate` become `undefined`, so those keys aren’t included in `filterParams`, and the API interprets their absence as “no date filtering.”"}
{"text":"File: Booking.js, Q: How can you unit-test `getList` logic? A: Stub `convertDate.stringToISOString` and `filterBookings`, call `getList` with sample inputs, and assert `filterBookings` was called with correct page, pageSize, keyword, and a `filterParams` object matching expectations."}
{"text":"File: Booking.js, Q: Why build `filterParams` separately before calling `filterBookings`? A: To isolate transformation logic (date conversion, toggle mapping) from the API call, improving readability and testability."}
{"text":"File: Booking.js, Q: How would you extend `getList` to include a custom sort field? A: Add a `sortBy` parameter and include `filterParams.sorting = `${sortBy} ${sortOrder}`` before calling `filterBookings`."}
{"text":"File: Booking.js, Q: What pattern does `getList` illustrate? A: The “parameter normalization” pattern: accept raw state (UI values), normalize them into API-friendly types, then execute the fetch via a context action."}
{"text":"File: Booking.js, Q: How does `getList` integrate with the `useEffect` hooks above? A: One effect watches `[textSearch, selectedFilter]` and calls `getList(1)` whenever search or filter changes; another effect subscribes to external events to re-trigger `getList` on demand."}
{"text":"File: Booking.js, Q: Why not call `filterBookings` directly in the `useEffect`? A: Because `getList` encapsulates all necessary parameter logic; calling `getList` avoids duplication and keeps the effect concise (`getList(1)`)."}
{"text":"File: Booking.js, Q: What does `onApplyFilter` do when called? A: It updates the `selectedFilter` state with the new filter object, which then triggers the `useEffect` watching `[textSearch, selectedFilter]` to reload the booking list."}
{"text":"File: Booking.js, Q: Why separate `bookingFilter` and `selectedFilter` in state? A: To allow users to modify filters (`bookingFilter`) without immediately applying them, and only when `onApplyFilter` calls `setSelectedFilter` does the list refresh with the new criteria."}
{"text":"File: Booking.js, Q: How is `onBtAddPress` connected to the UI? A: It’s passed as the `onBtAddPress` prop to `<BaseLayout>`, so tapping the Add button toggles `visibleSelectAmenity` to `true`, opening the amenity selection modal."}
{"text":"File: Booking.js, Q: What is the effect of `setVisibleSelectAmenity(true)` in `onBtAddPress`? A: It renders `<SelectAmenityModal>` by setting its `visible` prop to true, allowing the user to choose an amenity before creating a new booking."}
{"text":"File: Booking.js, Q: How does `onTextSearchChange` integrate with list filtering? A: It updates the `textSearch` state on each keystroke, which the `[textSearch, selectedFilter]` effect listens to and calls `getList(1)`, performing a live search."}
{"text":"File: Booking.js, Q: Why not debounce `onTextSearchChange` by default? A: Without debounce, every character triggers a fetch; you could wrap `setTextSearch` or the effect in a `debounce` to reduce network churn during fast typing."}
{"text":"File: Booking.js, Q: What does `gotoDetail(item)` accomplish? A: It uses `NavigationService.navigate('editBooking', { id: item.reservationId })` to route the user to the booking edit screen, passing along the selected reservation’s ID."}
{"text":"File: Booking.js, Q: Why pass `reservationId` as `id` in `gotoDetail`? A: Because the edit form expects a route parameter named `id` to fetch and populate the existing booking details via `getBookingDetail(id)` in the destination screen."}
{"text":"File: Booking.js, Q: How would you unit-test the `gotoDetail` function? A: Mock `NavigationService.navigate`, call `gotoDetail({ reservationId: 'abc' })`, and assert that `navigate` was called once with arguments `('editBooking', { id: 'abc' })`."}
{"text":"File: Booking.js, Q: What potential bug could occur in `gotoDetail`? A: If `item.reservationId` is undefined or null, navigation may break; you could guard with `if (!item.reservationId) return;` to prevent invalid navigation."}
{"text":"File: Booking.js, Q: How could you refactor these handlers to use `useCallback`? A: Wrap each in `useCallback` with appropriate dependencies (e.g. `onApplyFilter = useCallback(value => setSelectedFilter(value), [])`) to preserve stable references and avoid unnecessary re-renders."}
{"text":"File: Booking.js, Q: What accessibility or testing props might you add to these handlers? A: Attach `testID` props to the Add button (`onBtAddPress`) and the search input (`onTextSearchChange`), and use `accessibilityLabel` on filter apply actions to support E2E tests and screen readers."}
{"text":"File: Booking.js, Q: What is the role of the `renderItem` function? A: It returns an `<ItemBooking>` component for each booking entry, passing the item data and wiring its `onPress` to navigate to the detail view via `gotoDetail(item)`."}
{"text":"File: Booking.js, Q: Why does `renderItem` accept `item` directly rather than an object? A: It’s a helper that unwraps the booking object for clarity; the `AppList` adapter destructures `({item})` and calls `renderItem(item)` to separate list rendering from item formatting."}
{"text":"File: Booking.js, Q: How does the `keyExtractor` prop improve list performance? A: It returns a stable string key (`${item.id}`) for each item, enabling React to efficiently track list items and minimize re-renders when items change."}
{"text":"File: Booking.js, Q: Why interpolate `item.id` into a template string in `keyExtractor`? A: To ensure the key is always a string—React requires string keys, and interpolation handles numeric or mixed IDs uniformly."}
{"text":"File: Booking.js, Q: What does the `loadData` function prop do in `listProps`? A: It defines how to fetch more pages: when `AppList` needs page N, it calls `getList(page)`, centralizing pagination logic."}
{"text":"File: Booking.js, Q: How are the `isRefresh` and `isLoadMore` flags used by `AppList`? A: They signal loading states—`isRefresh` for pull-to-refresh and `isLoadMore` for infinite-scroll loading—so the list shows appropriate spinners."}
{"text":"File: Booking.js, Q: What information do `currentPage` and `totalPage` supply? A: They tell `AppList` where the user is in pagination and when to stop loading more, preventing unnecessary fetches beyond the last page."}
{"text":"File: Booking.js, Q: How does passing `data` to `AppList` work? A: `data` is the array of booking items; `AppList` iterates over it, using `renderItem` and `keyExtractor` to render each entry."}
{"text":"File: Booking.js, Q: Why include `iconName: icons.jobRequestEmpty` in `listProps`? A: To display a placeholder icon in `AppList` when `data` is empty, improving the empty-state UX."}
{"text":"File: Booking.js, Q: How does `<Filter>` integrate into the layout? A: Placed above `AppList`, it lets users adjust `filters` and triggers `onCompleted` or `onSearch`, which update state and refresh `listProps.data`."}
{"text":"File: Booking.js, Q: What do `showBell` and `showAddButton` props on `<BaseLayout>` control? A: They conditionally render a notifications bell icon and an Add button in the header, enabling quick access to booking creation and alerts."}
{"text":"File: Booking.js, Q: Why is `<AppList {...listProps} />` spread with `...listProps`? A: So all required list configuration (data, loading flags, render functions, pagination) is passed cleanly without repetitive prop definitions."}
{"text":"File: Booking.js, Q: How does the `onPress` handler in `renderItem` work? A: It invokes `gotoDetail(item)`, which calls `NavigationService.navigate('editBooking',{id:item.reservationId})`, routing the user to edit that booking."}
{"text":"File: Booking.js, Q: Why separate `renderItem` from inline JSX in `listProps`? A: To isolate item‐rendering logic, improving readability and making it easier to test or refactor the booking item UI independently."}
{"text":"File: TaskManagement.js, Q: What does `useTaskManagement()` provide to the TaskManagement component? A: It returns context state (`list`, `statusList`, `priorityList`, `teamList`, `usersInTeams`) and actions (`getTaskList`, `getStatusList`, `getPriorityList`, `getTeamsByTenant`, `getCurrentTeamList`, `getUsersInTeamByTenants`) for managing task data, filters, and lookups."}
{"text":"File: TaskManagement.js, Q: How is `tenant` and `isControlOffice` used? A: They come from `useUser()` and determine default tenant filter (`tenant.id`) and whether to fetch all tenants (`isControlOffice && getTenantList()`) for the filter UI."}
{"text":"File: TaskManagement.js, Q: What is the shape and purpose of `defaultFilter`? A: It initializes the filter state with empty `fromDate`/`toDate`, no selected options, the current tenant, and empty `teamIds`/`userIds`, so the list starts unfiltered."}
{"text":"File: TaskManagement.js, Q: How does `getTMTeamList` decide whether to call `getCurrentTeamList` vs `getTeamsByTenant`? A: It checks if `isControlOffice` or the selected tenant matches `ControlOfficePrjId`; if so it fetches current teams, else fetches teams for the given tenant ID."}
{"text":"File: TaskManagement.js, Q: Why does the effect on `[teamList]` call `getUsersInTeamByTenants()`? A: Whenever `teamList` changes, it maps team IDs and fetches all users in those teams to populate the `usersInTeams` dropdown, keeping user options in sync."}
{"text":"File: TaskManagement.js, Q: What triggers the initial data fetches in the first `useEffect`? A: On mount, it calls `getStatusList()`, `getPriorityList()`, `getTMTeamList(tenant.id)`, optionally `getTenantList()`, and subscribes to `ReloadTM` events for list reloads."}
{"text":"File: TaskManagement.js, Q: How does the component subscribe to `'ReloadTM'` events? A: Inside the first effect it calls `DeviceEventEmitter.addListener('ReloadTM', getList)`, then cleans up by removing the subscription on unmount."}
{"text":"File: TaskManagement.js, Q: What triggers the task list reload besides external events? A: The second `useEffect` watches `[selectedFilter, keyword]` and calls `getList()` whenever filter criteria or search keyword change."}
{"text":"File: TaskManagement.js, Q: How is `getList` parameterized and what does it do? A: It accepts `page` (default 1) and `filter` (default `selectedFilter`), extracts filter fields (dates, flags, IDs), normalizes dates to ISO, and calls `getTaskList` with pagination and filter params."}
{"text":"File: TaskManagement.js, Q: How are `fromDate` and `toDate` converted for the API? A: `convertDate.stringToISOString` transforms locale date strings into ISO format, preventing backend parsing issues."}
{"text":"File: TaskManagement.js, Q: How is the `isOverdue` flag computed? A: It checks if `multipleOptions` includes `multipleOptionValue.isOverdue`; if present yields `true`, otherwise `undefined`, matching API expectations."}
{"text":"File: TaskManagement.js, Q: What is the role of `filterData`? A: It defines the configuration for each filter field (date range, tenant, teams, users, status, priority, task type, overdue toggle) passed to the `<Filter>` component."}
{"text":"File: TaskManagement.js, Q: Why does `tenantFilter` use `FilterTypes.LIST_SELECT` and custom `getList`? A: To enable searching/pagination of tenants when `isControlOffice` is true, fetching tenant list on demand via `getTenantList`."}
{"text":"File: TaskManagement.js, Q: How do `menuIds` and `userIds` filters reset when tenant changes? A: `resetPropsOnChange: ['teamId','userId']` forces those filters to clear whenever a new tenant is selected, avoiding stale options."}
{"text":"File: TaskManagement.js, Q: How is pagination wired into the rendered list? A: The `list` object provides `data`, `isRefresh`, `isLoadMore`, `currentPage`, and `totalPage`; `listProps.loadData` calls `getList(page)` to fetch more as the user scrolls."}
{"text":"File: TaskManagement.js, Q: What does `renderItem` do for each task? A: It returns an `<ItemTask>` component configured with the task data and an `onPress` that navigates to the edit screen for that task ID."}
{"text":"File: TaskManagement.js, Q: How does the Add Task button work? A: `onAddTask` calls `NavigationService.navigate('addTask')`, and it’s wired via `layoutProps.onBtAddPress` passed to `<BaseLayout>`."}
{"text":"File: TaskManagement.js, Q: Why is `keyword` state used and how? A: It tracks the text search input; the filter UI calls `setKeyword`, which triggers the list effect to reload tasks with the new search term."}
{"text":"File: TaskManagement.js, Q: How can this component avoid redundant fetches on unmount/remount? A: By providing an empty dependency array (`[]`) to the initial effect and cleaning up the event listener, ensuring setup occurs only once per mount."}
{"text":"File: TaskManagement.js, Q: How would you test that `getStatusList` is called on mount? A: In a unit test, mock `useTaskManagement` to spy on `getStatusList`, mount the component, and assert the spy was invoked exactly once."}
{"text":"File: TaskManagement.js, Q: What pattern does `useEffect` + `DeviceEventEmitter` illustrate? A: The subscribe/unsubscribe pattern—setting up a listener once on mount and tearing it down on unmount to manage cross-component events."}
{"text":"File: TaskManagement.js, Q: Why use `useState(defaultFilter)` for `selectedFilter`? A: To maintain the applied filter separately from the default template, allowing the user to modify but revert to defaults via `onClearFilter`."}
{"text":"File: TaskManagement.js, Q: How does `onClearFilter` work? A: It refetches the team list for the current tenant and resets `selectedFilter` back to `defaultFilter`, clearing all user-chosen filters."}
{"text":"File: TaskManagement.js, Q: How do `teamList` and `usersInTeams` relate in filter options? A: `teamList` provides the teams dropdown; when it changes, the effect fetches `usersInTeams` so the user dropdown only shows users in the selected teams."}
{"text":"File: TaskManagement.js, Q: What is the significance of destructuring `list` at the top? A: It unpacks list pagination and loading flags into local variables (`data`, `isRefresh`, etc.) for passing to `AppList` and controlling UI state."}
{"text":"File: TaskManagement.js, Q: What is the purpose of the `taskTypeList` constant? A: It defines the two possible task types—site tasks (`id: false`) and control office tasks (`id: true`)—each with a localized display name via `I18n.t`."}
{"text":"File: TaskManagement.js, Q: Why does `taskTypeList` use boolean `id` values instead of strings? A: Because the `isPublic` filter expects a boolean flag internally, so `id: false`/`true` directly maps to the API’s `isPublic` parameter."}
{"text":"File: TaskManagement.js, Q: What does `defaultFilter` represent? A: It initializes the filter state for the task list view, with an empty date range, no toggles (`multipleOptions`), default tenant from the user context, and no team or user selections."}
{"text":"File: TaskManagement.js, Q: Why are `fromDate` and `toDate` set to `undefined` in `defaultFilter.dateRange`? A: To signal “no date filtering” initially; undefined values won’t be included in the API call, so tasks of all dates load by default."}
{"text":"File: TaskManagement.js, Q: What is the role of `multipleOptionValue`? A: It centralizes the key for the “overdue only” toggle (`'isOverdue'`), ensuring both the filter UI and the request logic use the same constant."}
{"text":"File: TaskManagement.js, Q: What do the `useState` hooks for `selectedFilter` and `filterTenantId` manage? A: `selectedFilter` holds the currently applied filter settings; `filterTenantId` tracks which tenant’s teams to fetch whenever the tenant filter changes."}
{"text":"File: TaskManagement.js, Q: How is the `tenantFilter` field configured in `filterData`? A: As a `LIST_SELECT` filter showing `tenantList` options, searchable via `getTenantList`, disabled unless the user is in a control office role, and resetting team/user filters on change."}
{"text":"File: TaskManagement.js, Q: What does `listExist: tenantList.data` achieve in the `tenantFilter` config? A: It tells the component whether initial tenant data is already loaded (`data` present), so it can decide between showing current options or invoking `getTenantList`."}
{"text":"File: TaskManagement.js, Q: What is the purpose of the `getList` callback in `tenantFilter`? A: It allows server‐side searching of tenants: when the user types in the tenant dropdown, `getTenantList({ filter: keyword })` fetches matching tenants page by page."}
{"text":"File: TaskManagement.js, Q: Why is `disabled: !isControlOffice` used for `tenantFilter`? A: Only control‐office users can switch tenants; others see and use their own tenant filter but cannot change it, enforcing access control in the UI."}
{"text":"File: TaskManagement.js, Q: How does the `onChange` function for `tenantFilter` update the component state? A: When a new tenant is selected, it sets `filterTenantId` to the tenant’s ID and calls `getTMTeamList(tenantId)` to refresh the available teams under that tenant."}
{"text":"File: TaskManagement.js, Q: What does `resetPropsOnChange: ['teamId','userId']` ensure? A: It clears the `teamIds` and `userIds` filters automatically when the tenant filter changes, preventing stale team/user selections from a previous tenant."}
{"text":"File: TaskManagement.js, Q: How is the `teamIds` filter configured? A: As a multi‐select dropdown (`FilterTypes.DROPDOWN`) showing `teamList` with `multiple: true`, letting users pick one or more teams to filter tasks by."}
{"text":"File: TaskManagement.js, Q: What does the `userIds` filter configuration specify? A: A multi‐select dropdown showing `usersInTeams`, displaying each user’s `displayName` and using `userId` as the value key, to filter tasks by assignee."}
{"text":"File: TaskManagement.js, Q: How is the `statusIds` filter defined? A: As a multi‐select dropdown (`multiple: true`) listing `statusList`, allowing users to filter tasks by one or more status codes."}
{"text":"File: TaskManagement.js, Q: What is special about the `priorityId` filter? A: It’s a single‐select filter (`multiple: false`) showing `priorityList`, since each task has exactly one priority level."}
{"text":"File: TaskManagement.js, Q: How does the `isPublic` filter use `taskTypeList`? A: It’s a single‐select filter (`multiple: false`) showing the site vs. control‐office options defined in `taskTypeList`, binding to the `isPublic` boolean API parameter."}
{"text":"File: TaskManagement.js, Q: What does the `multipleOptions` filter control? A: It provides toggle filters—in this case only “Overdue Only”—by matching values in `multipleOptionValue` and passing them in an array to the API."}
{"text":"File: TaskManagement.js, Q: Why does `multipleOptions` use `valKey: 'value'`? A: Because its options are objects `{value, name}`, so `value` holds the filter key (`'isOverdue'`) and `name` is the label shown to the user."}
{"text":"File: TaskManagement.js, Q: What is the purpose of the `keyword` state? A: It holds the current text search input for tasks; changing it triggers a list reload, filtering tasks whose titles or descriptions match the keyword."}
{"text":"File: TaskManagement.js, Q: What does the first `React.useEffect` with an empty dependency array (`[]`) do? A: On mount, it loads lookup data by calling `getStatusList()`, `getPriorityList()`, and `getTMTeamList(tenant.id)`; if the user is in a control office, it also calls `getTenantList()`. It then subscribes to the `'ReloadTM'` event via `DeviceEventEmitter.addListener('ReloadTM', getList)`, and cleans up that subscription on unmount."}
{"text":"File: TaskManagement.js, Q: Why is the dependency array for the first effect empty (`[]`)? A: An empty array ensures the effect runs only once on component mount, preventing repeated fetches or subscriptions on every render."}
{"text":"File: TaskManagement.js, Q: Why does the first effect call `getTenantList()` only if `isControlOffice` is true? A: Only control‐office users should be able to select and switch between tenants; non‐control users stay limited to their own tenant, so unnecessary tenant data isn’t fetched for them."}
{"text":"File: TaskManagement.js, Q: What is the purpose of subscribing to the `'ReloadTM'` event in the first effect? A: It allows external components or actions (e.g., after adding/editing a task) to emit `'ReloadTM'`, causing this screen to call `getList()` and refresh its task list automatically."}
{"text":"File: TaskManagement.js, Q: Why must the subscription be cleaned up in the effect’s return function? A: To remove the event listener on unmount, preventing memory leaks and duplicate callbacks if the component mounts again."}
{"text":"File: TaskManagement.js, Q: What triggers the second `React.useEffect` that depends on `[selectedFilter, keyword]`? A: Any change to the filter settings (`selectedFilter`) or the search text (`keyword`) will re-run this effect, calling `getList()` to reload the task data accordingly."}
{"text":"File: TaskManagement.js, Q: Why does the second effect call `getList()` with no arguments? A: Because `getList` defaults to `page = 1` and `filter = selectedFilter`, so calling it without parameters fetches the first page of tasks using the current filter and keyword."}
{"text":"File: TaskManagement.js, Q: What is the role of the `getList` function? A: It centralizes list-fetch logic: it takes a page number and a filter object, extracts and normalizes filter fields, and invokes `getTaskList` with pagination, the search keyword, page size, and all filter parameters."}
{"text":"File: TaskManagement.js, Q: How does `getList` extract and normalize date filters? A: It destructures `fromDate` and `toDate` from `filter.dateRange` and uses `convertDate.stringToISOString` to convert them from UI-friendly strings into ISO format for the API."}
{"text":"File: TaskManagement.js, Q: How is the `isOverdue` flag computed in `getList`? A: It checks `multipleOptions.includes(multipleOptionValue.isOverdue)`. If true, `isOverdue` becomes `true`; if false, it becomes `undefined` so the API won’t filter by overdue when the toggle is off."}
{"text":"File: TaskManagement.js, Q: Why does `getList` include `pageSize: PAGE_SIZE` in its API call? A: To enforce a consistent number of tasks per page, aligning with the app’s pagination configuration imported from `Config`."}
{"text":"File: TaskManagement.js, Q: What fields from the filter object are passed directly to the API? A: `statusIds`, `priorityId`, `isPublic`, `tenantFilter.id` (as `tenantId`), `teamIds`, and `userIds` are spread into `filterParams` and included in the `getTaskList` call."}
{"text":"File: TaskManagement.js, Q: Why spread `...filterParams` into the `getTaskList` call? A: To keep the API parameters in one object, avoiding manual prop listing and ensuring every filter value—converted or not—is passed through uniformly."}
{"text":"File: TaskManagement.js, Q: Why default the `filter` parameter of `getList` to `selectedFilter`? A: So that `getList()` without arguments always uses the latest applied filter state, making it convenient for effects and event listeners to refresh with current criteria."}
{"text":"File: TaskManagement.js, Q: How do the two `useEffect` hooks and `getList` function work together to keep the task list in sync? A: The first effect sets up initial data and a reload listener; the second reacts to filter/search changes; both call `getList`, which builds and fires the API request via `getTaskList`, ensuring the UI always reflects the latest state."}
{"text":"File: TaskManagement.js, Q: What does `onApplyFilter` do? A: It updates the `selectedFilter` state with the provided filter object, triggering a reload of the task list via the effect that watches `[selectedFilter, keyword]`."}
{"text":"File: TaskManagement.js, Q: What is the purpose of `onClearFilter`? A: It resets the team filter by calling `getTMTeamList(filterTenantId)` to reload teams for the current tenant, then resets `selectedFilter` back to `defaultFilter`, clearing all applied filters."}
{"text":"File: TaskManagement.js, Q: How does `onPressItem` function? A: It navigates to the task-edit screen by calling `NavigationService.navigate('editTask', { id })`, passing the selected task’s ID as a route parameter."}
{"text":"File: TaskManagement.js, Q: What does `renderItem` return for each task? A: It returns an `<ItemTask>` component, passing the task `item` and wiring its `onPress` prop to `() => onPressItem(item.id)` so tapping the row opens the edit view."}
{"text":"File: TaskManagement.js, Q: What happens when `onAddTask` is called? A: It navigates to the 'addTask' screen by invoking `NavigationService.navigate('addTask')`, bringing up the task-creation form."}
{"text":"File: TaskManagement.js, Q: How is `listProps` configured for `<AppList>`? A: It spreads pagination and data props (`data`, `isRefresh`, `isLoadMore`, `currentPage`, `totalPage`), plus `loadData: ({page}) => getList(page)`, `keyExtractor: item => item.id.toString()`, `renderItem` wrapper, and `contentContainerStyle: {marginTop:20}`."}
{"text":"File: TaskManagement.js, Q: Why does the component call `getList(1)` inside a `useEffect` with an empty dependency array? A: To fetch the first page of tasks immediately on mount, ensuring the list is populated before any user interaction."}
{"text":"File: TaskManagement.js, Q: What is contained in `layoutProps`? A: It defines header behavior: `addPermission: 'TaskManagement.Create'`, `onBtAddPress: onAddTask`, `showBell: true`, and `showAddButton: true` for the `<BaseLayout>`."}
{"text":"File: TaskManagement.js, Q: How does `<BaseLayout>` use `layoutProps` and the title? A: It spreads `layoutProps` into its props and sets `title=\"TASK_MANAGEMENT_TXT\"`, configuring the header’s buttons, permissions, and displayed title."}
{"text":"File: TaskManagement.js, Q: How is the `<Filter>` component configured in the return block? A: It receives `data={filterData}`, `onCompleted={onApplyFilter}`, `selectedFilter`, `defaultFilter`, `searchPlaceHolder=\"TASK_MGMT_SEARCH_PLACEHOLDER\"`, `onSearch={key => setKeyword(key)}`, and `onClear={onClearFilter}` to manage filtering UI."}
{"text":"File: TaskManagement.js, Q: What does the `onSearch` prop of `<Filter>` do? A: It calls `setKeyword(key)`, updating the `keyword` state which triggers the effect watching `[selectedFilter, keyword]` and reloads the task list with the search term."}
{"text":"File: TaskManagement.js, Q: What is the role of the `onClear` prop passed to `<Filter>`? A: It invokes `onClearFilter`, clearing all filters back to defaults and reloading the team list for the current tenant."}
{"text":"File: TaskManagement.js, Q: How does `keyExtractor: item => item.id.toString()` benefit `<AppList>`? A: It returns a unique string key for each list item, enabling React to optimize list rendering and reconciliation."}
{"text":"File: TaskManagement.js, Q: Why is `contentContainerStyle: {marginTop:20}` applied to the list? A: To add vertical spacing at the top of the task list, improving visual separation from the filter UI above."}
{"text":"File: TaskManagement.js, Q: How does `loadData: ({page}) => getList(page)` support infinite scrolling? A: When `<AppList>` requests more data (e.g., on scroll), it calls `loadData` with the next `page`, invoking `getList(page)` to fetch additional tasks."}
{"text":"File: TaskManagement.js, Q: What default values does `getList` use when called with no arguments? A: It defaults to `page = 1` and `filter = selectedFilter`, so it always fetches the first page using the latest applied filter state."}
{"text":"File: TaskManagement.js, Q: Why is the mount effect for `getList` separate from the effect that watches `[selectedFilter, keyword]`? A: To ensure an initial data fetch occurs on mount regardless of filter/search changes, keeping concerns separated and effects focused."}
{"text":"File: TaskManagement.js, Q: What permission string controls enabling the Add button in the header? A: The `addPermission` prop is set to `'TaskManagement.Create'`, gating the Add button based on user permissions in `<BaseLayout>`."}
{"text":"File: TaskManagement.js, Q: How would you modify `onPressItem` to guard against invalid IDs? A: Add a check like `if (!id) return;` before navigation to prevent routing errors when `item.id` is missing."}
{"text":"File: TaskManagement.js, Q: How could you optimize `renderItem` with `useCallback`? A: Wrap it as `const renderItem = useCallback(item => <ItemTask ... />, [onPressItem])` so the function identity remains stable across renders."}
{"text":"File: TaskManagement.js, Q: What pattern does this component illustrate by separating filter, list, and layout concerns? A: It follows the “composition” pattern: filter logic in `<Filter>`, list rendering in `<AppList>`, and header controls in `<BaseLayout>`, each handled by focused props and callbacks."}
{"text":"File: Asset.js, Q: What does `useAsset()` provide to the Asset screen? A: It returns the `asset` state (including `list`, `companies`, and `assetTypesFilter`) and actions (`getAssets`, `getAssetTypesFilter`, `getCompanies`, `getAssetByCode`) for loading and filtering assets."}
{"text":"File: Asset.js, Q: What does `useWorkflow()` provide? A: It supplies the `getWorkflowStatus` action and the `workflow.statusList` state, used here to fetch and store workflow statuses for inspections."}
{"text":"File: Asset.js, Q: What does `useFeedback()` provide? A: It returns `feedback.qrFeedbackSetting` (QR feedback configuration) and `getQrFeedbackSetting` to load that configuration on mount."}
{"text":"File: Asset.js, Q: How is the asset list data destructured? A: From `list` state: `data` (array of assets), `isRefresh` (pull-to-refresh flag), `isLoadMore` (infinite-scroll loading), `currentPage`, and `totalPage`."}
{"text":"File: Asset.js, Q: What is the shape of `defaultFilter`? A: It contains `datePurchased` and `dateWarranty` with undefined `fromDate`/`toDate`, `assetTypeIds` and `companyId` undefined, and `multipleOptions` defaulting to `['isActive']`."}
{"text":"File: Asset.js, Q: Why are `datePurchased` and `dateWarranty` initialized with `undefined` dates? A: To indicate no date filtering by default, so the initial asset list shows all purchase and warranty dates."}
{"text":"File: Asset.js, Q: What are the `multipleOptionValue` constants? A: They define toggle keys: `isInactive` and `isActive`, used in `multipleOptions` to filter active or inactive assets."}
{"text":"File: Asset.js, Q: How does `filterData.datePurchased` configure the filter UI? A: It sets the title to `'PURCHASED_DATE'` and uses `FilterTypes.DATE_TIME` to present a date-range picker."}
{"text":"File: Asset.js, Q: How is `filterData.dateWarranty` configured? A: Similarly, with title `'WARRANTY_DATE'` and type `FilterTypes.DATE_TIME` for filtering by warranty expiration date."}
{"text":"File: Asset.js, Q: What does `filterData.assetTypesFilter` do? A: It configures a `LIST_SELECT` dropdown titled `'ASSET_TYPE'`, sourcing options from `assetTypes` and fetching more via `getAssetTypesFilter`."}
{"text":"File: Asset.js, Q: How does the asset types dropdown support pagination? A: By providing a `getList` callback `(page, keyword) => getAssetTypesFilter({ page, keyword })` and checking `assetTypes.data` in `listExist`."}
{"text":"File: Asset.js, Q: What does `filterData.companiesFilter` configure? A: A `LIST_SELECT` filter titled `'COMPANY'` with options from `companies` and a `getList` callback to `getCompanies`."}
{"text":"File: Asset.js, Q: Why is there a `listExist` property for list-select filters? A: It indicates whether initial data exists (`.data` array) so the component knows if it needs to call the `getList` callback."}
{"text":"File: Asset.js, Q: What is the purpose of `filterData.locationName`? A: It provides a free-text filter titled `'UNIT_LOCATION'` to search assets by their location name."}
{"text":"File: Asset.js, Q: How is the `multipleOptions` filter configured? A: With `valKey: 'value'` and options for active/inactive toggles, showing labels `'COMMON_ACTIVE'` and `'COMMON_INACTIVE'`."}
{"text":"File: Asset.js, Q: Why include only `'isActive'` in `defaultFilter.multipleOptions`? A: To default the list to show only active assets on initial load."}
{"text":"File: Asset.js, Q: How is the `selectedFilter` state initialized? A: With `useState(defaultFilter)`, so the UI starts with the default filter settings."}
{"text":"File: Asset.js, Q: What does the `keyword` state represent? A: The current search text entered by the user, used to filter assets by name or code."}
{"text":"File: Asset.js, Q: Why call `getQrFeedbackSetting()` in a `useEffect` on mount? A: To load QR feedback configuration before rendering, which may affect the UI (e.g., showing or hiding the add button)."}
{"text":"File: Asset.js, Q: What actions happen in the main `React.useEffect` on mount? A: `getAssetTypesFilter()`, `getCompanies()`, conditional `getWorkflowStatus(Modules.INSPECTION)` if no statuses, and subscription to `'ReloadAsset'` events."}
{"text":"File: Asset.js, Q: Why check `_.size(statusList)` before calling `getWorkflowStatus`? A: To avoid redundant API calls if the workflow statuses have already been loaded."}
{"text":"File: Asset.js, Q: What event does `DeviceEventEmitter.addListener('ReloadAsset', getList)` listen for? A: The `'ReloadAsset'` event, triggering `getList` to refresh the asset list when assets change elsewhere in the app."}
{"text":"File: Asset.js, Q: Why remove the subscription on unmount? A: To prevent memory leaks and stale callbacks when the component is no longer in the view hierarchy."}
{"text":"File: Asset.js, Q: How does the `useEffect` that depends on `[selectedFilter, keyword]` work? A: It calls `getList()` whenever the filter settings or search keyword change, keeping the list synchronized with user inputs."}
{"text":"File: Asset.js, Q: What default values does `getList()` use when called without arguments? A: `page = 1` and `filter = selectedFilter`, so it fetches the first page based on the current filter."}
{"text":"File: Asset.js, Q: How are `page` and `filter` parameters passed to `getList` from pagination? A: Via `loadData: ({ page }) => getList(page)` in `listProps`, enabling infinite-scroll support."}
{"text":"File: Asset.js, Q: How does `getList` construct its `filterParams` object? A: By extracting fields from `filter`, converting dates to ISO strings, mapping toggle values, and adding `sorting: 'id desc'`."}
{"text":"File: Asset.js, Q: How is `assetTypeIds` derived in `filterParams`? A: From `filter.assetTypesFilter?.id`, passing the selected asset type ID to the API."}
{"text":"File: Asset.js, Q: How is `companyIds` derived? A: From `filter.companiesFilter?.id`, sending the selected company ID as a filter."}
{"text":"File: Asset.js, Q: How is the `isActive` flag computed for the API? A: As `multipleOptions.includes(multipleOptionValue.isActive)`, yielding `true` when the active toggle is selected."}
{"text":"File: Asset.js, Q: Why use `convertDate.stringToISOString` for date fields? A: To format `fromDate` and `toDate` into standardized ISO strings that the backend expects."}
{"text":"File: Asset.js, Q: What are the date parameters sent to the API? A: `fromPurchasedDate`, `toPurchasedDate`, `fromWarrantDate`, and `toWarrantDate`."}
{"text":"File: Asset.js, Q: How is `locationName` included in the API call? A: As the `locationName` key in `filterParams`, passing whatever the user entered."}
{"text":"File: Asset.js, Q: What sorting order is applied by default? A: `'id desc'`, so the newest assets appear first."}
{"text":"File: Asset.js, Q: What action does `getAssets()` perform with the parameters? A: It fetches the asset list for the given page, search keyword, and filter parameters, updating the context state."}
{"text":"File: Asset.js, Q: How does `onApplyFilter` work? A: It receives the new filter object from the `<Filter>` component and calls `setSelectedFilter(value)`, triggering a list reload."}
{"text":"File: Asset.js, Q: What does `onPressItem` do? A: Navigates to the asset detail screen via `NavigationService.navigate('detailAssets', { id })`."}
{"text":"File: Asset.js, Q: How does `renderItem` render each asset? A: It returns `<ItemAsset item={item} onPress={() => onPressItem(item.id)} />`, wiring each row to open its detail view."}
{"text":"File: Asset.js, Q: What does `onAddAsset` do? A: Navigates to the add-asset screen by calling `NavigationService.navigate('addAsset')`."}
{"text":"File: Asset.js, Q: How is the `listProps` object structured for `<AppList>`? A: It includes `data`, `isRefresh`, `isLoadMore`, `currentPage`, `totalPage`, `loadData`, `keyExtractor`, `renderItem`, and a top margin in `contentContainerStyle`."}
{"text":"File: Asset.js, Q: Why use `item.id.toString()` in `keyExtractor`? A: React keys must be strings; converting ensures stable, unique keys for list items."}
{"text":"File: Asset.js, Q: What does the effect `useEffect(() => getList(1), [])` do? A: Loads the first page of assets on component mount to populate the list immediately."}
{"text":"File: Asset.js, Q: What does `openQRCodeScanner` do? A: Opens the QR code scanner screen via navigation and passes a callback to fetch an asset by its scanned code."}
{"text":"File: Asset.js, Q: Why does `openQRCodeScanner` set `notAllowGoBack: true`? A: To block the back button on the scanner screen, forcing users to complete or cancel scanning explicitly."}
{"text":"File: Asset.js, Q: How does the scanner callback fetch asset details? A: By calling `getAssetByCode({ code: assetCode })` when the QR code is read."}
{"text":"File: Asset.js, Q: What is the `rightButtonProps` object used for? A: It configures the QR scanner button in the header with an icon, size, and `onPress` handler."}
{"text":"File: Asset.js, Q: How are `layoutProps` defined for `<BaseLayout>`? A: They include permission `'Asset.Create'`, conditional `showAddButton`, `onBtAddPress`, `rightBtn`, and `showBell: true`."}
{"text":"File: Asset.js, Q: What controls whether the Add button appears? A: `showAddButton` is `true` only if `qrFeedbackSetting?.isEmbedExternalWebsite` is falsy."}
{"text":"File: Asset.js, Q: What does `addPermission: 'Asset.Create'` enforce? A: It gates the Add button behind the `'Asset.Create'` permission in the layout."}
{"text":"File: Asset.js, Q: Why set `showBell: true` in `layoutProps`? A: To display the notification bell icon in the header for the asset screen."}
{"text":"File: Asset.js, Q: How does `<Filter>` use `onSearch`? A: It calls `setKeyword(key)` whenever the user types in the search input, triggering a list reload effect."}
{"text":"File: Asset.js, Q: What placeholder text does the search input show? A: `ASSET_SEARCH_PLACEHOLDER`, a localized key for the asset search field."}
{"text":"File: Asset.js, Q: How does `<AppList>` integrate with the refresh and load-more flags? A: It uses `isRefresh` to show pull-to-refresh loading and `isLoadMore` for infinite-scroll loading indicators."}
{"text":"File: Asset.js, Q: What role does `DeviceEventEmitter` play in this component? A: It listens for `'ReloadAsset'` events to programmatically refresh the asset list when assets change elsewhere."}
{"text":"File: Asset.js, Q: How might you debounce rapid search input changes? A: Wrap `setKeyword` or the list-reload effect in a debounce (e.g., via `lodash.debounce`) to batch API calls."}
{"text":"File: Asset.js, Q: How could you handle API errors in `getList`? A: Wrap the `getAssets` call in `try/catch` and display an alert on failure."}
{"text":"File: Asset.js, Q: What pattern does this component illustrate by splitting concerns? A: It composes filter (`<Filter>`), list (`<AppList>`), and layout (`<BaseLayout>`) logic via props and hooks for maintainability."}
{"text":"File: Asset.js, Q: How would you unit-test the filter logic? A: Mock `getAssetTypesFilter`, `getCompanies`, and call the filter callbacks to assert `getAssets` is called with correct parameters."}
{"text":"File: Asset.js, Q: How can you add a “Clear Filters” button? A: Implement an `onClearFilter` that calls `setSelectedFilter(defaultFilter)` and resets `keyword` to `''`, then reloads the list."}
{"text":"File: Asset.js, Q: How could you refactor date conversion out of `getList`? A: Extract a helper `normalizeDateRange(dateRange)` that returns `{ from, to }` ISO strings, reducing duplication across screens."}
{"text":"File: Asset.js, Q: How can you improve type safety in the filter data? A: Define a TypeScript interface for `FilterData` that enforces each field’s shape (`title`, `type`, `options`, etc.)."}
{"text":"File: Feedback.js, Q: What does useFeedback() provide to the Feedback screen? A: It returns feedback state (`list`, `listQRFeedback`, `categories`, `types`, `locations`, `statusList`, `divisionList`, `qrFeedbackSetting`) and actions (`getListFB`, `getListQRFeedback`, `getCategories`, `getTypes`, `getLocations`, `getFeedbackStatus`, `getQrFeedbackSetting`, `getFeedbackDivision`) for loading dropdowns, filters, and lists."}
{"text":"File: Feedback.js, Q: What is the purpose and shape of defaultFilter? A: It initializes the filter state with an empty dateRange (`fromDate: undefined`, `toDate: undefined`), meaning no date filtering until the user applies a range."}
{"text":"File: Feedback.js, Q: How does filterFeedback configure the filters for the Feedback tab? A: It defines a dateRange picker plus multi-select `statusIds`, single-select `types`, and single-select `categories`, each with titles and options from context state."}
{"text":"File: Feedback.js, Q: What is divisionFilterControl used for? A: It defines a `commentBoxDivisionId` dropdown (type `FilterTypes.DROPDOWN`) for the division filter, conditionally merged into `filterQRFeedback` when `qrFeedbackSetting.canViewDivision` is true."}
{"text":"File: Feedback.js, Q: What bug exists in the tab constant? A: Both `tab.feedback` and `tab.qrFeedback` are set to `0`, so switching tabs always matches the feedback branch and never the QR branch."}
{"text":"File: Feedback.js, Q: How does the component track which tab is active? A: It uses `const [tabIndex, setTabIndex] = useState(0)` and evaluates `isTabFeedback = tabIndex === tab.feedback` to branch UI and data logic."}
{"text":"File: Feedback.js, Q: What’s wrong with the selectedFilter state initializer? A: It uses `setSelectedFilter = !isTabFeedback ? setQRFeedbackFilter : setFeedbackFilter`, aliasing the setter incorrectly. It should be `const [selectedFilter, setSelectedFilter] = useState(isTabFeedback ? feedbackFilter : qrFeedbackFilter)`."}
{"text":"File: Feedback.js, Q: How is textSearch used? A: It stores the search input string; changes to `textSearch` trigger the effect watching `[textSearch, selectedFilter]` to reload the list."}
{"text":"File: Feedback.js, Q: What does the first useEffect (with empty deps) do? A: On mount, it fetches all lookup data—categories, types, feedback status, divisions, QR feedback settings, and initial locations—so filters have their options ready."}
{"text":"File: Feedback.js, Q: How does the second useEffect reload data on filter/search changes? A: It depends on `[textSearch, selectedFilter]` and calls `getList(1)` whenever either changes, refreshing the list to match the new criteria."}
{"text":"File: Feedback.js, Q: What does the third useEffect (deps: [tabIndex]) manage? A: It subscribes to the `UpdateListFeedback` event, calling `getList(1, textSearch, selectedFilter)` on each emission, and cleans up the listener on unmount or tab change."}
{"text":"File: Feedback.js, Q: How does getValueForOptions(list, listQRFeedback) work? A: It returns `list` when on the Feedback tab, otherwise `listQRFeedback`, determining which dataset the list UI should render."}
{"text":"File: Feedback.js, Q: What pagination and loading flags come from listData? A: `{ data, isRefresh, isLoadMore, currentPage, totalPage }` from either `list` or `listQRFeedback`, passed to `<AppList>` to drive infinite scroll and pull-to-refresh."}
{"text":"File: Feedback.js, Q: How does getList choose which API to call? A: It selects `getListFB` when `tabIndex === tab.feedback`, otherwise `getListQRFeedback` for the QR Feedback tab."}
{"text":"File: Feedback.js, Q: What parameters does getList normalize before calling the API? A: It spreads `selectedFilter`, converts `fromDate`/`toDate` to ISO strings with `convertDate.stringToISOString`, and maps `commentBoxLocationId` to its `.id`."}
{"text":"File: Feedback.js, Q: What does clearFilter do? A: It deep-clones `defaultFilter` with `_.cloneDeep` and sets it as `selectedFilter`, resetting all filters to their initial empty state."}
{"text":"File: Feedback.js, Q: How does onApplyFilter work? A: It receives a new filter object from `<Filter>` and calls `setSelectedFilter(value)`, which triggers the reload effect."}
{"text":"File: Feedback.js, Q: What happens when the Add button is pressed (onBtAddPress)? A: It navigates to the `addFeedback` screen via `NavigationService.navigate('addFeedback')`."}
{"text":"File: Feedback.js, Q: How does onTextSearchChange integrate search? A: It updates the `textSearch` state on each keystroke, and the reload effect uses this new keyword to fetch matching items."}
{"text":"File: Feedback.js, Q: What does gotoDetail(item) do? A: It navigates to `editFeedback` or `editQRFeedback` depending on the active tab, passing `{ id: item.id }` as the route parameter."}
{"text":"File: Feedback.js, Q: How does onTabChange behave? A: It sets the new `tabIndex` and calls `clearFilter()` to reset filters whenever the user switches between tabs."}
{"text":"File: Feedback.js, Q: What does renderItem(item) return? A: It returns `<ItemFB>` with `moduleId` set to either `Modules.FEEDBACK` or `Modules.QR_FEEDBACK`, the `item` data, and an `onPress` that calls `gotoDetail(item)`."}
{"text":"File: Feedback.js, Q: How is listProps for <AppList> constructed? A: It bundles `data`, `isRefresh`, `isLoadMore`, `currentPage`, `totalPage`, an empty-state `iconName`, `loadData: ({page}) => getList(page)`, `keyExtractor: item => `${item.id}`, and `renderItem`."}
{"text":"File: Feedback.js, Q: What header props are passed to <BaseLayout>? A: `{ addPermission: 'Feedbacks.Create', showAddButton: isTabFeedback, onBtAddPress: isTabFeedback ? onBtAddPress : null, title: 'HOME_TEXT_FEEDBACK', showBell: true }`."}
{"text":"File: Feedback.js, Q: How is the <Filter> component configured per tab? A: It receives either `filterFeedback` or `filterQRFeedback` based on `isTabFeedback`, plus `onCompleted`, `selectedFilter`, `defaultFilter`, `onSearch`, and a dynamic `searchPlaceHolder` depending on the tab."}
{"text":"File: Feedback.js, Q: Where and how is the SegmentControl rendered? A: Inside `<SegmentWrapper>` below the filter; it's given `selectedIndex={tabIndex}`, `values={['FEEDBACK_HEADER_TAB','FEEDBACK_QR_HEADER_TAB']}`, and `onChange={onTabChange}` to allow tab switching."}
{"text":"File: Feedback.js, Q: Why cloneDeep defaultFilter in clearFilter? A: To avoid mutating the original filter object and ensure a fresh, isolated filter state when resetting."}
{"text":"File: Feedback.js, Q: Why is getLocations called with {page:1} in the mount effect? A: To preload the first batch of location options for the `commentBoxLocationId` dropdown before the user opens the filter."}
{"text":"File: Feedback.js, Q: What does listExist: locations.data indicate in filterQRFeedback? A: It tells the filter component that initial location data exists (`locations.data` is non-empty), so it can render options without immediately calling getList."}
{"text":"File: Feedback.js, Q: How is commentBoxLocationId mapped to the API? A: In getList, `filter.commentBoxLocationId?.id` is extracted and passed as the `commentBoxLocationId` parameter in the API call."}
{"text":"File: Feedback.js, Q: What does the `useFeedback()` hook provide to the Feedback component? A: It supplies the feedback context’s state (`list`, `listQRFeedback`, `categories`, `types`, `locations`, `statusList`, `divisionList`, `qrFeedbackSetting`) and its actions (`getListFB`, `getListQRFeedback`, `getCategories`, `getTypes`, `getLocations`, `getFeedbackStatus`, `getQrFeedbackSetting`, `getFeedbackDivision`) for loading lookup data, list data, and QR-feedback configuration."}
{"text":"File: Feedback.js, Q: How is the active tab determined and what is the bug in its definition? A: The component tracks active tab via `const [tabIndex, setTabIndex] = useState(0)` and `isTabFeedback = tabIndex === tab.feedback`. However, both `tab.feedback` and `tab.qrFeedback` are set to `0`, so `isTabFeedback` is always true and the QR-Feedback branch never runs."}
{"text":"File: Feedback.js, Q: How is the `selectedFilter` state initialized and why is it incorrect? A: It’s declared as `const [selectedFilter, setSelectedFilter = !isTabFeedback ? setQRFeedbackFilter : setFeedbackFilter] = useState(isTabFeedback ? feedbackFilter : qrFeedbackFilter)`. This mistakenly aliases the setter rather than properly destructuring; it should be `const [selectedFilter, setSelectedFilter] = useState(isTabFeedback ? feedbackFilter : qrFeedbackFilter)`."}
{"text":"File: Feedback.js, Q: What is the shape of `defaultFilter` and what does it represent? A: `defaultFilter` is an object with `dateRange: { fromDate: undefined, toDate: undefined }`, representing no date filtering by default for both Feedback and QR-Feedback lists."}
{"text":"File: Feedback.js, Q: How does `filterFeedback` configure the filter UI for the Feedback tab? A: It provides a mapping of filter fields: an empty `dateRange` object for date-picker, a multi-select `statusIds` dropdown using `statusList`, single-select `types` using `types`, and single-select `categories` using `categories`."}
{"text":"File: Feedback.js, Q: How is `filterQRFeedback` constructed and when does it include division filtering? A: `filterQRFeedback` defines `dateRange`, `commentBoxTypeId` (type dropdown), `phoneNumber` (free-text), and `commentBoxLocationId` (list-select with remote loading). It conditionally merges `divisionFilterControl` when `qrFeedbackSetting?.canViewDivision` is true, adding a `commentBoxDivisionId` dropdown."}
{"text":"File: Feedback.js, Q: What does `divisionFilterControl` define? A: An object `{ commentBoxDivisionId: { title: 'DIVISION', type: FilterTypes.DROPDOWN, options: divisionList } }`, used to filter QR-Feedback by organizational division when permitted."}
{"text":"File: Feedback.js, Q: What initial data-loading happens in the first `useEffect`? A: On mount, it calls `getCategories()`, `getTypes()`, `getFeedbackStatus()`, `getFeedbackDivision()`, `getQrFeedbackSetting()`, and `getLocations({ page:1 })` to populate all filter dropdowns and QR settings before rendering."}
{"text":"File: Feedback.js, Q: How does the component respond to changes in search text or filters? A: The second `useEffect` lists `[textSearch, selectedFilter]` and calls `getList(1)` whenever either changes, re-fetching page 1 of the appropriate list with updated criteria."}
{"text":"File: Feedback.js, Q: What event listener is set up in the third `useEffect` and why? A: It subscribes to `DeviceEventEmitter.addListener('UpdateListFeedback', ...)`, so external events (e.g. after editing an item) trigger `getList(1, textSearch, selectedFilter)` to refresh the list. The listener is torn down on cleanup."}
{"text":"File: Feedback.js, Q: Why does the third effect depend on `[tabIndex]`? A: So that when the user switches tabs, the previous listener is removed and a new one set up that calls the correct `getList` for the active tab."}
{"text":"File: Feedback.js, Q: How does `getValueForOptions` choose between the two lists? A: It returns `list` when `tabIndex === tab.feedback`, otherwise `listQRFeedback`, ensuring the UI renders the correct dataset for the active tab."}
{"text":"File: Feedback.js, Q: What pagination and loading props are extracted from the list data? A: `{ data, isRefresh, isLoadMore, currentPage, totalPage }` are destructured from the chosen `list` object and passed to `<AppList>` to manage infinite scroll and pull-to-refresh."}
{"text":"File: Feedback.js, Q: What is the signature of the `getList` function and its default parameters? A: `const getList = (page = 1, keyword = textSearch, filter = selectedFilter) => { … }`, defaulting to page 1, current search keyword, and current filter state when invoked without arguments."}
{"text":"File: Feedback.js, Q: How are date filters applied in the API call? A: Inside `getList`, it destructures `fromDate` and `toDate` from `filter.dateRange` and passes them as ISO strings (`convertDate.stringToISOString`) if defined, or omits them otherwise."}
{"text":"File: Feedback.js, Q: How does `getList` choose which data-fetch action to call? A: It uses `const getData = tabIndex === tab.feedback ? getListFB : getListQRFeedback`, then calls `getData({ page, pageSize: PAGE_SIZE, keyword, ...filterParams })`."}
{"text":"File: Feedback.js, Q: How is the `commentBoxLocationId` filter mapped to the API request? A: `filterParams` includes `commentBoxLocationId: filter.commentBoxLocationId?.id`, extracting the selected location’s ID for filtering QR feedback."}
{"text":"File: Feedback.js, Q: Why does `clearFilter` use `_.cloneDeep(defaultFilter)`? A: To create a fresh copy of `defaultFilter`—avoiding mutation of the original—then pass it to `setSelectedFilter`, effectively resetting all filter fields."}
{"text":"File: Feedback.js, Q: How does `onApplyFilter` update filters? A: It accepts the new filter object from `<Filter>` and calls `setSelectedFilter(value)`, triggering the `useEffect` to reload the list with the new criteria."}
{"text":"File: Feedback.js, Q: What happens when the Add button is pressed via `onBtAddPress`? A: It calls `NavigationService.navigate('addFeedback')`, routing the user to the feedback creation screen. This button only appears when `isTabFeedback` is true."}
{"text":"File: Feedback.js, Q: How does `onTextSearchChange` handle search input? A: It updates `textSearch` state on each keystroke; the `[textSearch, selectedFilter]` effect then re-fetches page 1 of the list using the new keyword."}
{"text":"File: Feedback.js, Q: How does `gotoDetail` navigate to the edit screen? A: It calls `NavigationService.navigate(isTabFeedback ? 'editFeedback' : 'editQRFeedback', { id: item.id })`, passing the selected item’s ID to the appropriate edit screen based on the active tab."}
{"text":"File: Feedback.js, Q: What does the `renderItem` function do? A: It returns `<ItemFB moduleId={…} item={item} onPress={() => gotoDetail(item)} />`, rendering each feedback entry with the proper module ID and wiring the press handler to `gotoDetail`."}
{"text":"File: Feedback.js, Q: How is the `listProps` object constructed for `<AppList>`? A: It includes `data`, `isRefresh`, `isLoadMore`, `currentPage`, `totalPage`, an empty-state `iconName`, `loadData: ({ page }) => getList(page)`, `keyExtractor: item => `{item.id}`, and `renderItem`."}
{"text":"File: Feedback.js, Q: What props are passed to `<BaseLayout>` and what do they control? A: `{ addPermission: 'Feedbacks.Create', showAddButton: isTabFeedback, onBtAddPress: isTabFeedback ? onBtAddPress : null, title: 'HOME_TEXT_FEEDBACK', showBell: true }`. They control header buttons, permissions, title text, and bell icon."}
{"text":"File: Feedback.js, Q: How is the `<Filter>` component configured per tab? A: It’s passed `data={isTabFeedback ? filterFeedback : filterQRFeedback}`, `onCompleted`, `selectedFilter`, `defaultFilter`, `onSearch`, and a dynamic `searchPlaceHolder` depending on `tabIndex`, so the UI reflects current tab context."}
{"text":"File: Feedback.js, Q: What is the purpose of `<SegmentWrapper>` and `<SegmentControl>`? A: `<SegmentWrapper>` styles the segment bar; `<SegmentControl>` receives `selectedIndex={tabIndex}`, `values={['FEEDBACK_HEADER_TAB','FEEDBACK_QR_HEADER_TAB']}`, and `onChange={onTabChange}` to render a tappable tab switcher."}
{"text":"File: Feedback.js, Q: How does `onTabChange` manage tab switching? A: It sets `tabIndex` to the new index and calls `clearFilter()` to reset filters whenever the user switches between Feedback and QR-Feedback tabs."}
{"text":"File: Feedback.js, Q: Why clone `defaultFilter` in `clearFilter` instead of reusing it? A: To avoid shared-state bugs: mutating or retaining references to the original filter object could cause stale or unexpected filter values."}
{"text":"File: Feedback.js, Q: How do the two list modes (Feedback vs. QR-Feedback) differ in UI and data? A: Feedback mode shows status, type, category filters and uses `list` via `getListFB`; QR-Feedback mode shows type, phone, location, (and optionally division) filters and uses `listQRFeedback` via `getListQRFeedback`."}
{"text":"File: Feedback.js, Q: What accessibility and testing considerations are present? A: Components should include `accessibilityLabel` and `testID` props on `Filter`, tab buttons, search input, list items, and add button to support screen readers and E2E tests."}
{"text":"File: Feedback.js, Q: How could you debounce search input to reduce API calls? A: Wrap `setTextSearch` or the effect’s `getList(1)` call in `lodash.debounce`, so the list reload only after the user stops typing for a short delay."}
{"text":"File: Feedback.js, Q: How would you handle API errors in `getList`? A: Surround `getData({...})` with `try/catch`, call `Alert.alert(I18n.t('ERROR'), error.message)` on failure, and optionally set an error state to display a message in the UI."}
{"text":"File: Feedback.js, Q: What pattern does the component illustrate with its effects and event listeners? A: It uses the subscribe/unsubscribe pattern: effects set up data-fetch and event listeners on mount, and clean them up on unmount or dependency change, isolating side-effects."}
{"text":"File: Feedback.js, Q: How could you refactor filter state management to simplify toggling between modes? A: Encapsulate filter logic in a custom `useFeedbackFilter(tabIndex)` hook that returns `filterData`, `selectedFilter`, `setSelectedFilter`, and splits default/filter objects per tab automatically."}
{"text":"File: Feedback.js, Q: How can you ensure the tab constant bug is fixed? A: Update `const tab = { feedback: 0, qrFeedback: 1 };` so `tab.feedback` and `tab.qrFeedback` differ, allowing the component to distinguish between tabs correctly."}
{"text":"File: Feedback.js, Q: Why is the search placeholder dynamic? A: It uses `searchPlaceHolder={tabIndex===0?'FB_SEARCH_PLACEHOLDER':'QR_FB_SEARCH_PLACEHOLDER'}` so the input hint matches the active list’s context (general feedback vs. QR code feedback)."}
{"text":"File: MeterReading.js, Q: What does `useMeterReading()` provide to the MeterReading component? A: It returns the `meterReading` context state (`meterReadings`, `meterTypes`, `settings`) and actions (`getMeterReadings`, `getMeterTypes`, `getMeterSettings`) for loading lookup data and the meter-reading list."}
{"text":"File: MeterReading.js, Q: Why does the component call `useState('')` for `textSearch`? A: To track the user’s search input; changes to `textSearch` trigger the list reload effect, filtering the meter readings by keyword."}
{"text":"File: MeterReading.js, Q: What is the purpose of the `listStatus` array? A: It defines two status options—active and inactive—with localized names (`I18n.t('COMMON_ACTIVE')`, `I18n.t('COMMON_INACTIVE')`) and boolean IDs, used in the `isActive` filter dropdown."}
{"text":"File: MeterReading.js, Q: What does `defaultFilter` define? A: It initializes filters with an empty `dateRange` (`fromDate`/`toDate` undefined), `isActive` defaulting to `[true]` (show only active), and `year` defaulting to the current year."}
{"text":"File: MeterReading.js, Q: How does `filterData` configure the `<Filter>` UI? A: It maps filter keys to UI props: `dateRange` (date picker), `isActive` (single-select status dropdown), `meterTypeId` (single-select type dropdown), `period` and `year` (single-select grids with custom columns), and `serialNumber` (text input)."}
{"text":"File: MeterReading.js, Q: Why spread `[...]meterTypes` into the `meterTypeId` options? A: To create a fresh array copy of `meterTypes` for the filter, ensuring React detects updates when the context state changes."}
{"text":"File: MeterReading.js, Q: What does `valKey: 'value'` and `fieldName: 'label'` mean in the `period` and `year` filters? A: They tell the filter which object property to use as the option’s value (`value`) and display label (`label`), matching the shape of `meterReadingPeriods` and `meterReadingYears` entries."}
{"text":"File: MeterReading.js, Q: How is filter state managed? A: Via `const [selectedFilter, setSelectedFilter] = useState(defaultFilter)`, storing the currently applied filter values separate from the defaults."}
{"text":"File: MeterReading.js, Q: What triggers the effect `useEffect(() => getList(1), [textSearch, selectedFilter])`? A: Any change to `textSearch` or `selectedFilter` causes a fresh load of page 1 of meter readings, keeping the list in sync with user inputs."}
{"text":"File: MeterReading.js, Q: Why is there a separate `useEffect` for `getMeterTypes()` and `getMeterSettings()` on mount? A: To fetch lookup data (meter types and settings) only once when the component first renders, populating dropdowns before user interaction."}
{"text":"File: MeterReading.js, Q: How does the component subscribe to reload events? A: A `useEffect` adds a `DeviceEventEmitter.addListener('ReloadInventory', ...)` that calls `getList(1)` when the event fires, and cleans up the listener on unmount."}
{"text":"File: MeterReading.js, Q: What does the `getList` function do? A: It builds the API payload from `selectedFilter` and `textSearch`, extracting `fromDate`/`toDate`, first elements of single-select arrays via `_.first`, and spreads `getIsoDateRange` results, then calls `getMeterReadings`."}
{"text":"File: MeterReading.js, Q: Why use `_.first(selectedFilter.meterTypeId)` instead of accessing `[0]` directly? A: To safely get the first element or `undefined` if the array is empty, guarding against runtime errors on missing selections."}
{"text":"File: MeterReading.js, Q: What is the purpose of `getIsoDateRange(fromDate, toDate)`? A: It returns an object `{ fromDate: isoStart, toDate: isoEnd }` to normalize the UI’s date-range values into the ISO-format keys the API expects."}
{"text":"File: MeterReading.js, Q: How are pagination and loading state passed to `<AppList>`? A: The `meterReadings` object provides `{ data, isRefresh, isLoadMore, currentPage, totalPage }`, which `<AppList>` uses to render items, pull-to-refresh, and infinite scroll."}
{"text":"File: MeterReading.js, Q: How does the `onApplyFilter` callback work? A: It’s passed to `<Filter>` as `onCompleted`; when the user applies filters, it receives a new filter object and calls `setSelectedFilter`, triggering a list reload."}
{"text":"File: MeterReading.js, Q: What is the role of `onTextSearchChange`? A: It updates `textSearch` state on each keystroke; the effect watching `textSearch` then reloads the meter readings with the new search term."}
{"text":"File: MeterReading.js, Q: How does `onItemPress` navigate to the detail screen? A: It calls `navigation.navigate('meterReadingDetail', { id: item.id, meterDeviceId: item.meterDeviceId })`, passing both the record ID and its device ID as parameters."}
{"text":"File: MeterReading.js, Q: What does `renderItem` return for each list row? A: `<ItemMeterReading settings={settings} item={item} onPress={() => onItemPress(item)} />`, injecting the current `settings` and wiring the press handler to `onItemPress`."}
{"text":"File: MeterReading.js, Q: How is the `listProps` object constructed for `<AppList>`? A: It includes `data`, `isRefresh`, `isLoadMore`, `currentPage`, `totalPage`, an empty-state `iconName`, `loadData: ({page})=>getList(page)`, `keyExtractor: item=>item.id.toString()`, and `renderItem`."}
{"text":"File: MeterReading.js, Q: What does `openCreateRecord` do? A: It navigates to the `'createMeterManual'` screen with no parameters, opening the manual meter-reading creation form."}
{"text":"File: MeterReading.js, Q: How does `onReceiveCode` integrate QR scanning? A: It’s passed as `callback` to the scanner; when a QR code is read, it navigates to `'createMeterManual'` with `{ id: code }` to pre-load that record."}
{"text":"File: MeterReading.js, Q: What are `rightButtonProps` used for? A: They configure the header’s QR-scanner button—setting its icon, size, and `onPress` to `openQRCodeScanner`—and are passed as `rightBtn` to `<BaseLayout>`."}
{"text":"File: MeterReading.js, Q: How are `mainLayoutProps` defined and used? A: They include `onBtAddPress: openCreateRecord`, `addPermission: 'MeterReading.Create'`, `showBell`, `noPadding`, `title` localized via `I18n.t('METER_READING_TITLE')`, `showAddButton`, and conditionally `rightBtn` if `isGranted('MeterReading.Create')`."}
{"text":"File: MeterReading.js, Q: How does `<BaseLayout>` compose the screen? A: It spreads `...mainLayoutProps` to configure header controls, then renders `<Filter>` and `<AppList>` as its children, establishing the overall screen layout."}
{"text":"File: MeterReading.js, Q: What prop configures the filter's search input? A: `searchPlaceHolder` is set to `\"COMMON_UNIT_OR_LOCATION\"` inside a code span: ``searchPlaceHolder=\"COMMON_UNIT_OR_LOCATION\"``, guiding the user to search by unit or location."}
{"text":"File: MeterReading.js, Q: How does the component ensure lookup data is available before filtering? A: By calling `getMeterTypes()` and `getMeterSettings()` on mount—before any filter changes—to populate `meterTypes` and `settings` used in the UI."}