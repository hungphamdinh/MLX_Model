{"text":"Q: How does the `SlotView` component determine how many slots have been selected? A: It uses `useMemo` to count `slots.filter(item => item.isCheck).length` and stores it in `totalSelected`, recomputing only when `slots` changes."}
{"text":"Q: What condition makes the “flag” icon appear on a slot? A: `showFlag` becomes true when `totalSelected > 0 && totalSelected < numberSlot`, and each unselected slot adjacent to a selected one gets `isFlag=true`, causing `<SlotFlag/>` to render."}
{"text":"Q: How is the background color of a slot computed? A: `getSlotColor(slot)` returns gray `#E9EBEE` if max slots reached and slot unchecked, primary if `slot.isCheck`, or azure otherwise."}
{"text":"Q: What happens when the user taps a slot? A: `onSelectSlot(index)` toggles `isCheck` for that slot, clears other checks if selecting a non-flag new slot, then recomputes `isFlag` for neighbors before calling `onSlotsChange([...slots])`."}
{"text":"Q: Why does selecting a non-flag slot clear previous selections? A: To ensure contiguous selection, tapping outside the current flagged range resets all `isCheck` flags when the new slot has `isFlag===false`."}
{"text":"Q: How does `onSelectSlot` decide which slots get flagged? A: After toggling, it iterates slots: if an unchecked slot has a checked neighbor (previous or next), it sets `isFlag=true`, marking it as part of a contiguous range."}
{"text":"Q: How are unavailable slots rendered? A: If `item.isAvailable` is false, `SlotView` shows an `<UnavailableSlot>` styled with a grey background and no touch handler, displaying time text only."}
{"text":"Q: How is the time label on each slot formatted? A: `formatSlotTime(start,end)` uses `moment(start,'YYYY-MM-DD HH:mm').format('HH:mm')` for both times, joining them with `-`, e.g. `09:00-10:00`."}
{"text":"Q: What does the `disabled` prop on `<TimeSlot>` do? A: It prevents selecting more than `numberSlot` slots: when `totalSelected===numberSlot` and this slot isn’t checked, `disabled` is true, blocking taps."}
{"text":"Q: How does `FormSlotView` integrate `SlotView` into React Hook Form? A: It uses `useCommonFormController(name)` to get `value`/`setFieldValue`, wraps `SlotView` in `<FormControl>`, and in `onSlotsChange` calls `setFieldValue(newSlots)` plus any `onChange` prop."}
{"text":"Q: How is the maximum number of selectable slots enforced? A: Through the `numberSlot` prop: once `totalSelected` equals `numberSlot`, all other unchecked slots become disabled and greyed out."}
{"text":"Q: What does the empty state look like when there are no slots? A: `SlotView` checks `_.size(slots) > 0`; if false, it renders `<EmptySlotMessage>` with text key `BK_NEW_SLOT_EMPTY`."}
{"text":"Q: How are flags cleared when deselecting slots? A: In `onSelectSlot`, after toggling a slot off, it iterates all slots resetting `isFlag` to false unless they adjoin a checked slot, ensuring flags always reflect current adjacency."}
{"text":"Q: Why does `SlotView` copy the `slots` array before calling `onSlotsChange`? A: To provide a new reference (`[...slots]`) so React Hook Form detects the update and re-renders the form field."}
{"text":"Q: How would you modify the logic to allow non-contiguous slot selection? A: Remove the block in `onSelectSlot` that clears all checks when selecting a non-flag slot, and skip adjacency-based `isFlag` toggling."}
{"text":"Q: How does `SlotView` initialize the display of flags when slots data first loads? A: Flags are initially false; only after a user selection does `onSelectSlot` calculate and set `isFlag` on adjacent slots."}
{"text":"Q: Why does `onSelectSlot` clear all `isCheck` flags when selecting an unchecked, non-flag slot? A: To enforce a single contiguous block selection: tapping outside the current block resets selection to start a new block at that slot."}
{"text":"Q: How does the code ensure that flags always reflect current adjacency after toggling a slot? A: After toggling, it loops through all slots, checking each unchecked slot’s neighbors and setting `isFlag=true` if either neighbor is checked, otherwise clearing it."}
{"text":"Q: What would happen if the flag logic block in `onSelectSlot` were removed? A: Slots adjacent to checked ones would no longer be visually distinguished, breaking the UI cue for contiguous selection."}
{"text":"Q: How is the `numberSlot` prop used to limit user selection? A: It defines the maximum `isCheck` count; once reached, all other unchecked slots are disabled and greyed until the user deselects one."}
{"text":"Q: How could you extend `SlotView` to support a minimum contiguous block size? A: Add a prop `minSlot`; in `onSelectSlot`, prevent toggling off until at least `minSlot` contiguous `isCheck` slots remain, showing an error otherwise."}
{"text":"Q: How does `FormSlotView` propagate external `onChange` behavior? A: It calls the optional `onChange(newSlots)` callback after `setFieldValue`, allowing parent components to react (e.g., updating recurrence logic)."}
{"text":"Q: In `AddOrEditBooking`, how does changing slots trigger recurrence updates? A: The `onChange` passed to `FormSlotView` recomputes `bookingTimes` via `generateTimeSlots` when `recurrence` exists, updating the `recurrence.bookingTimes` field."}
{"text":"Q: Why does `FormSlotView` use `useCommonFormController` instead of `useFormContext().watch` directly? A: `useCommonFormController` encapsulates form registration, value retrieval, setter, and error handling for a given field name, simplifying integration."}
{"text":"Q: How does disabling of slots interact with the disabled form state? A: When `isDisabledForm` is true (edit of canceled/declined), `_commonFormController` likely passes `disabled` into `SlotView`, preventing all taps."}
{"text":"Q: How would you add keyboard accessibility to slot selection? A: Add `accessible` and `accessibilityRole='button'` props to `TimeSlot`, handling `onAccessibilityAction` for selection, and updating `isCheck` accordingly."}
{"text":"Q: What visual feedback could be added when a slot is tapped? A: Add a short `Animated.spring` scale effect on the tapped `TimeSlot`, leveraging the existing `Animated` API used elsewhere in the UI."}
{"text":"Q: How does the design ensure that slot state remains in sync with form state? A: `FormSlotView`’s `value` prop (from `useCommonFormController`) is bound to `slots`, so any external form reset updates the displayed slots immediately."}
{"text":"Q: How could you unit-test the slot adjacency logic? A: Write tests that feed arrays of slots with `isCheck` patterns into `onSelectSlot`, then assert the resulting `isFlag` flags both before and after toggles."}
{"text":"Q: How are stale slot references avoided when updating state? A: By using `onSlotsChange([...slots])`, a new array is created; combined with React Hook Form’s new `value` reference, stale closures are prevented."}
{"text":"Q: What is the significance of checking `idx < slots.length - 2` when flagging next slots? A: Ensures indexing safety: it checks only up to the second-to-last slot (so `idx+1` exists), avoiding out-of-bounds errors."}
{"text":"Q: How does the code handle simultaneous rapid taps on multiple slots? A: Since state updates synchronously in `onSelectSlot`, rapid taps will queue handlers; you may need to debounce `onSelectSlot` to avoid race conditions."}
{"text":"Q: Why use `moment(startTime, 'YYYY-MM-DD HH:mm')` instead of plain JS `Date` parsing? A: `moment` ensures consistent parsing across platforms and locales, matching the backend format precisely for user display."}
{"text":"Q: How could you display tooltips for each slot’s exact ISO timestamp? A: Wrap `SlotText` in a `Tooltip` component, showing the original `startTime` and `endTime` on long press or hover."}
{"text":"Q: What happens to slot selections when the date changes? A: In `AddOrEditBooking`, changing `startEndDate` triggers `getBookingTimeSlots`, which calls `setValue('slots', bookingSlots)` resetting selections to the new date’s slots."}
{"text":"Q: How does the effect `useEffect([bookingSlots])` ensure new slots are loaded for add mode? A: It watches `bookingSlots` from context; when they update (from API), it calls `formMethods.setValue('slots', bookingSlots)` for fresh data."}
{"text":"Q: How is `bookingSlots` fetched in the first place? A: `useBooking()` hook’s `getAllTimeSlots` is called in `useEffect([startDate,endDate,amenityDetail])`, populating `bookingSlots` via context/saga."}
{"text":"Q: How would you optimize rendering for large numbers of slots? A: Use `FlatList` instead of mapping over arrays, with `initialNumToRender`, `windowSize`, and `getItemLayout` for performance on hundreds of slots."}
{"text":"Q: How does slot selection affect deposit recalculation? A: `calculateDepositPrice` effect depends on `slots`; any change (via `onSlotsChange`) triggers deposit logic to update form field `depositPrice`."}
{"text":"Q: Why doesn’t `calculateDepositPrice` run directly in `onSelectSlot`? A: Separation of concerns: selection handler only updates slots; a dedicated effect recalculates deposit, keeping side effects centralized."}
{"text":"Q: How would you display a loading state while slots are fetched? A: Introduce an `isLoadingSlots` flag in context, render a spinner overlay in `SlotView` when true, hiding slot buttons until ready."}
{"text":"Q: How can you preserve slot selection when switching between add and edit modes? A: Store `slots` in component state or context keyed by booking ID, re-inject via `formMethods.reset` in `getInitialValuesForUpdate` for edit mode."}
{"text":"Q: How do you handle timezone differences in slot times? A: Ensure `getBookingTimeSlots` and `formatSlotTime` both use the same timezone context (via `moment.tz`), so labels match the user’s local zone."}
{"text":"Q: How can `numberSlot` be dynamically computed based on amenity rules? A: Pass `numberSlot={amenityDetail.numOfExtendTimeSlot + 1}` into `FormSlotView`, as current code fetches via `_.get` in JSX."}
{"text":"Q: What visual change indicates the slot limit has been reached? A: Unchecked slots turn grey and `disabled`, preventing taps; flags and selected slots remain colored to show active block."}
{"text":"Q: How would you add multi-touch support to extend selection? A: On touch-move across slots, detect drag gestures and call `onSelectSlot` for each slot under the finger, enabling click-and-drag selection."}
{"text":"Q: How could you allow deselecting the first slot of a block? A: Modify the clear-all logic: if the tapped slot is at the block edge (`isFlag===true`), allow toggling it off without clearing the whole block."}
{"text":"Q: What accessibility label would you assign to slots? A: Use `accessibilityLabel={Slot from ${formatSlotTime(start,end)} ${slot.isCheck? selected : unselected}}` on each `TimeSlot`."}
{"text":"Q: How does the component handle stale `recurrence` when slots change? A: The passed `onChange` resets `recurrence.bookingTimes` via `generateTimeSlots`, keeping recurrence in sync with slot selection."}
{"text":"Q: How to prevent slot selection when form is disabled? A: Wrap `SlotView` in `<FormDisabledProvider>` so `useCommonFormController` passes `disabled` prop, disabling all touch handlers conditionally."}
{"text":"Q: How does the slot component clean up memory on unmount? A: No subscriptions in `SlotView`; once unmounted, its state and handlers are garbage-collected automatically."}
{"text":"Q: How to extend slot logic for variable-length bookings? A: Add a `duration` prop per slot; in `onSelectSlot`, allow selection of non-adjacent slots if their durations sum to the requested total."}
{"text":"Q: How do you integrate real-time slot availability updates? A: Subscribe to a WebSocket feed for slot changes; on messages update `bookingSlots` in context, triggering form reset in `FormSlotView`."}
{"text":"Q: How can you test end-to-end slot booking flows? A: Write E2E tests that navigate to add-booking screen, select date, wait for slots, tap contiguous and non-contiguous slots, verify flags, save, and assert booking success."}
{"text":"Q: How to handle daylight savings transitions in slot times? A: Use `moment.tz` with fixed timezone for both fetching and formatting, ensuring slot intervals shift correctly on DST change days."}
{"text":"Q: Why does the component avoid using slot index as the key in lists? A: It uses `index.toString()`, which is acceptable here as slot order doesn’t change dynamically; for dynamic lists, a unique ID would be safer."}
{"text":"Q: How would you internationalize slot time formats? A: Replace `moment.format('HH:mm')` with `moment.locale(I18n.locale).format('LT')`, using locale-specific 12/24-hour conventions."}
{"text":"Q: How could you visualize available vs unavailable slots differently? A: Add opacity or an icon overlay to unavailable slots, beyond just grey background, improving user clarity."}
{"text":"Q: How to optimize `formatSlotTime` for large arrays? A: Precompute and cache formatted strings on slot fetch, storing alongside each slot, rather than recalculating on every render."}
{"text":"Q: How does the code ensure `slots` always has a default? A: The prop default `slots = []` in function signature prevents undefined errors in mapping and filtering operations."}
{"text":"Q: How would you add swipe-to-clear functionality across selected slots? A: Detect horizontal swipe gestures on `TimeSlotBox` and clear all `isCheck` by calling `onSlotsChange([])` on swipe end."}
{"text":"Q: What improvements could be made for long-press selection? A: Long-press a slot to select a range: on long-press start record index, on long-press end select all slots between start and end indices."}
{"text":"Q: How to handle server-side slot booking conflicts after local selection? A: After user taps Save, revalidate slots via API; on conflict, highlight conflicted slots and prompt user to adjust selection."}
{"text":"Q: How can you add visual grouping by hour or day? A: In `SlotView`, group `slots` by date/hour, render headings between groups in the map, improving readability for multi-day slots."}
{"text":"Q: How does state immutability ensure predictable updates? A: By creating new arrays (`[...slots]`) and objects for flags/checks, React’s change detection reliably triggers re-renders and avoids mutation bugs."}
{"text":"Q: How does the AddOrEditBooking component decide whether to create a new booking or update an existing one? A: It reads `useRoute().name` and sets `isAddNew = name==='addBooking'`; in `onSave`, it calls `addBooking(payload)` if `isAddNew` is true, otherwise `updateBooking(payload)`."}
{"text":"Q: Which core data fields must be included in the payload for both add and edit operations? A: `amenityId`, `startDate`, `endDate`, `status` (statusCode), `bookingType`, `files` (only new uploads), and optionally `paymentStatus` if deposits are used."}
{"text":"Q: How are `startDate` and `endDate` computed for a new booking? A: They derive from the first and last checked slot’s `startTime` and `endTime` respectively, inside `onSave` when `isAddNew` is true."}
{"text":"Q: How are `startDate` and `endDate` handled for editing? A: When `isAddNew` is false, the payload reuses `bookingDetail.startDate` and `bookingDetail.endDate` without modification."}
{"text":"Q: How does the code filter out already-uploaded files before sending the payload? A: It runs `formValues.files.filter(item => item.path)` to include only files with a local `path` property for upload."}
{"text":"Q: How is the `status` field represented in the payload? A: It takes `formValues.status.statusCode` and assigns it to the `status` key in `payload`."}
{"text":"Q: When should the `paymentStatus` field be included in the payload? A: Only if `amenityDetail.isUseDeposited` is true; it sets `payload.paymentStatus = formValues.paymentStatus.paymentStatusCode`."}
{"text":"Q: How does the handler include occupier-specific fields in the payload? A: For `bookingType===occupier`, it adds `buildingId`, `unitId`, `fullUnitId`, `userId`, `name`, `userName`, `phone`, `email`, and `emailAddress` from the `unit` and contact form values."}
{"text":"Q: How does the handler include company-specific fields? A: For `bookingType===company`, it sets `payload.companyId=formValues.company.id`, `payload.name=formValues.company.companyName`, and `payload.email=formValues.company.primaryEmail`."}
{"text":"Q: How does the handler include outsider-specific fields? A: For `bookingType===outsider`, it simply sets `payload.email = formValues.email`."}
{"text":"Q: What logic handles recurring bookings inside `onSave`? A: If `formValues.recurrence` exists, `onSave` calls `await recurringBooking(formValues, payload)` and returns early, skipping the single-date API call."}
{"text":"Q: How does `recurringBooking` build its payload differently? A: It deletes `startDate`/`endDate`, maps `rec.bookingTimes` into `bookingObj.bookingTimes`, and calls `validateRecurringBooking` instead of `addBooking/updateBooking`."}
{"text":"Q: How are API errors handled during add/update operations? A: Currently errors in `recurringBooking` are caught and show `Alert.alert('ERROR', error.message)`; similar try/catch could wrap `addBooking/updateBooking` to alert the user."}
{"text":"Q: What happens after a successful add or update? A: It emits `DeviceEventEmitter.emit('UpdateListBooking')` to refresh other screens, then calls `navigation.goBack()` to return."}
{"text":"Q: Why is `files.filter(item => item.path)` used instead of sending all files? A: To avoid re-uploading files already stored on the server, sending only new local files with a `path`."}
{"text":"Q: How does the form’s validation schema enforce slot selection for new bookings? A: It adds a Yup `slots` array test when `isAddNew` is true, requiring at least one element with `isCheck===true`."}
{"text":"Q: How is the deposit price recalculated after slot changes? A: A `useEffect` watching `calculateDepositPrice` (which depends on `slots`) updates the `depositPrice` form field via `setValue`."}
{"text":"Q: How does the component disable form inputs when editing a canceled or declined booking? A: In the `bookingDetail` effect, it checks status codes and sets `isDisabledForm=true`, which `<FormDisabledProvider>` uses to disable all controls."}
{"text":"Q: What role does `reset(getInitialValuesForUpdate())` play when editing? A: It populates the form with the existing booking’s values, including nested fields, ensuring the payload matches current data if unchanged."}
{"text":"Q: How does `getInitialValuesForUpdate` handle nested fields for different booking types? A: It conditionally adds `unit`, `company`, or `email` fields based on `bookingDetail.bookingType`, matching the shape expected by form controls."}
{"text":"Q: How is `validateRecurringBooking` result integrated back into the UI? A: The success response populates `bookingRequestData`, triggers the confirmation modal, and displays valid/invalid slots before final save."}
{"text":"Q: How does the code ensure `onSave` is only called after form validation? A: The Save button’s `onPress` is `handleSubmit(onSave)`, which runs React Hook Form’s resolver before invoking `onSave`."}
{"text":"Q: How can you handle API timeouts or network errors in `onSave`? A: Wrap the `addBooking/updateBooking` call in try/catch and show an `Alert.alert('Error', error.message)` on failure."}
{"text":"Q: How would you extend error handling to retry failed saves? A: In the catch block, present the user with an option to retry by calling `onSave(formMethods.getValues())` again if they confirm."}
{"text":"Q: Why does the code use both `bookingDetail` and `formValues` when building the edit payload? A: To preserve any unchanged fields (dates, contact info) while applying only modified form values."}
{"text":"Q: How is form state reset after a successful save? A: Currently navigation.goBack unmounts the component; to reset in-place, call `reset(initialValues)` on success instead of navigating."}
{"text":"Q: How can you surface server-side validation errors to users? A: Catch errors from `addBooking/updateBooking`, parse `error.response.data`, and pass specific messages into `Alert.alert` or inline form errors via `setError`."}
{"text":"Q: How does the UI reflect that a booking is being saved? A: You could add an `isSaving` state, disable the Save button, and show a spinner in the button until the promise resolves."}
{"text":"Q: How does the payload handle custom booking properties like `purposeId` and `numberOfPerson`? A: These are spread from `formValues` into `payload`, ensuring optional fields are included if filled."}
{"text":"Q: What ensures consistency between the form’s `bookingType` array and the payload’s `bookingType` scalar? A: The code reads `const bookingType = watch('bookingType')[0]` then includes that in `payload.bookingType`."}
{"text":"Q: How would you validate `files` before uploading? A: Add a Yup test on `files` in the validation schema to check file size/type, preventing uploads of invalid files."}
{"text":"Q: What event triggers reloading the booking list elsewhere in the app? A: `DeviceEventEmitter.emit('UpdateListBooking')` notifies listeners (e.g., booking list screen) to refresh data."}
{"text":"Q: How can you unit-test the add/edit logic in `onSave`? A: Mock `addBooking` and `updateBooking`, provide known formValues, call `onSave`, and assert correct payload passed and navigation/emitter calls executed."}
{"text":"Q: How is the `navigation` prop used after saving? A: It calls `navigation.goBack()` to return to the previous screen, reflecting the updated booking list."}
{"text":"Q: How could you centralize payload construction to avoid duplication? A: Extract a `buildPayload(formValues, bookingDetail, isAddNew)` helper that returns a new or updated payload object."}
{"text":"Q: How does the component decide between “Add” and “Edit” mode at startup? A: It reads useRoute().name and sets isAddNew = (name==='addBooking'), isEdit = (name==='editBooking'). This controls which effects run, which UI elements display, and whether addBooking or updateBooking is called."}
{"text":"Q: Why is id = params?.id important, and how is it used? A: In edit mode, id tells the component which booking to fetch via getBookingDetail(id). Without it, there’s no context for populating the form with existing data."}
{"text":"Q: Which pieces of data must be loaded before rendering the form, and how is loading handled? A: amenityDetail (to know available slots, deposit rules), bookingSlots (initial slot availability), and reference files. A <LoaderContainer> wraps the form, showing <BookingLoading> until amenityDetail is truthy."}
{"text":"Q: How are default form values provided for a new booking? A: Via initialValues, including defaults for status (REQUESTED), payment (NOT_YET_DEPOSIT), bookingType ([occupier]), empty slots, files, etc."}
{"text":"Q: How does getInitialValuesForUpdate() shape the form for editing? A: It maps fields from bookingDetail into the same shape as the form’s defaultValues, including nested unit/company/email objects based on bookingType."}
{"text":"Q: Which UI sections are only shown in “Add” mode? A: <FormCalendarPicker> date selector, the slot picker (<FormSlotView>), and booking warning text (when outside the booking period)."}
{"text":"Q: Which UI elements are suppressed in “Edit” mode? A: Date picker, slot selector, and recurrence controls—because editing cannot change the reservation’s time slots or recurrence pattern."}
{"text":"Q: How does the component show the existing booking time in edit mode? A: It renders <InfoRow> components showing a clock icon with “HH:mm – HH:mm” and a calendar icon with the booking date."}
{"text":"Q: How are available time slots initially populated? A: On mount or date/amenity changes, getBookingTimeSlots() calls getAllTimeSlots({amenityId,fromDate,toDate}), and an effect sets formValues.slots = bookingSlots."}
{"text":"Q: When is the deposit price recalculated? A: In a useEffect that watches the calculateDepositPrice callback, which depends on slots. Thus, any slot change triggers recalculation."}
{"text":"Q: How is the correct deposit rule matched? A: It filters selected slots, extracts the first and last slot’s day and time, then finds a matching rule in amenityDetail.amenityTimeRules by numNextValidDate, startTime, and endTime."}
{"text":"Q: How does the “Recurring” feature integrate into the Add form? A: If amenityDetail.isAllowRecurring is true, <BookingRecurring> renders. Its onSubmitForm sets formValues.recurrence, toggling the recurring flow."}
{"text":"Q: How does onSave branch for recurring bookings? A: If formValues.recurrence exists, it calls await recurringBooking(formValues, payload) and returns early, deferring the actual API call until after confirmation."}
{"text":"Q: What does validateRecurringBooking do? A: It checks all requested slots for availability without creating bookings, returning validSlots and invalidSlots for user confirmation."}
{"text":"Q: What happens when the user confirms the recurring booking? A: handleConfirmBooking remaps validSlots to bookingData.bookingTimes, calls recurringBooking(bookingData), then navigates back and emits UpdateListBooking."}
{"text":"Q: How can the user remove invalid or unwanted slots? A: In <BookingRecurringConfirmation>, each valid slot row has a trash icon; tapping triggers handleRemoveSlot, which filters out that slot."}
{"text":"Q: How are default and new files handled in the payload? A: onSave filters formValues.files for items with a local path property, so only new uploads are sent; existing files remain untouched."}
{"text":"Q: How does the component disable form inputs for canceled/declined bookings? A: After fetching bookingDetail, it checks if statusCode is CANCELED or DECLINED and sets isDisabledForm=true, which <FormDisabledProvider> uses to disable all fields."}
{"text":"Q: How does the payload handle custom booking properties like `purposeId` and `numberOfPerson`? A: These are spread from formValues into payload, ensuring optional fields are included if filled."}
{"text":"Q: What ensures consistency between the form’s `bookingType` array and the payload’s `bookingType` scalar? A: The code reads const bookingType = watch('bookingType')[0] then includes that in payload.bookingType."}
{"text":"Q: How would you validate `files` before uploading? A: Add a Yup test on `files` in the validation schema to check file size/type, preventing uploads of invalid files."}
{"text":"Q: How can you unit-test the add/edit logic in `onSave`? A: Mock addBooking and updateBooking, provide known formValues, call onSave, and assert correct payload passed and navigation/emitter calls executed."}
{"text":"Q: What event triggers reloading the booking list elsewhere in the app? A: DeviceEventEmitter.emit('UpdateListBooking') notifies listeners (e.g., booking list screen) to refresh data."}
{"text":"Q: How is the navigation prop used after saving? A: It calls navigation.goBack() to return to the previous screen, reflecting the updated booking list."}
{"text":"Q: What is the purpose of the `BookingRecurringConfirmation` component? A: To display a modal summarizing the results of a recurring booking validation, showing valid and invalid slots, metadata (requestedBy, amenityName, createdDate, status), and allowing the user to remove slots or confirm the booking."}
{"text":"Q: How does `buildConfirmationObj` transform `bookingRequestData` into `localData`? A: It deep-clones `bookingRequestData`, maps each `bookingTimes` slot to include an `isAvailable` boolean and a formatted `timeRange`, then separates them into `validSlots` and `invalidSlots`, and copies over metadata fields (`requestedBy`, `amenityName`, `createdDate`, `status`)."}
{"text":"Q: Why is `cloneDeep` used in `buildConfirmationObj` and `handleConfirmBooking`? A: To avoid mutating the original `bookingRequestData` object, ensuring immutability and state isolation when filtering and remapping slots."}
{"text":"Q: How is the `isAvailable` flag determined for each slot? A: By checking `slot.isAvailable !== false` (treating undefined or true as available) and storing the result in the mapped slot object."}
{"text":"Q: What format does `getTimeRange` produce for each slot? A: It returns a string like `YYYY/MM/DD HH:mm - HH:mm`, using `formatDate(slot.startDate)` for the date and `moment.utcOffset(tz).format('HH:mm')` for start and end times, where `tz` is derived from the ISO string offset."}
{"text":"Q: How does `getTimeZone` extract the timezone offset from a date string? A: If the input is a string, it takes characters 19–25 of the string (`YYYY-MM-DDTHH:mm:ss+07:00`) to get `+07:00`; otherwise defaults to `+07:00`."}
{"text":"Q: Why wrap `BookingRecurringConfirmation` with `withModal`? A: To inject `visible` and `onClosePress` props and automatically render the component inside a `<Modal>` with the specified modal key, standardizing show/hide behavior."}
{"text":"Q: How does the component initialize its state when `bookingRequestData` changes? A: A `useEffect` hook watches `bookingRequestData` and calls `setLocalData(buildConfirmationObj(bookingRequestData))`, ensuring the UI always reflects the latest data."}
{"text":"Q: What UI element shows invalid slots to the user? A: A red `<Text>` above the metadata, rendering `CANNOT_BOOKING_ON: ` followed by the joined `invalidSlots.timeRange` values."}
{"text":"Q: How are valid slots rendered in the list? A: Via a `<SlotList>` FlatList with `data={localData.validSlots}`, `keyExtractor={(item,i)=>String(i)}`, and `renderItem={renderSlot}` showing each slot’s index and timeRange."}
{"text":"Q: Describe the JSX structure of each slot row. A: `<SlotRow>` with a `<Row>` showing `#${index+1}` and the slot’s `timeRange`, followed by a `<RemoveBtn>` containing a trash icon that calls `handleRemoveSlot(index)`."}
{"text":"Q: What confirmation does `handleRemoveSlot` present to the user? A: An `Alert.alert` with title `REMOVE_BOOKING_CONFIRMATION`, Cancel and Remove buttons; the Remove button’s `onPress` filters out the slot at the given index from `localData.validSlots`."}
{"text":"Q: How does removing a slot affect the confirmation flow? A: It updates `localData.validSlots`; if the user later presses Confirm, only the remaining slots are sent in the final booking request."}
{"text":"Q: What happens when the user presses the Confirm button? A: `handleConfirmBooking` deep-clones `bookingRequestData`, replaces `bookingTimes` with the filtered `validSlots`, deletes `validSlots`/`invalidSlots`, calls `recurringBooking(bookingData)`, then `onClosePress()`, navigates back and emits `UpdateListBooking` if successful."}
{"text":"Q: Why delete `validSlots` and `invalidSlots` before calling the API? A: Because the API expects only `bookingTimes` array; extra keys would be ignored or cause payload validation errors."}
{"text":"Q: How does the component navigate away after confirmation? A: After `recurringBooking` resolves truthily, it calls `NavigationService.goBack()` to exit the modal/screen and `DeviceEventEmitter.emit('UpdateListBooking')` to refresh the booking list."}
{"text":"Q: How are the Cancel and Confirm buttons rendered conditionally? A: In `<ButtonsRow>`, Cancel always appears; Confirm is shown only if `localData.validSlots.length > 0`, preventing confirmation with no slots."}
{"text":"Q: What local state shape is stored in `localData`? A: An object with arrays `validSlots`, `invalidSlots`, and strings `requestedBy`, `amenityName`, `createdDate`, `status`."}
{"text":"Q: How are dates formatted for `COMMON_CREATED_DATE`? A: `new Date(localData.createdDate).toLocaleString()` is used in `<LabelValue>` to display the human-readable creation timestamp."}
{"text":"Q: What is the role of the `LabelValue` subcomponent? A: To render bold label text (`I18n.t(labelKey)`) followed by the corresponding `value`, used for metadata fields."}
{"text":"Q: Why map over `bookingTimes || []` instead of assuming it’s always defined? A: To handle cases where `bookingTimes` is undefined or null, preventing runtime errors by defaulting to an empty array."}
{"text":"Q: How could you handle a failure in `recurringBooking` inside `handleConfirmBooking`? A: Wrap the API call in try/catch, show `Alert.alert('ERROR', error.message)` on catch, and avoid closing the modal until success."}
{"text":"Q: What Lodash functions are used and why? A: `cloneDeep` for immutability, `map` for transforming arrays, `filter` for separating valid/invalid slots, and `size` to count `invalidSlots` before rendering the warning."}
{"text":"Q: How is `size(localData.invalidSlots) > 0` used? A: To conditionally render the invalid-slots warning text only when there is at least one invalid slot."}
{"text":"Q: How would you add a “Select All” button for valid slots? A: Include a `<Button title='Select All' onPress={() => setLocalData({...localData, validSlots:buildConfirmationObj(bookingRequestData).validSlots})}/>` above the `<SlotList>`."}
{"text":"Q: How can you provide an “Undo” for removed slots? A: Maintain a separate `removedSlots` array in state, push removed slots there, and add an “Undo” button that restores the last removed slot to `validSlots`."}
{"text":"Q: What accessibility props should be added to the modal buttons? A: `accessibilityLabel` (e.g., 'Confirm Recurring Booking'), `accessibilityRole='button'`, and `accessible={true}` for better screen reader support."}
{"text":"Q: How would you unit-test `buildConfirmationObj`? A: Provide a mock `bookingRequestData` with mixed `bookingTimes` having `isAvailable` flags, call `buildConfirmationObj`, and assert correct `validSlots`/`invalidSlots` arrays and metadata outputs."}
{"text":"Q: Why does `getTimeRange` use `utcOffset(tz)` on both start and end times? A: To interpret the ISO timestamp correctly in the intended timezone, ensuring displayed times match the server’s offset."}
{"text":"Q: How could you memoize `buildConfirmationObj` to optimize re-renders? A: Wrap it in `useCallback` or use `useMemo(() => buildConfirmationObj(data), [data])` to avoid rebuilding arrays unnecessarily."}
{"text":"Q: How do you ensure the modal’s list scrolls when there are many slots? A: The `SlotList` FlatList has a `max-height:200px` style and is scrollable by default, so overflow scrolls inside the modal container."}
{"text":"Q: How can you highlight invalid slots visually? A: Change the warning text color or add an icon beside each invalid `timeRange` in the warning message to draw attention."}
{"text":"Q: What could go wrong if `bookingRequestData` changes while the modal is open? A: The `useEffect` will overwrite `localData`, potentially losing user-removed slots; consider ignoring updates if `localData` has been modified."}
{"text":"Q: How does the component prevent memory leaks on unmount? A: There are no subscriptions created in `BookingRecurringConfirmation`; the `useEffect` setter is safe and no cleanup is needed."}
{"text":"Q: How would you add a “Review Recurrence Rules” section above the slot list? A: Insert a `<Text>` summarizing `bookingRequestData.frequency`, `every`, and `onType` fields before the warning, using `LabelValue` or custom formatting."}
{"text":"Q: How can you ensure `handleConfirmBooking` only fires once? A: Use an `isSubmitting` ref or state to ignore subsequent presses until the first promise resolves, preventing duplicate API calls."}
{"text":"Q: Why delete both `validSlots` and `invalidSlots` before sending the final request? A: To avoid sending extraneous data to the API and ensure the payload matches the expected schema (only `bookingTimes`)."}
{"text":"Q: How can you add loading indicators to the Confirm button? A: Pass a `loading={isSubmitting}` prop to `<Button>` (if supported) or conditionally render an `<ActivityIndicator>` alongside the button text."}
{"text":"Q: How would you internationalize the slot time format? A: Replace `formatDate` and `moment.format('HH:mm')` with `moment.locale(I18n.locale).format('L LT')` to use locale-specific date/time patterns."}
{"text":"Q: How is `onClosePress` implemented by `withModal`? A: `withModal` injects a function that hides the modal by toggling a `visible` prop in the parent HOC’s state."}
{"text":"Q: How could you refactor `BookingRecurringConfirmation` to accept a custom slot renderer? A: Add a `renderSlotItem` prop and replace `renderItem={renderSlot}` with `renderItem={renderSlotItem || renderSlot}` to allow injection."}
{"text":"Q: What best practice does splitting out `LabelValue` illustrate? A: DRY UI code: reuse a small component for consistent label-value pairs, reducing duplication and ensuring uniform styling."}
{"text":"Q: How would you extend the component to show reasons for invalid slots? A: Have the API return `invalidSlots` objects with a `reason` field, then render each as `item.timeRange + ' (' + item.reason + ')'`."}
{"text":"Q: How do you test the Alert in `handleRemoveSlot`? A: Use Jest mocking of `Alert.alert` to capture the callback array, simulate pressing the remove button by calling the `onPress` function, and assert `localData.validSlots` updates."}
{"text":"Q: How does the component handle confirmation if all slots become invalid? A: Since `localData.validSlots.length === 0`, the Confirm button is hidden, forcing the user to cancel or adjust their selection."}
{"text":"Q: What cleanup might be needed if `recurringBooking` is canceled mid-request? A: Cancel the API request (e.g., via AbortController) and reset any `isSubmitting` flags in a finally block to restore UI interactivity."}
{"text":"Q: How can you integrate analytics for user actions in this modal? A: Call an event tracking function inside `handleRemoveSlot` and `handleConfirmBooking`, logging slot counts and user decisions."}
{"text":"Q: How would you add keyboard navigation for the slot list? A: Use React Native’s `onFocus` and `onKeyPress` handlers on each `<RemoveBtn>`, managing focus order and activating removal with the Delete key."}
{"text":"Q: How does the modal’s styling ensure readability on small screens? A: The `Container` has padding and the `SlotList` a max-height, scrolling internally, so content doesn’t overflow off-screen."}
{"text":"Q: How could you extract duplicate metadata logic into a hook? A: Create `useConfirmationData(bookingRequestData)` returning `{localData, handleRemoveSlot, handleConfirmBooking}` to share with other confirmation screens."}
{"text":"Q: What are the key differences between single and recurring booking confirmation flows? A: Single bookings skip this modal and call `addBooking` directly; recurring bookings require validation, user slot pruning, and two-step API calls."}
{"text":"Q: What is the role of the `Booking` component? A: It displays a paginated list of bookings, provides filtering and search capabilities, and allows navigating to add or edit booking screens."}
{"text":"Q: How does the component fetch initial filter data? A: In the first `useEffect([])`, it calls `getBookingStatus()`, `getPaymentStatus()`, and `getAmenities()` from the `useBooking` hook to populate dropdown options."}
{"text":"Q: What is `defaultFilter` and how is it structured? A: An object with keys `dateRange`, `statusIds`, `isIncludeExpired`, `paymentStatusIds`, `amenityIds`, and `multipleOptions`, providing the baseline filter values on mount."}
{"text":"Q: How is `dateRange` initialized by default? A: Using `getDefaultDateRange()`, which returns start and end dates for the current default period (e.g., current week or month)."}
{"text":"Q: How are multiple-options filters handled? A: `multipleOptions` is an array containing flags `onlyActiveAmenity` and `isIncludeExpired`, allowing toggling those behaviors in the API call."}
{"text":"Q: What is the `filters` object and how does it drive the `<Filter>` UI? A: It maps filter keys (e.g., `statusIds`, `paymentStatusIds`, `amenityIds`, `multipleOptions`) to configuration objects with titles, options, and metadata for the Filter component to render appropriate controls."}
{"text":"Q: How does the `amenityIds` filter differ from the others? A: It uses `type: FilterTypes.DROPDOWN`, passes `amenitiesFilter` options, and includes `dropdownProps` (e.g., `showSearchBar: true`) to enable searching within the dropdown."}
{"text":"Q: What state variables manage filter behavior? A: `bookingFilter` holds the default filter and is not used further; `selectedFilter` holds the current filter and drives API calls; both initialized to `defaultFilter`."}
{"text":"Q: Why is `setSelectedFilter = setBookingFilter` in the `useState` signature? A: It appears to be a typo; normally `const [selectedFilter, setSelectedFilter] = useState(bookingFilter)` is used to allow updating the filter."}
{"text":"Q: How is text search implemented? A: A `textSearch` state drives the keyword passed to `getList`; updating `textSearch` triggers a new fetch via the `useEffect([textSearch, selectedFilter])` hook."}
{"text":"Q: How does the component react to filter or search changes? A: In `useEffect([textSearch, selectedFilter])`, it calls `getList(1)` to reload the first page whenever either changes."}
{"text":"Q: How does the component subscribe to external list updates? A: In `useEffect([])`, it adds a `DeviceEventEmitter` listener for `'UpdateListBooking'` that calls `getList(1)` when triggered, and removes the listener on unmount."}
{"text":"Q: Why remove the subscriber on cleanup? A: To avoid memory leaks and duplicate event handling when the component unmounts or remounts."}
{"text":"Q: What parameters does `getList` accept and default to? A: `(page = 1, keyword = textSearch, filter = selectedFilter)`; page resets to 1 for new searches/filters, keyword and filter come from state."}
{"text":"Q: How are date filters converted before API calls? A: `fromDate` and `toDate` from `filter.dateRange` are converted via `convertDate.stringToISOString` if they exist, matching the backend format."}
{"text":"Q: How are boolean flags derived in `getList`? A: `isIncludeExpired` and `onlyActiveAmenity` are derived by checking if their respective values exist in `filter.multipleOptions`, or set to `null` if not."}
{"text":"Q: What sorting order is applied by default? A: `'createdAt desc'` is added to `filterParams` to sort bookings by creation date descending."}
{"text":"Q: How does the component trigger the API call? A: It calls `filterBookings({ page, pageSize: PAGE_SIZE, keyword, ...filterParams })` provided by `useBooking`."}
{"text":"Q: What is `PAGE_SIZE` and why is it used? A: A constant defining how many items to fetch per page, ensuring consistent pagination across screens."}
{"text":"Q: How is pagination handled in the UI? A: Via the `AppList` component receiving `isRefresh`, `isLoadMore`, `currentPage`, `totalPage`, and `loadData` props for infinite scroll or load-more behavior."}
{"text":"Q: What is the structure of `list` from `useBooking`? A: An object containing `data` (array of bookings), `isRefresh`, `isLoadMore`, `currentPage`, and `totalPage`."}
{"text":"Q: How is the “Add Booking” action wired? A: The BaseLayout’s `onBtAddPress` prop is set to `onBtAddPress`, which sets `visibleSelectAmenity = true`, opening the amenity selection modal."}
{"text":"Q: How does `SelectAmenityModal` integrate? A: Rendered at the bottom of the JSX, controlled by `visibleSelectAmenity`, with `onSelect` calling `getAmenityDetail` and navigating to 'addBooking' screen."}
{"text":"Q: What steps occur when an amenity is selected? A: `onAmenitySelect` sets the modal invisible, calls `getAmenityDetail(amenity.amenityId)` to prefetch details, then `NavigationService.navigate('addBooking')` to open the add screen."}
{"text":"Q: Why prefetch `getAmenityDetail` before navigation? A: To speed up the AddBooking screen load by having amenity data ready in the context when the screen mounts."}
{"text":"Q: How does the component navigate to edit mode? A: In `renderItem`, the `ItemBooking` receives an `onPress={() => gotoDetail(item)}`, and `gotoDetail` calls `NavigationService.navigate('editBooking', { id: item.reservationId })`."}
{"text":"Q: What is the shape of each `item` in the list? A: A booking object containing at minimum `reservationId` (for detail navigation) and other fields for display by `ItemBooking`."}
{"text":"Q: How is `renderItem` implemented and why wrap in a function? A: As `const renderItem = (item) => <ItemBooking item={item} onPress={...} />` then passed via `renderItem={({ item }) => renderItem(item)}` to keep code clean."}
{"text":"Q: How does the component ensure unique keys? A: By using `keyExtractor: (item) => ${item.id}` where `item.id` is assumed to be unique for each booking."}
{"text":"Q: How can the user trigger a search manually? A: The `<Filter>` component’s `onSearch={onTextSearchChange}` prop updates `textSearch` state when the search input changes."}
{"text":"Q: How are filter changes applied? A: The `<Filter>` component’s `onCompleted={onApplyFilter}` prop calls `setSelectedFilter(value)`, triggering the effect to reload `getList(1)`."}
{"text":"Q: How does the Filter component know current selections? A: It receives `selectedFilter={selectedFilter}` and `defaultFilter={defaultFilter}` to manage its internal UI state."}
{"text":"Q: What placeholder does the search input show? A: The string `BOOKING_SEARCH_PLACEHOLDER` which is internationalized by I18n in the Filter component."}
{"text":"Q: Why use `useMemo` anywhere in this component? A: None in this snippet; one could memoize `filters` or `getList` definition to avoid unnecessary re-renders, but usage is minimal."}
{"text":"Q: How would you debounce the search input? A: Wrap `onTextSearchChange` in a debounced function (e.g., using `lodash.debounce`) so `getList` isn’t called on every keystroke immediately."}
{"text":"Q: How can you display a default empty state icon? A: The `AppList` receives `iconName: icons.jobRequestEmpty`, showing it when `data.length===0`."}
{"text":"Q: How is pull-to-refresh handled? A: `AppList` uses its `isRefresh` and `loadData` props to trigger `getList(1)` when the user pulls down on the list."}
{"text":"Q: How is load-more on scroll handled? A: `AppList` also uses `isLoadMore`, `currentPage`, `totalPage`, and calls `loadData({ page: currentPage+1 })` when the user scrolls near the bottom."}
{"text":"Q: How can you show a loading spinner during initial load? A: `AppList` or `BaseLayout` could show an activity indicator; in this component, no explicit loader is shown, assuming `AppList` handles its own loading UI."}
{"text":"Q: What event should be emitted after adding or editing a booking? A: `DeviceEventEmitter.emit('UpdateListBooking')` should be called by the Add/Edit screens to refresh this list via the subscriber."}
{"text":"Q: How is the list refreshed after returning from Add/Edit? A: The `DeviceEventEmitter` listener triggers `getList(1)` when the event fires, ensuring the latest data appears."}
{"text":"Q: What potential memory leaks exist and how to fix them? A: Failing to remove the DeviceEventEmitter listener could leak; this component correctly calls `subscriber.remove()` in the cleanup function."}
{"text":"Q: How would you add a “Refresh” button in the header? A: Pass a `rightButtons` prop to `BaseLayout` with a refresh icon that calls `getList(1)` when pressed."}
{"text":"Q: How can you persist filter state across navigations? A: Store `selectedFilter` in context or URL params, and initialize state from that when the component mounts."}
{"text":"Q: How would you add a “Clear Filters” button? A: Provide a button that calls `setSelectedFilter(defaultFilter)` and resets `textSearch` to `''`."}
{"text":"Q: How could you disable the Add button conditionally? A: Use `showAddButton={!someCondition}` or replace `onBtAddPress` with a no-op if the user lacks permissions."}
{"text":"Q: What should you be careful about when calling `getList` inside effects? A: Always include dependencies `[textSearch, selectedFilter]` so stale closures don’t use old filter or search values."}
{"text":"Q: How can you add analytics for filter usage? A: In `onApplyFilter`, call an analytics tracking function with the new filter values to capture user behavior."}
{"text":"Q: How would you handle API errors from `filterBookings`? A: Add error handling in the hook or pass an `onError` callback to show an `Alert.alert` on failure."}
{"text":"Q: How can you ensure keyboard dismissal after search? A: In `onTextSearchChange`, call `Keyboard.dismiss()` after setting `textSearch` to hide the keyboard on mobile."}
{"text":"Q: How to make `getList` stable across renders? A: Wrap it in `useCallback` with dependencies `[textSearch, selectedFilter]` so it doesn’t get redefined unnecessarily."}
{"text":"Q: What accessibility labels should be added? A: Add `accessibilityLabel` to the Add button, search input, filter controls, and each `ItemBooking` for better screen reader support."}
{"text":"Q: How to handle deep link navigation to a filter state? A: Parse query params from the deep link, set `selectedFilter` and `textSearch` accordingly in an initial `useEffect`, then call `getList(1)`."}
{"text":"Q: How can you optimize performance for large filter option lists? A: Use virtualization (e.g., FlatList) within the Filter dropdowns, and memoize option arrays with `useMemo`."}
{"text":"Q: How would you implement server-side search debounce? A: In the hook `filterBookings`, debounce calls by keyword or implement caching to throttle server requests."}
{"text":"Q: What considerations exist for offline handling? A: Cache the last fetched `list` and `amenityList` in local storage, display cached data when offline, and queue filter or search updates to retry when back online."}
{"text":"Q: How to unit-test the Booking component? A: Mock `useBooking` hook to provide fake data and spies on `filterBookings`, render the component, simulate filter changes and search input, and assert that `filterBookings` was called with correct args."}
{"text":"Q: How do you extend the component to show booking counts? A: Use `useMemo` to calculate `data.length` and display a `<Text>` like \"Showing {data.length} of {totalPage*PAGE_SIZE}\" above the list."}
{"text":"Q: How would you handle localization of date filters? A: Pass localized date formats to `getDefaultDateRange()` and display current range in the UI via I18n and `formatDate`."}
{"text":"Q: How can you integrate user permissions for filtering? A: Fetch user roles from context, and conditionally include/exclude certain `filters` entries (e.g., hide `paymentStatusIds` if not authorized)."}
{"text":"Q: What refactoring could reduce complexity in `getList`? A: Extract filter param building into a helper like `buildBookingFilterParams(selectedFilter, textSearch, page)` to simplify the component."}
{"text":"Q: How do you ensure filter and search state reset on unmount? A: In a cleanup effect `useEffect(() => { return () => { setTextSearch(''); setSelectedFilter(defaultFilter); } }, [])` to clear state if needed."}
{"text":"Q: How would you show a “No network” banner? A: Use NetInfo subscription to detect connectivity, and render a `<Banner>` above the list when offline."}
{"text":"Q: How can you debounce filter application? A: Wrap `setSelectedFilter` in a debounced function so rapid filter changes don’t call `getList` too frequently."}
{"text":"Q: How to implement a date range picker for `dateRange` instead of defaults? A: Replace `dateRange` filter UI with a `<DateRangePicker>` component, mapping its start and end into `selectedFilter.dateRange`."}
{"text":"Q: How to add inline loading indicators per card? A: Pass `isLoading` prop to `ItemBooking` and show a spinner overlay on each item during updates."}
{"text":"Q: How to handle focus when the amenity modal opens? A: Use React Native’s `autoFocus` prop on the modal’s search input and call `setVisibleSelectAmenity(true)` with a slight delay."}
{"text":"Q: How to add a “Back to top” button when scrolled far down? A: Track scroll position in `AppList` via `onScroll`, and conditionally render a floating button that calls `scrollToOffset({y:0})` on the FlatList ref."}
{"text":"Q: How would you support filtering by creator or user? A: Add a new filter key `createdByIds` with a multi-select dropdown pulling from a users list via `getUsers` hook, then include in `filterParams`."}
{"text":"Q: How can you theme filter and list components? A: Pass theme props (colors, fonts) into `<Filter>` and `<AppList>` or use styled-components’ ThemeProvider for consistent styling."}
{"text":"Q: What is the importance of passing `keyword` to `filterBookings`? A: It enables server-side searching by booking name/ID, ensuring the backend filters results rather than client-side post-fetch filtering."}
{"text":"Q: How can you add a “Clear Search” icon? A: In the `<Filter>` component’s search input, render an `X` icon when `textSearch` is non-empty, with `onPress={() => setTextSearch('')}` to clear."}
{"text":"Q: How would you support bookmarking favorite bookings? A: Add a “star” toggle in `ItemBooking` that updates a favorites list in context or local storage, and add a filter toggle `onlyFavorites`.   "}
{"text":"Q: How do you handle large data volumes? A: Use pagination (`PAGE_SIZE`), server-side filters, and avoid fetching all data at once; optionally implement infinite scroll thresholds."}
{"text":"Q: How would you implement optimistic UI for add/edit? A: Immediately insert the new/updated booking into `data` array via context update before the API responds, then reconcile on success/failure."}
{"text":"Q: How can you instrument performance logging? A: Measure start/end timestamps around `filterBookings` calls and list renders, log via `console.time` or an analytics SDK."}
{"text":"Q: What considerations exist when adding new filter types? A: Ensure the `filters` object provides the correct `type`, `options`, `valKey`, and UI props; update `defaultFilter` and `getList` to include the new key."}
{"text":"Q: How can you centralize filter logic for reuse? A: Create a custom hook `useBookingFilters` that returns `filters`, `defaultFilter`, `selectedFilter`, `setSelectedFilter`, and `buildFilterParams`."}
{"text":"Q: How does the component handle deep linking to a specific booking? A: On navigation params (e.g., `navigate('Booking', { highlightId: xxx })`), check `route.params.highlightId` and scroll to that booking in the list via FlatList’s `scrollToIndex`."}
{"text":"Q: How to add a “Group by amenity” view? A: Transform `data` into grouped sections by `amenityName` and pass to a `<SectionList>` instead of `<FlatList>`."}
{"text":"Q: What best practice does splitting this component illustrate? A: Separation of concerns: data fetching in `useBooking`, list UI in `AppList`, filter controls in `Filter`, and modal in `SelectAmenityModal`, leading to maintainable and testable code."}
{"text":"Q: What is the purpose of the `initialValues` object? A: It defines the default form values for a new booking, including null amenityId, current date for startEndDate, default status/paymentStatus codes, empty arrays/strings for purposeId, numberOfPerson, remark, bookingType set to occupier, and empty files/depositPrice/slots."}
{"text":"Q: Why include both `startEndDate` and `endDate` in initialValues? A: `startEndDate` is used for the date picker in add mode; `endDate` exists to match the Angular shape but is unused for new bookings (the actual end date comes from slots)."}
{"text":"Q: How does `validationSchema` enforce conditional requirements for `unit`, `company`, and `email`? A: It uses Yup’s `.when('bookingType')` to require `unit` when bookingType is occupier, `company` when company, and `email` (with valid format) when outsider."}
{"text":"Q: What additional test is added to `slots` when `isAddNew` is true? A: A Yup `.test('at-least-one-selected')` ensures at least one slot has `isCheck===true`, enforcing slot selection for new bookings."}
{"text":"Q: How is the Yup schema memoized? A: Wrapped in `useMemo` with `[isAddNew]` dependency so the schema recomputes only when add/edit mode changes."}
{"text":"Q: How does `useCompatibleForm` integrate React Hook Form and Yup? A: It calls `useForm` with `defaultValues` and a resolver from `useYupValidationResolver(validationSchema)`, wiring validation and defaults together."}
{"text":"Q: How does `watch('bookingType')[0]` extract the selected booking type? A: `bookingType` is an array; watching it returns e.g. `[1]`, so `[0]` yields the numeric value for conditional rendering and payload."}
{"text":"Q: Why guard `const slots = watch('slots') || [];`? A: Ensures `slots` is always an array, avoiding undefined when the form is resetting or before initialValues is applied."}
{"text":"Q: How is `startDate` chosen differently for add vs edit? A: If `isAddNew`, `startDate = startEndDate`; otherwise it’s taken from `bookingDetail.startDate` loaded from API."}
{"text":"Q: What triggers the effect `useEffect([id])`? A: Whenever the route params id changes, which happens when navigating to edit a different booking, it calls `getBookingDetail(id)` to fetch data."}
{"text":"Q: Why is `resetBookingDetail` commented out? A: Possibly to avoid clearing bookingDetail on unmount before context consumers complete; might be toggled based on broader app reset logic."}
{"text":"Q: How are `referenceFiles` used in edit mode? A: An effect on `[_.size(referenceFiles)]` calls `setValue('files', referenceFiles)` to prefill document picker with existing attachments."}
{"text":"Q: What is the role of `bookingRuleFiles`? A: Files containing policy/rule documents for the amenity; an effect on `[bookingRuleFiles, amenityDetail]` sets them into the form for rules display."}
{"text":"Q: How are simpleCompanies fetched and used? A: On mount, `getSimpleCompanies({page:1})` loads company options; used by `FormLazyDropdown` when bookingType is company."}
{"text":"Q: Why check `_.size(amenityList) === 0` before calling `getAmenities()`? A: To avoid refetching amenity list if it’s already loaded, improving performance."}
{"text":"Q: How does the effect on `[bookingSlots]` work? A: When `bookingSlots` updates from API, if `isAddNew`, it sets the form field `slots` to that new array so the slot picker shows available times."}
{"text":"Q: Why is `getInitialValuesForUpdate()` separated into its own function? A: Encapsulates mapping of bookingDetail into form shape, handling nested objects per bookingType, keeping effects cleaner."}
{"text":"Q: How does `reset(getInitialValuesForUpdate())` work? A: Completely replaces form state with values returned from that function, resetting inputs, dropdowns, and slot arrays for edit mode."}
{"text":"Q: What determines `isDisabledForm`? A: After loading bookingDetail, if statusCode is CANCELED or DECLINED, setIsDisabledForm(true) disables all form inputs via FormDisabledProvider."}
{"text":"Q: How does FormDisabledProvider disable nested form controls? A: It likely provides a form context flag that each `<FormInput>`, `<FormDropdown>`, etc. checks to render in disabled/editable mode."}
{"text":"Q: Why fetch `bookingRuleFiles` only in add mode? A: To show amenity policy before booking; in edit mode the rules are static or not needed since booking is existing."}
{"text":"Q: How is `getBookingTimeSlots` triggered? A: In a useEffect with dependencies `[startDate, endDate, amenityDetail]`, whenever the selected date or amenity changes."}
{"text":"Q: Why format dates as `YYYY/MM/DD`? A: Matches backend API expectations for fromDate/toDate parameters in getAllTimeSlots."}
{"text":"Q: How is `calculateDepositPrice` memoized? A: Wrapped in `useCallback` depending only on `slots`, so the reference changes only when slots array changes."}
{"text":"Q: Why does `calculateDepositPrice` check `!amenityDetail` first? A: Prevents errors if rules aren’t loaded yet; deposit logic runs only when amenity rules exist."}
{"text":"Q: How are `checkedSlots` determined? A: By filtering `slots.filter(item => item.isCheck)`, capturing only selected time intervals."}
{"text":"Q: How is `weekday` used for deposit logic? A: Array mapping numeric day to string, so `weekday[moment(startDateSlot).day()]` yields e.g. 'WEDNESDAY' to match rule.numNextValidDate."}
{"text":"Q: Why format times with `'HH:mm:ss'`? A: amenityTimeRules store times in that format, enabling exact match comparisons."}
{"text":"Q: What happens if multiple rules match? A: `.find` returns the first; business logic likely ensures rules are unique per day/time slot combination."}
{"text":"Q: How does the effect `useEffect([calculateDepositPrice])` trigger? A: When the callback reference changes (i.e. when slots change), it invokes deposit recalculation."}
{"text":"Q: How does `recurringBooking` sanitize `bookingParams`? A: Spreads in values, then deletes startDate/endDate to avoid sending conflicting fields when using bookingTimes array."}
{"text":"Q: How are `bookingTimes` validated? A: If empty, shows an alert NO_RECURRING_SLOT_AVAILABLE and returns without proceeding."}
{"text":"Q: How does `validateRecurringBooking` integrate with statusList? A: Call returns `res.status` code; matchedStatus found via statusList.find to get human-readable name for confirmation modal."}
{"text":"Q: What fields are set in `bookingRequestData`? A: API response spread (`res`), plus amenityName, requestedBy, createdDate, status (name), validSlots (bookingTimes), invalidSlots (from res)."}
{"text":"Q: Why call `setConfirmationVisible(true)`? A: To show the BookingConfirmation modal with the prepared data for user review."}
{"text":"Q: How does `handleConfirm` differ from final confirmation? A: `handleConfirm` simply calls `onSave` again to persist after user confirms in the modal, then closes the modal."}
{"text":"Q: Why use `formMethods.getValues()` in `handleConfirm`? A: To get current form state (including any unchanged fields) when re-invoking save logic after confirmation."}
{"text":"Q: How are `uploadFiles` determined? A: Filtering `files.filter(item => item.path)` picks only new local files to upload; existing server files lack a `path` and are skipped."}
{"text":"Q: Why compute `slotStartTime`/`slotEndTime` only for add mode? A: Edit mode uses existing bookingDetail times; new bookings derive times from slot selection."}
{"text":"Q: How does the payload map contact fields for occupier? A: Reads from `formValues.unit` and contact fields set by FormSuggestionPicker, ensuring userId, name, email, phone are included."}
{"text":"Q: How does `BookingRecurring` component communicate back to parent? A: It calls `onSubmitForm(rec)` with recurrence rules, and `onRemove()` to clear recurrence when user toggles off."}
{"text":"Q: What logic sets the paymentStatus default for new bookings? A: In `[amenityDetail]` effect, if `amenityDetail.isUseDeposited`, it sets `paymentStatus` form field to 'NotYetDeposit'."}
{"text":"Q: How is `bookingWarningMessage` calculated and displayed? A: Not in this file, but similar pattern: useMemo compares now with period.from/to via getTimePeriod, showing warning via BookingWarningText styled in warning color."}
{"text":"Q: Why wrap the entire form in `<LoaderContainer>`? A: To show a loading spinner until amenityDetail loads, preventing incomplete UI render and avoiding form interactions before data is ready."}
{"text":"Q: How does selecting a new amenity work in add mode? A: Tapping AmenityButton opens SelectAmenityModal; on select, `setValue('amenityId')`, calls `getAmenityDetail`, and closes modal, triggering related effects."}
{"text":"Q: How is `displayStatus` list built? A: useMemo filters out canceled/declined status codes when `isAddNew` is true, ensuring user cannot pick invalid statuses for new bookings."}
{"text":"Q: Why use `showValue={false}` on status and payment dropdowns? A: Likely to display localized labels via I18n keys rather than raw code strings, enabling custom rendering inside dropdown."}
{"text":"Q: How is the Save button disabled? A: `disabled={isDisabledForm}` from state; if form disabled, Save is unclickable and grayed out by BaseLayout button props."}
{"text":"Q: How are `common_save` and other labels localized? A: Through `I18n.t('COMMON_SAVE')` and similar keys, ensuring multi-language support."}
{"text":"Q: What is the impact of missing dependency arrays in effects? A: Potential stale props or infinite loops; code correctly lists dependencies for each effect to ensure accurate updates."}
{"text":"Q: How does the component avoid race conditions between slot fetch and amenityDetail change? A: Effects have amenityDetail in dependencies so slot fetch runs only when amenityDetail is loaded/changed, avoiding precondition errors."}
{"text":"Q: How are errors communicated to the user? A: Via `Alert.alert` calls with localized error messages, e.g., `Alert.alert(I18n.t('ERROR'), error.message)`."}
{"text":"Q: What is the purpose of `FloatingConversation`? A: Renders a chat widget in edit mode for ongoing conversation about that booking, passing moduleId and guid for message context."}
{"text":"Q: Why conditionally render `FloatingConversation` only when `!isAddNew`? A: Chat is only relevant for existing bookings with a GUID; new bookings have no chat history yet."}
{"text":"Q: How are policy rules displayed? A: `<BookingPolicyRules>` component inside a Container, given `amenityDetail` and `bookingRuleFiles` to render rules and documents."}
{"text":"Q: How is the overall layout structured? A: BaseLayout wraps header, form scroll area, and bottom Save button; AwareScrollView handles keyboard avoidance; Containers group fields visually."}
{"text":"Q: Why use styled-components for `Container` and `TimeWrapper`? A: Encapsulates styling (padding, margins) in JS, promoting reusable layout primitives consistent with theme."}
{"text":"Q: How does `InfoRow` enhance code reuse? A: Renders icon + text row for time/date display, avoiding duplication of Row + Ionicon + Text across date/time UI."}
{"text":"Q: Why import both `useEffect` and `useMemo`/`useCallback`? A: `useEffect` handles side-effects (data fetch, form resets); `useMemo`/`useCallback` optimize expensive calculations and stable references."}
{"text":"Q: How could you improve performance in this component? A: Memoize expensive subcomponents, split into smaller child components, debounce heavy effects, and avoid unnecessary resets via precise dependencies."}
{"text":"Q: What testing strategies apply here? A: Unit-test mapping functions (`getInitialValuesForUpdate`, `calculateDepositPrice`, `buildConfirmationObj`), integration test form flows with React Testing Library, and E2E for add/edit screens."}
{"text":"Q: How would you refactor to reduce file size? A: Extract large sections (recurrence flow, deposit logic) into custom hooks (e.g., `useDeposit`, `useRecurringLogic`) to separate concerns."}
{"text":"Q: How can you ensure form cleanup on unmount? A: Call `resetBookingDetail()` or `formMethods.reset(initialValues)` in a cleanup effect to clear context and form state when leaving screen."}
{"text":"Q: How would you handle partial success on updateBooking? A: If API returns partial failures, show inline errors via `setError` on specific fields or `Alert.alert` with details, and avoid navigation.goBack."}
{"text":"Q: What considerations exist for offline booking creation? A: Queue payload in local storage, show offline indicator, and sync when network returns; disable slot fetch and show cached slots in offline mode."}
{"text":"Q: How can you internationalize numberOfPerson input? A: Use locale-specific number pad and format via `Intl.NumberFormat` for display while typing, and parse using `parseInt` on submit."}
{"text":"Q: How would you handle form validation messages display? A: Pass `error` props from React Hook Form to each `<FormInput>`/`<FormDropdown>` to show inline validation errors below fields."}
{"text":"Q: How can you dynamically show/hide fields based on business logic? A: Use conditional rendering tied to `bookingType`, `amenityDetail.isUseDeposited`, and `amenityDetail.isAllowRecurring` to keep UI reactive."}
{"text":"Q: What is the significance of `languageId` from useApp? A: Used to pick the correct remark text from `amenityDetail.remarks` array by matching `languageName === languageId`."}
{"text":"Q: How is `amenityRemark` computed? A: In JSX, using `_.size(amenityDetail.remarks)` and `find` to get the remark value for the current language, defaulting to empty string."}
{"text":"Q: Why display `amenityRemark` as a disabled FormInput? A: To show static policy notes or instructions tied to the selected amenity, without allowing user edits."}
{"text":"Q: How is the `company` dropdown implemented differently from `status`? A: Uses `<FormLazyDropdown>` with server-side search (`getSimpleCompanies`) for large company lists, whereas status uses a simple static dropdown."}
{"text":"Q: Why pass `mode='small'` to most form controls? A: To use a compact UI variant suitable for mobile screens, reducing padding/font sizes for dense layouts."}
{"text":"Q: How would you implement a “Help” tooltip for each field? A: Wrap field labels in a `InfoTooltip` component that shows contextual help text on tap or hover."}
{"text":"Q: How does the component handle accessibility for custom components? A: Ensure each form control has `accessibilityLabel`, `accessible`, and role attributes; wrap composite controls in `FormControl` with appropriate props."}
{"text":"Q: How would you add analytics for user interactions? A: In each `onPress`, `onChange`, and `handleSubmit`, call tracking functions logging event names and field values (anonymized) for UX analysis."}
{"text":"Q: What patterns enable easier maintenance of this screen? A: Modularization of logic into hooks, small reusable UI components, centralized validation schema, and consistent naming conventions for form fields."}
{"text":"Q: How can you enforce consistency between form field names and payload keys? A: Define a constants file mapping form names to payload keys and use it in both form setup and payload building, reducing typos."}
{"text":"Q: How might you support dark mode? A: Use theme context via styled-components, reference Colors from theme for backgrounds/text, and ensure all hardcoded colors use theme variables."}
{"text":"Q: How does the component manage memory leaks from async calls? A: Could use `let isMounted = true` in effects and cancel state updates if unmounted, or use AbortController to cancel fetches when unmounting."}
{"text":"Q: How to extract common form field array logic into a custom hook? A: Create `useFormArray(name)` for watching, setting, and validation of array fields like slots, companies, or files, reducing boilerplate."}
{"text":"Q: What are the key scenarios to test manually? A: Add booking happy path, slot selection edge cases (max slots, non-contiguous), deposit calculation, cancel/decline edit mode, file upload, recurring booking full flow."}
{"text":"Q: How does the component handle time zone differences? A: Uses `moment` for parsing/formatting with local defaults; to handle multiple zones, consider using `moment.tz` and passing timeZone context from user settings."}
{"text":"Q: How to integrate feature flags for recurring booking? A: Wrap `<BookingRecurring>` and related logic in `if (featureFlags.recurringBooking)` to enable/disable the feature remotely."}
{"text":"Q: How would you extract currency formatting logic? A: Use `LocaleConfig.formatMoney` inside a custom hook `useCurrency` or context, ensuring consistent formatting and currency symbol placement."}
{"text":"Q: How to prevent stale bookingSlots after amenity change? A: Clear form `slots` (e.g., `setValue('slots', [])`) before fetching new slots in `getBookingTimeSlots` to avoid showing old availability briefly."}
{"text":"Q: How to handle missing bookingPurposes? A: Check `bookingPurposes.length===0` before rendering the dropdown and display a spinner or “No purposes available” message until loaded."}
{"text":"Q: How can you improve user guidance for required fields? A: Add `*` indicators to labels, group required fields together, and show tooltips explaining why certain fields are mandatory."}
{"text":"Q: Why use `navigation.goBack()` instead of `NavigationService`? A: Here `navigation` prop from react-navigation is used; elsewhere `NavigationService` is used for non-hook contexts—both achieve similar navigation actions."}
{"text":"Q: What linter rules would you apply to this file? A: Enforce consistent dependency arrays in hooks, no unused vars (e.g., resetBookingDetail commented), and consistent naming/import order."}
{"text":"Q: How to handle API versioning in payload? A: Include a `version` key in payload or update hook call to `addBookingV2`, allowing backward compatibility as backend evolves."}
{"text":"Q: How does the component ensure idempotency on save? A: Could include a client-generated UUID in payload, preventing duplicate bookings if the user taps Save twice due to lag."}
{"text":"Q: How would you support editing recurring bookings? A: Extend edit mode to load `bookingDetail.recurrence` rules, prefill `<BookingRecurring>` component, and branch on `formValues.recurrence` in onSave."}
{"text":"Q: What approach helps coordinate multiple async calls? A: Use `Promise.all` or sequential `await` inside an async wrapper, handling errors individually or via consolidated catch with context."}
{"text":"Q: How can you centralize I18n keys usage? A: Create a constants file `I18nKeys` exporting keys like `FORM_THIS_FIELD_IS_REQUIRED`, and import them for consistency and refactoring safety."}
{"text":"Q: How to ensure predictable form reset on mode switch? A: In a `useEffect([isAddNew])`, call `reset(initialValues)` when switching from edit to add or vice versa, clearing stale values."}
{"text":"Q: What are potential edge cases in booking flows? A: Booking past dates, selecting slots crossing midnight, handling leap year/feb29, daylight savings transitions, simultaneous edits by multiple users."}
{"text":"Q: How to integrate unit tests for form validation schema? A: Use Yup’s `validateSync` on sample payloads, ensuring required fields, email format, and slot selection tests pass/fail as expected."}
{"text":"Q: How to support automated localization testing? A: Render the component in different locales within tests, snapshot test the UI labels, and verify date/time formats match locale conventions."}
{"text":"Q: How can you profile render performance? A: Use React DevTools Profiler to record renders, identify heavy hooks or re-renders, and optimize via memoization or splitting components."}
{"text":"Q: How to document this component for future developers? A: Add JSDoc comments for key functions (`getInitialValuesForUpdate`, `calculateDepositPrice`, `recurringBooking`), and inline TODOs for known improvements."}
{"text":"Q: What accessibility audit should be performed? A: Use tools like aXe or React Native Accessible to ensure forms have proper labels, focus order, and color contrast for warning text."}
{"text":"Q: How would you internationalize date picker? A: Pass `locale={I18n.locale}` prop to `<FormCalendarPicker>` and ensure it uses `moment.locale(I18n.locale)` under the hood."}
{"text":"Q: How to handle user time zone in deposit logic? A: Include tenant’s time zone in amenityDetail, and use that zone in moment parsing/formatting and rule matching to avoid local discrepancies."}
{"text":"Q: How does the component scale for multiple booking targets? A: Booking targets (occupier, company, outsider) drive conditional fields; adding a new target simply requires adding case in schema and payload logic."}
{"text":"Q: How to externalize field labels for A/B testing? A: Pass label keys as props or define them in an external config so experiments can swap labels without code changes."}
{"text":"Q: How to ensure the modal doesn’t block underlying keyboard shortcuts? A: Use `keyboardShouldPersistTaps='handled'` on ScrollViews and modals to manage focus and tap behavior reliably."}
{"text":"Q: What debugging tools help track form state? A: Use React Hook Form’s `useWatch` in dev mode to log form values on every change, or use the DevTools integration for state inspection."}
{"text":"Q: How to support reactive form loading spinners per section? A: Add local `isLoadingStatus`, `isLoadingPurposes`, `isLoadingSlots` flags from hooks, and render spinners in place of dropdowns/lists when true."}
{"text":"Q: How to handle large attachments in FormDocumentPicker? A: Validate file size in the picker component, show progress indicators for large uploads, and allow cancellation of in-flight uploads."}
{"text":"Q: How would you implement deep error reporting for production? A: Use Sentry or similar to capture exceptions in `recurringBooking`, `onSave`, and other async flows, reporting stack traces and user context."}
{"text":"Q: How to refactor error alerts into a centralized handler? A: Create a `useErrorHandler()` hook that catches and displays errors uniformly, replacing `Alert.alert` calls with `showError(error)`."}
{"text":"Q: How can you integrate a confirmation prompt before discarding changes? A: Use a `useBeforeRemove` listener from react-navigation to show an `Alert.alert` if `formMethods.formState.isDirty` when navigating away."}
{"text":"Q: How to allow users to save drafts without completing booking? A: Introduce a `statusCode: DRAFT`, add a “Save Draft” button calling `addBooking` with draft flag, and surface drafts in the booking list."}
{"text":"Q: How to ensure backward compatibility with older booking APIs? A: Version-check in hook, map new payload shape to legacy API format if required, and maintain both code paths until full migration."}
{"text":"Q: How to handle server-side data shape changes? A: Use TypeScript interfaces or PropTypes to define expected shapes for bookingDetail, amenityDetail, and adjust mapping in `getInitialValuesForUpdate` accordingly."}
{"text":"Q: What metrics should you capture for booking flows? A: Load times for slot fetching, time to first render, validation errors counts, recurring booking success/failure rates, and user abandonment points."}
{"text":"Q: How can you ensure the component is future-proof for new features (e.g., multi-resource booking)? A: Architect with extensible patterns—use maps for targets, abstract slot logic, and externalize business rules to configuration rather than hardcoded arrays."}
{"text":"Q: How do you ensure that the UI remains responsive under slow network conditions? A: Show skeleton loaders for form fields, disable Save until network checks complete, and allow users to interact with cached data optimistically."}
{"text":"Q: What patterns support previewing a booking summary before save? A: Render a read-only `<BookingSummary>` component below the form that updates live from formValues, giving users immediate feedback."}
{"text":"Q: How to implement server-side validation feedback inline? A: After API failure with field errors, call `setError('fieldName', { message: serverMessage })` to display under the relevant input."}
{"text":"Q: How to support multiple locales for currency in depositPrice? A: Store prices in smallest unit (cents), and use `Intl.NumberFormat(I18n.locale, { style:'currency', currency: localeCurrency })` instead of LocaleConfig.formatMoney."}
{"text":"Q: How would you handle legacy browsers or React Native versions without Hooks? A: Provide a class-based equivalent component or use the Hooks-to-HOC polyfill, ensuring backward compatibility gradually phased out."}
{"text":"Q: How to structure this component for micro-frontend architectures? A: Expose `<AddOrEditBooking>` as a standalone module, bundle its dependencies separately, and integrate via dynamic import or WebView in host app."}
{"text":"Q: How to monitor memory usage of this component? A: In development, use memory profiler tools, monitor number of listeners, array sizes (slots, bookingRuleFiles), and clean up any lingering state on unmount."}
{"text":"Q: How to support accessibility contrast testing? A: Use automated tools to check color contrast of BookingWarningText, disabled inputs, and ensure adherence to WCAG guidelines."}
{"text":"Q: What is the significance of styling `<Card>` via styled-components? A: Provides consistent container style (margin, padding, border) with theme integration, simplifying layout adjustments across screens."}
{"text":"Q: How can you centralize slot formatting logic? A: Move `formatSlotTime` and `getTimeRange` into a utility module `slotUtils.js` for reuse between Add and Confirmation components."}
{"text":"Q: How to handle conditional display of paymentStatus dropdown? A: Render it only when `amenityDetail.isUseDeposited` && ((isAddNew && status!==REQUESTED) || (!isAddNew && bookingDetail.paymentStatus)) to match business rules."}
{"text":"Q: How does the component manage multiple contexts (booking, app, user, file)? A: Uses separate hooks (`useBooking`, `useApp`, `useUser`, `useFile`), isolating domain logic and promoting single-responsibility."}
{"text":"Q: How to ensure context state stays in sync across components? A: Use context providers at top-level, keep hook logic idempotent, and consider subscribing to context changes with selectors to minimize re-renders."}
{"text":"Q: How would you implement feature toggle for file uploads? A: Wrap `<FormDocumentPicker>` in `if (featureFlags.fileUploads)` so you can turn off file attachments via remote config."}
{"text":"Q: What improvements could be made to the `InfoRow` component? A: Add `accessibilityRole='text'` and `accessible` props, allow custom icon color via props, and memoize to avoid re-renders with props unchanged."}
{"text":"Q: How to support right-to-left (RTL) layouts? A: Use `I18nManager.isRTL` to flip styled-components (e.g., `margin-right` to `margin-left`) and ensure icon/name order reverses correctly."}
{"text":"Q: How can you add state persistence between sessions? A: Use AsyncStorage or MMKV to save in-progress form data under a key and restore it in `useEffect([])` on mount, prompting the user to resume."}
{"text":"Q: How to handle complex unit suggestion logic? A: Replace FormSuggestionPicker with a virtualized dropdown that pages results via `getSimpleUnits`, and cache results for repeat queries."}
{"text":"Q: How to share deposit logic across multiple components? A: Extract into `useDepositCalculator(slots, amenityTimeRules)` hook returning `{price, formatted}` and use inside Add/Edit and any summary components."}
{"text":"Q: How does the code ensure consistent money formatting? A: Uses `LocaleConfig.formatMoney` central utility; you could switch to `Intl.NumberFormat` for built-in locale support."}
{"text":"Q: How might you centralize date handling? A: Create a `DateUtils` module exporting `formatDate`, `getTimePeriod`, `stringToISO`, and reuse across components to avoid inconsistent formats."}
{"text":"Q: How to handle currency conversion for multi-currency amenities? A: Extend amenityDetail to include currency code, and use `Intl.NumberFormat` with dynamic currency parameter in deposit and total price displays."}
{"text":"Q: How would you support a “preview as PDF” for bookings? A: Build HTML/CSS template of formValues, use a PDF generator library (e.g., react-native-html-to-pdf), and offer a download/share action after Save."}
{"text":"Q: How to ensure developers can easily extend booking fields? A: Use a JSON schema to define form fields, render via a dynamic form builder, and map schema keys to payload automatically."}
{"text":"Q: How to coordinate booking and payment flows? A: After add/edit, navigate to a Payment screen if `amenityDetail.isUseDeposited` and `paymentStatus===NOT_YET_DEPOSIT`, passing bookingId to initiate payment."}
{"text":"Q: How to instrument logs for slot fetch latency? A: In `getBookingTimeSlots`, record timestamps before/after `getAllTimeSlots` and send timing data to analytics or console.trace for debugging."}
{"text":"Q: How to support server-driven UI changes? A: Fetch a form configuration object from API describing which fields to show/validate, and render form controls dynamically based on that config instead of hardcoded JSX."}
{"text":"Q: How to handle multiple bookingRecurrence flows? A: Abstract recurrence logic into `useRecurrence` hook, accepting config and callbacks for validation, confirmation, and final save, enabling reuse in other modules."}
{"text":"Q: What patterns help isolate side effects in hooks? A: Use custom hooks (`useBookingDetail`, `useSlotFetcher`, `useDepositPrice`, `useRecurringBooking`) to keep the component focused on UI composition."}
{"text":"Q: How can you reduce render-blocking work on initial load? A: Lazy-load heavy components (`BookingRecurring`, `BookingPolicyRules`) via React.lazy and Suspense, showing skeletons until loaded."}
{"text":"Q: How to ensure consistent error state reset? A: On successful `addBooking` or `updateBooking`, call `clearErrors()` from React Hook Form to remove any lingering validation messages before navigation."}
{"text":"Q: How to support bi-directional data flow? A: Use controlled components via `value` and `onChange`, but allow programmatic updates via `setValue` in effects, keeping form state authoritative."}
{"text":"Q: How to implement collaborative editing safeguards? A: Subscribe to real-time updates on bookingDetail via WebSocket, show a warning if another user edits the booking concurrently, and optionally lock the form."}
{"text":"Q: How would you integrate a guided tutorial overlay? A: Use a library like react-native-copilot to highlight fields (FormCalendarPicker, SlotView, Save button) with step-by-step instructions for first-time users."}
{"text":"Q: How to audit user changes for compliance? A: Track previous and new values in `onSave`, send a diff to an audit log endpoint, and display change history in the FloatingConversation chat."}
{"text":"Q: What considerations exist for mobile vs tablet layouts? A: Adjust Container width, use multi-column layout for large screens, and increase touch target sizes for better ergonomics on tablets."}
{"text":"Q: How to support voice input for form fields? A: Integrate React Native Voice or built-in speech-to-text APIs for text inputs like `remark` and `purpose`, enhancing accessibility."}