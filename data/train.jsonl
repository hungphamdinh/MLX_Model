{"text": "API Handler Wrappers"}
{"text":"Q: Why wrap RequestApi calls in individual async functions in the hook? A: To encapsulate each API endpoint behind a named method, allowing handler wrappers to uniformly manage side effects and dispatch actions."}
{"text":"Q: How does withErrorHandling enhance getPriorityList? A: It dispatches GET_PRIORITY_LIST.REQUEST before the call, then GET_PRIORITY_LIST.SUCCESS or GET_PRIORITY_LIST.FAILURE after, centralizing error dispatch without loading states."}
{"text":"Q: What additional behavior does withLoadingAndErrorHandling add for addTask? A: It also dispatches loading state actions (e.g., SET_LOADING) around the API call so the UI can show spinners while the request is in progress."}
{"text":"Q: Why import useHandlerAction alongside useStateValue? A: useHandlerAction provides the handler wrappers (withErrorHandling, withLoadingAndErrorHandling) that bind API methods to Redux action lifecycles."}
{"text":"Q: How does generateAction facilitate consistent action type creation? A: It takes a base string (e.g., 'taskManagement/GET_TASK_LIST') and returns .REQUEST, .SUCCESS, and .FAILURE constants automatically."}
{"text":"Q: Why include RequestApi.getTMTeamList in getTeamsByTenant? A: To call the shared team-list endpoint with specific params (target:'TaskManagement', isActive:true) while letting the wrapper manage dispatch."}
{"text":"Q: How does getMentionUsers leverage both transformMentionUsers and getCacheKey? A: The async method returns a structured object so the handler can dispatch GET_MENTION_USER.SUCCESS with both data and cache key for the reducer."}
{"text":"Q: What does getTaskList(params) wrap? A: It wraps RequestApi.getTaskList(params) to fetch a paginated list of tasks and returns the response."}
{"text":"Q: What does getPriorityList() wrap? A: It wraps RequestApi.getPriorityList() to retrieve the priority options for tasks and returns the response."}
{"text":"Q: What does getTeamsByTenant(params) wrap? A: It wraps RequestApi.getTMTeamList({ ...params, target:'TaskManagement', isActive:true }) to fetch active teams for a given tenant."}
{"text":"Q: What does getCurrentTeamList() wrap? A: It wraps RequestApi.getCurrentTeamList() to fetch teams assigned to the current user context."}
{"text":"Q: What does getAssigneeList(params) wrap? A: It wraps RequestApi.getUsersInTeamByTenant(params) to fetch users for a specific team and returns the response."}
{"text":"Q: What does getUsersInTeamByTenants(params) wrap? A: It wraps RequestApi.getUsersInTeamByTenants(params) to fetch users across multiple teams in one call."}
{"text":"Q: What does getTaskDetail(taskId) wrap? A: It wraps RequestApi.getTaskDetail(taskId) to fetch detailed information for a single task by its ID."}
{"text":"Q: What does addTask(payload) wrap? A: It wraps RequestApi.addTask or RequestApi.addTaskWithSchedule based on payload.schedule, then handles file uploads and navigation."}
{"text":"Q: What does updateTask(payload) wrap? A: It wraps RequestApi.updateTask or RequestApi.updateTaskWithSchedule based on payload.isSeries, then handles file uploads and navigation."}
{"text":"Q: What does getStatusList() wrap? A: It wraps RequestApi.getStatusList() to retrieve the status options for tasks and returns the response."}
{"text":"Q: What does addComment(params) wrap? A: It wraps RequestApi.addComment(params) to submit a new comment for a task and returns the response."}
{"text":"Q: What does getCommentByTask(params) wrap? A: It wraps RequestApi.getCommentByTask(params) to fetch comments for a given task and returns the response."}
{"text":"Q: What does getEmployeesByTenant(params) wrap? A: It wraps RequestApi.getListEmployeesByTenant(params) to fetch a paginated list of employees for a tenant."}
{"text":"Q: What does getTeamsForTaskDetail(params) wrap? A: It wraps RequestApi.getTMTeamList({ ...params, target:'TaskManagement', isActive:true }) to fetch teams related to an existing task."}
{"text":"Q: What does getTenantsTaskDetail(params) wrap? A: It wraps RequestApi.getTenantList({ ...params, editionIdSpecified:false, skipCount:0 }) to fetch the list of tenants."}
{"text":"Q: What does getTaskSetting() wrap? A: It wraps RequestApi.getTaskSetting() to fetch configuration settings for tasks, like default reminder intervals."}
{"text":"Q: What does getFileByReferenceId(params) wrap? A: It wraps RequestApi.getTaskFileReference(params) to fetch files attached to a task or schedule document by referenceId."}
{"text":"Q: What does setUpApprovals(params) wrap? A: It wraps RequestApi.setUpAprrovals(params) to submit pending changes for approval workflow initiation."}
{"text":"Q: What does approveChange(params) wrap? A: It wraps RequestApi.approveChange(params) to record an approval decision for a pending change."}
{"text":"Q: What does rejectChange(params) wrap? A: It wraps RequestApi.rejectChange(params) to record a rejection decision, including an optional rejectionReason."}
{"text":"Q: What does getTaskPropertyConfig() wrap? A: It wraps RequestApi.getTaskPropertyConfig() to fetch dynamic form field configurations for tasks."}
{"text": "Action & Saga Integration"}
{"text":"Q: What lifecycle actions occur when getTaskDetail is called? A: withLoadingAndErrorHandling dispatches GET_TASK_DETAIL.REQUEST, then on success GET_TASK_DETAIL.SUCCESS, or GET_TASK_DETAIL.FAILURE on error."}
{"text":"Q: How does resetTaskDetailRequest integrate with sagas? A: It dispatches RESET_TASK_DETAIL, which a saga or reducer listens for to clear taskDetail state without invoking an API."}
{"text":"Q: Why are REQUEST, SUCCESS, and FAILURE actions important? A: They demarcate each phase of an async operation, enabling sagas to trigger side effects on REQUEST and letting reducers handle state changes appropriately."}
{"text":"Q: How would a saga watch for UPDATE_TASK actions? A: A saga uses takeEvery(UPDATE_TASK.REQUEST, workerUpdateTask) to perform the API call and then dispatch UPDATE_TASK.SUCCESS or FAILURE based on the outcome."}
{"text":"Q: What action constant pattern is used for addComment? A: ADD_COMMENT.REQUEST is dispatched at call start, then ADD_COMMENT.SUCCESS or ADD_COMMENT.FAILURE is dispatched when the API resolves."}
{"text":"Q: How does withLoadingAndErrorHandling know which actions to dispatch? A: It receives the base constant (e.g., ADD_TASK) and automatically appends .REQUEST, .SUCCESS, and .FAILURE when wrapping the provided method."}
{"text":"Q: Which saga watches GET_TASK_LIST.REQUEST and what does it do? A: A watcher saga uses takeEvery(GET_TASK_LIST.REQUEST, handleGetTaskList) to call the API and dispatch GET_TASK_LIST.SUCCESS or FAILURE based on the response."}
{"text":"Q: Which saga watches GET_PRIORITY_LIST.REQUEST and what does it do? A: A watcher saga uses takeEvery(GET_PRIORITY_LIST.REQUEST, handleGetPriorityList) to fetch priorities and dispatch GET_PRIORITY_LIST.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_TEAMS_BY_TENANT.REQUEST and what does it do? A: It uses takeEvery(GET_TEAMS_BY_TENANT.REQUEST, handleGetTeamsByTenant) to call getTMTeamList and dispatch success or failure actions."}
{"text":"Q: Which saga watches GET_CURRENT_TEAMS.REQUEST and what does it do? A: It uses takeEvery(GET_CURRENT_TEAMS.REQUEST, handleGetCurrentTeamList) to fetch the user’s teams and dispatch GET_CURRENT_TEAMS.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_ASSIGNEE_LIST.REQUEST and what does it do? A: It uses takeEvery(GET_ASSIGNEE_LIST.REQUEST, handleGetAssigneeList) to fetch team users and dispatch GET_ASSIGNEE_LIST.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_USERS_IN_TEAMS_BY_TENANTS.REQUEST and what does it do? A: It uses takeEvery(GET_USERS_IN_TEAMS_BY_TENANTS.REQUEST, handleGetUsersInTeamByTenants) to batch-fetch users across teams."}
{"text":"Q: Which saga watches GET_TASK_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_TASK_DETAIL.REQUEST, handleGetTaskDetail) to fetch task details and dispatch GET_TASK_DETAIL.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches ADD_TASK.REQUEST and what does it do? A: It uses takeEvery(ADD_TASK.REQUEST, handleAddTask) to call addTask API, upload files, navigate back, and dispatch ADD_TASK.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches UPDATE_TASK.REQUEST and what does it do? A: It uses takeEvery(UPDATE_TASK.REQUEST, handleUpdateTask) to update tasks or series, upload files, navigate back, and dispatch UPDATE_TASK.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_STATUS_LIST.REQUEST and what does it do? A: It uses takeEvery(GET_STATUS_LIST.REQUEST, handleGetStatusList) to fetch statuses and dispatch GET_STATUS_LIST.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_MENTION_USER.REQUEST and what does it do? A: It uses takeEvery(GET_MENTION_USER.REQUEST, handleGetMentionUsers) to transform and cache mention data."}
{"text":"Q: Which saga watches ADD_COMMENT.REQUEST and what does it do? A: It uses takeEvery(ADD_COMMENT.REQUEST, handleAddComment) to submit a comment and dispatch ADD_COMMENT.SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_COMMENT_BY_TASK.REQUEST and what does it do? A: It uses takeEvery(GET_COMMENT_BY_TASK.REQUEST, handleGetCommentByTask) to fetch task comments."}
{"text":"Q: Which saga watches GET_EMPLOYEES_BY_TENANT.REQUEST and what does it do? A: It uses takeEvery(GET_EMPLOYEES_BY_TENANT.REQUEST, handleGetEmployeesByTenant) to paginate tenant employees."}
{"text":"Q: Which saga watches GET_TEAMS_FOR_TASK_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_TEAMS_FOR_TASK_DETAIL.REQUEST, handleGetTeamsForTaskDetail) to load teams for an existing task."}
{"text":"Q: Which saga watches GET_TENANTS_TASK_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_TENANTS_TASK_DETAIL.REQUEST, handleGetTenantsTaskDetail) to load tenant list for control office users."}
{"text":"Q: Which saga watches GET_TASK_SETTING.REQUEST and what does it do? A: It uses takeEvery(GET_TASK_SETTING.REQUEST, handleGetTaskSetting) to fetch default task config (reminders) for the form."}
{"text":"Q: Which saga watches GET_FILE_BY_REFERENCE_ID.REQUEST and what does it do? A: It uses takeEvery(GET_FILE_BY_REFERENCE_ID.REQUEST, handleGetFileByReferenceId) to clear and load attachments."}
{"text":"Q: Which saga watches SET_UP_APPROVAL.REQUEST and what does it do? A: It uses takeEvery(SET_UP_APPROVAL.REQUEST, handleSetUpApprovals) to send pending changes for approvals."}
{"text":"Q: Which saga watches APPROVE_CHANGE.REQUEST and what does it do? A: It uses takeEvery(APPROVE_CHANGE.REQUEST, handleApproveChange) to approve pending changes."}
{"text":"Q: Which saga watches REJECT_CHANGE.REQUEST and what does it do? A: It uses takeEvery(REJECT_CHANGE.REQUEST, handleRejectChange) to reject pending changes with optional reason."}
{"text":"Q: Which saga watches GET_TASK_PROPERTY_CONFIG.REQUEST and what does it do? A: It uses takeEvery(GET_TASK_PROPERTY_CONFIG.REQUEST, handleGetTaskPropertyConfig) to load dynamic form field configs."}
{"text":"Q: What does GET_TASK_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates tasks were fetched successfully; the reducer calls `state.list.setData(payload)` and deep-clones the ListModel to update `state.list`."}
{"text":"Q: What does GET_PRIORITY_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates priorities were fetched successfully; the reducer sets `state.priorityList = payload`."}
{"text":"Q: What does GET_TEAMS_BY_TENANT.SUCCESS indicate, and how does the reducer handle it? A: It indicates team data was fetched successfully; the reducer applies `transformWithCOTags(payload)` and sets `state.teamList`."}
{"text":"Q: What does GET_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates task details were fetched; the reducer sets `state.taskDetail = payload`."}
{"text":"Q: What does ADD_TASK.SUCCESS indicate, and how should the app respond? A: It indicates a new task was created successfully; UI components typically refresh the task list and navigate back (handled by sagas)."}
{"text":"Q: What does UPDATE_TASK.SUCCESS indicate, and how should the app respond? A: It indicates a task update succeeded; UI components refresh the display or navigate back as appropriate."}
{"text":"Q: What does GET_STATUS_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates statuses were fetched; the reducer sets `state.statusList = payload`."}
{"text":"Q: What does GET_MENTION_USER.SUCCESS indicate, and how does the reducer handle it? A: It indicates mentions were fetched; the reducer stores `state.mentionUsersDic[key] = mentionUsers` based on the provided key."}
{"text":"Q: What does ADD_COMMENT.SUCCESS indicate, and how does the reducer handle it? A: It indicates a comment was added; subsequent sagas or components may re-fetch comments, but the reducer does not directly update state here."}
{"text":"Q: What does GET_COMMENT_BY_TASK.SUCCESS indicate, and how does the reducer handle it? A: It indicates comments were fetched; the reducer sets `state.comments = payload`."}
{"text":"Q: What does GET_ASSIGNEE_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates team assignees were fetched successfully; the reducer applies `transformWithCOTags(payload)` and sets `state.assigneeList`."}
{"text":"Q: What does GET_CURRENT_TEAMS.SUCCESS indicate, and how does the reducer handle it? A: It indicates the current user’s teams were fetched; the reducer sets `state.teamList = payload`."}
{"text":"Q: What does GET_STATUS_LIST.SUCCESS indicate, and how does the reducer handle it? A: It indicates status options were fetched; the reducer sets `state.statusList = payload`."}
{"text":"Q: What does GET_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates detailed information for a task was fetched; the reducer sets `state.taskDetail = payload`."}
{"text":"Q: What does GET_TEAMS_FOR_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates teams for an existing task were fetched; the reducer applies `transformWithCOTags(payload)` and sets `state.teamsTaskDetail`."}
{"text":"Q: What does GET_USERS_IN_TEAMS_BY_TENANTS.SUCCESS indicate, and how does the reducer handle it? A: It indicates users across selected teams were fetched; the reducer applies `transformWithCOTags(payload)` and sets `state.usersInTeams`."}
{"text":"Q: What does GET_EMPLOYEES_BY_TENANT.SUCCESS indicate, and how does the reducer handle it? A: It indicates employees for a tenant were fetched; the reducer transforms items with `transformWithCOTags`, calls `employeesByTenant.setData(payload)`, and deep clones it."}
{"text":"Q: What does GET_TENANTS_TASK_DETAIL.SUCCESS indicate, and how does the reducer handle it? A: It indicates the tenant list was fetched; the reducer calls `tenantsDetail.setData(payload)`, sets `totalPage = 1`, and returns a deep clone."}
{"text": "Reducer & State Management"}
{"text":"Q: How does the reducer handle GET_TASK_LIST.REQUEST? A: It calls state.list.setPage(page) on the ListModel and then returns a deep clone so Redux detects the change."}
{"text":"Q: What does GET_TASK_LIST.SUCCESS do in the reducer? A: It sets the fetched data on the ListModel via list.setData(payload) and deep-clones the state for immutability."}
{"text":"Q: How are control-office tags applied to team lists? A: On GET_TEAMS_BY_TENANT.SUCCESS and GET_TEAMS_FOR_TASK_DETAIL.SUCCESS, the reducer calls transformWithCOTags before storing in state.teamList or state.teamsTaskDetail."}
{"text":"Q: Why deep-clone ListModel instances after mutation? A: Because ListModel methods mutate internal state, deep cloning ensures a new reference so Redux change detection works correctly."}
{"text":"Q: How does the reducer respond to GET_TENANTS_TASK_DETAIL.REQUEST vs SUCCESS? A: REQUEST resets pagination (page=1, totalPage=1), and SUCCESS populates tenantsDetail.setData(payload) before deep-cloning."}
{"text":"Q: What happens on GET_FILE_BY_REFERENCE_ID.REQUEST? A: The reducer clears state.files to an empty array, removing stale attachments before the new payload arrives."}
{"text":"Q: How are dynamic field configs loaded into state? A: On GET_TASK_PROPERTY_CONFIG.SUCCESS, the reducer prefixes each item’s key with TM_FFC_ and stores them in state.taskPropertyConfigs."}
{"text":"Q: What does the reducer’s default case do? A: It returns the unchanged state for any unrecognized action, preventing unintended state mutations."}
{"text":"Q: When GET_TASK_LIST.REQUEST is dispatched, which saga and reducer cases handle it? A: The saga watcher `takeEvery(GET_TASK_LIST.REQUEST, handleGetTaskList)` calls the API; on success it dispatches GET_TASK_LIST.SUCCESS, which the reducer handles by calling `state.list.setData(payload)` and deep-cloning the ListModel."}
{"text":"Q: How do GET_PRIORITY_LIST.REQUEST, its saga, and reducer integrate? A: `takeEvery(GET_PRIORITY_LIST.REQUEST, handleGetPriorityList)` invokes the priority API, then dispatches GET_PRIORITY_LIST.SUCCESS; the reducer sets `state.priorityList = payload`."}
{"text":"Q: Describe the flow for GET_TEAMS_BY_TENANT.REQUEST through saga and reducer. A: The saga watcher `takeEvery(GET_TEAMS_BY_TENANT.REQUEST, handleGetTeamsByTenant)` calls `getTMTeamList`; on GET_TEAMS_BY_TENANT.SUCCESS the reducer applies `transformWithCOTags` and stores the result in `state.teamList`."}
{"text":"Q: What happens from GET_TASK_DETAIL.REQUEST to the reducer update? A: The saga `takeEvery(GET_TASK_DETAIL.REQUEST, handleGetTaskDetail)` calls the detail API, then dispatches GET_TASK_DETAIL.SUCCESS; the reducer sets `state.taskDetail = payload`."}
{"text":"Q: How is ADD_TASK.REQUEST handled by saga and reducer? A: Under the saga `takeEvery(ADD_TASK.REQUEST, handleAddTask)`, the API call and file uploads occur, navigation is triggered, and then ADD_TASK.SUCCESS is dispatched; the reducer doesn’t store new state here, but components reload the list afterward."}
{"text":"Q: Explain the lifecycle for UPDATE_TASK.REQUEST. A: The saga `takeEvery(UPDATE_TASK.REQUEST, handleUpdateTask)` calls the update API (single or series), uploads files, navigates back, then dispatches UPDATE_TASK.SUCCESS; the reducer may clear pending changes or trigger side-effects via listeners."}
{"text":"Q: Outline how RESET_TASK_DETAIL is processed in saga and reducer. A: RESET_TASK_DETAIL is a plain action (no saga watcher); the reducer listens for RESET_TASK_DETAIL and sets `state.taskDetail = null` to clear the detail state."}
{"text":"Q: What is the flow for GET_COMMENT_BY_TASK.REQUEST? A: The saga `takeEvery(GET_COMMENT_BY_TASK.REQUEST, handleGetCommentByTask)` fetches comments, dispatches GET_COMMENT_BY_TASK.SUCCESS; the reducer then assigns `state.comments = payload`."}
{"text":"Q: How are SET_UP_APPROVAL.REQUEST and APPROVE_CHANGE.REQUEST handled? A: `takeEvery(SET_UP_APPROVAL.REQUEST, handleSetUpApprovals)` sends pending changes; upon SET_UP_APPROVAL.SUCCESS components may re-fetch taskDetail. Similarly, `takeEvery(APPROVE_CHANGE.REQUEST, handleApproveChange)` triggers backend approval and then APPROVE_CHANGE.SUCCESS updates approval state in the reducer."}
{"text":"Q: Describe the GET_TASK_PROPERTY_CONFIG.REQUEST to reducer update. A: The saga `takeEvery(GET_TASK_PROPERTY_CONFIG.REQUEST, handleGetTaskPropertyConfig)` fetches dynamic field configs, dispatches GET_TASK_PROPERTY_CONFIG.SUCCESS; the reducer prefixes each item’s key with `TM_FFC_` and stores them in `state.taskPropertyConfigs`."}
{"text": "Business Logic & Side Effects"}
{"text":"Q: Why call NavigationServices.goBack() after addTask and updateTask? A: To navigate back automatically once the task creation or update (and any file uploads) complete successfully."}
{"text":"Q: How are file uploads coordinated in addTask? A: After the primary API call, the code checks payload.files, derives the correct documentId, and calls RequestApi.uploadTaskManagementFiles."}
{"text":"Q: How does updateTask handle series vs single task updates? A: It checks payload.isSeries or schedule flags to call updateTaskWithSchedule for series or updateTask for single items."}
{"text":"Q: What is setUpApprovals used for? A: It sends pending change details to the approval API, initiating an approval workflow rather than directly updating the task."}
{"text":"Q: How do approveChange and rejectChange differ? A: Both call their respective API, but rejectChange may include a rejectionReason payload, while approveChange sends only approvalMatrixId."}
{"text":"Q: Why return both mentionUsers and key from getMentionUsers? A: So the reducer can cache the transformed user list under the provided key, avoiding duplicate API calls."}
{"text":"Q: How does transformMentionUsers affect caching logic? A: It produces normalized user objects, and getCacheKey ensures each param combination maps to a unique cache entry in state. "}
{"text":"Q: When is resetTaskDetail invoked in business flow? A: Components call resetTaskDetail (dispatch RESET_TASK_DETAIL) in cleanup effects to clear form state when unmounting the detail screen."}
{"text":"Q: How does resetTaskDetailRequest improve UX during navigation? A: By clearing the detail state immediately on unmount or reset, it prevents stale task data from appearing when revisiting the screen."}
{"text":"Q: What side effects does withLoadingAndErrorHandling wrapper trigger beyond dispatching actions? A: It toggles a global loading indicator, allowing the UI to show spinners during long-running operations like file uploads."}
{"text":"Q: How are errors during file uploads handled after addTask/updateTask? A: If uploadTaskManagementFiles fails, withLoadingAndErrorHandling dispatches FAILURE and error state, enabling the app to display an error message."}
{"text":"Q: Why call NavigationServices.goBack() after awaiting file uploads? A: To ensure all side effects complete before navigating away, preventing race conditions and guaranteeing data consistency."}
{"text":"Q: Why include isActive:true when fetching teams? A: To only retrieve active teams, improving performance and UX by excluding inactive entries from dropdowns."}
{"text":"Q: How does getTenantsTaskDetail support control-office workflows? A: By fetching all tenants via RequestApi.getTenantList with editionIdSpecified:false and skipCount:0, it provides the full tenant list for control-office context switching."}
{"text":"Q: Why use _.first(response) when extracting documentId? A: Some schedule APIs return an array; _.first ensures the correct documentId is selected for subsequent file uploads."}
{"text":"Q: What ensures navigation only occurs after file uploads? A: NavigationServices.goBack() is called after awaiting uploadTaskManagementFiles, guaranteeing all uploads finish before leaving the screen."}
{"text":"Feedback"}
{"text":"API Handler Wrappers"}
{"text":"Q: What does getListFB(params) wrap and dispatch? A: It dispatches GET_LIST_FB_REQUEST with params, calls RequestApi.getListFB(params), then dispatches GET_LIST_FB_SUCCESS with the response or GET_LIST_FB_FAILURE on error."}
{"text":"Q: What does getListQRFeedback(params) wrap and dispatch? A: It dispatches GET_LIST_FB_QR_REQUEST, calls RequestApi.getListQRFeedback(params), then dispatches GET_LIST_FB_QR_SUCCESS or GET_LIST_FB_QR_FAILURE on error."}
{"text":"Q: How does addFB integrate with handler wrappers? A: addFB is wrapped by withLoadingAndErrorHandling(ADD_FB) to dispatch ADD_FB.REQUEST, call RequestApi.createFeedback, upload files, then dispatch ADD_FB.SUCCESS or ADD_FB.FAILURE."}
{"text":"Q: How does editFB integrate with handler wrappers? A: editFB is wrapped by withLoadingAndErrorHandling(EDIT_FB) to dispatch EDIT_FB.REQUEST, call RequestApi.updateFeedback, upload files, then dispatch EDIT_FB.SUCCESS or EDIT_FB.FAILURE."}
{"text":"Q: What does editQrFB(params) wrap and dispatch? A: It dispatches EDIT_QR_FB_REQUEST, calls RequestApi.updateQRFeedback(params), then dispatches EDIT_QR_FB_SUCCESS(true) or EDIT_QR_FB_FAILURE(err) on error."}
{"text":"Q: What does detailFB(id) wrap and dispatch? A: It dispatches DETAIL_FB_REQUEST(id), calls RequestApi.getDetailFB(id), then dispatches DETAIL_FB_SUCCESS(response) or DETAIL_FB_FAILURE(err)."}
{"text":"Q: What does detailQRFeedback(id) wrap and dispatch? A: It dispatches DETAIL_FB_QR_REQUEST(id), calls RequestApi.getDetailQRFeedback(id), then dispatches DETAIL_FB_QR_SUCCESS(response) or DETAIL_FB_QR_FAILURE(err)."}
{"text":"Q: What does getSources(params) wrap and dispatch? A: It dispatches GET_SOURCES_REQUEST(params), calls RequestApi.getFeedbackSources(params), then dispatches GET_SOURCES_SUCCESS(response) or GET_SOURCES_FAILURE(err)."}
{"text":"Q: What does getAreas() wrap and dispatch? A: It dispatches GET_AREAS_REQUEST(), calls RequestApi.getAreas(), then dispatches GET_AREAS_SUCCESS(response) or GET_AREAS_FAILURE(err)."}
{"text":"Q: What does getCategories() wrap and dispatch? A: It dispatches GET_CATEGORIES_REQUEST(), calls RequestApi.getFeedbackCategories(), then dispatches GET_CATEGORIES_SUCCESS(response) or GET_CATEGORIES_FAILURE(err)."}
{"text":"Q: What does getTypes() wrap and dispatch? A: It dispatches GET_TYPES_REQUEST(), calls RequestApi.getFeedbackTypes(), then dispatches GET_TYPES_SUCCESS(response) or GET_TYPES_FAILURE(err)."}
{"text":"Q: What does getSubCategories(params) wrap and dispatch? A: It dispatches GET_SUB_CATEGORIES_REQUEST(params), calls RequestApi.getSubCategories(areaId, categoryId), then dispatches GET_SUB_CATEGORIES_SUCCESS(response) or GET_SUB_CATEGORIES_FAILURE(err)."}
{"text":"Q: What does addQuickJR(params) wrap and dispatch? A: It dispatches ADD_QUICK_JR_REQUEST(params), calls RequestApi.requestQuickCreateWorkOrder(params), then dispatches ADD_QUICK_JR_SUCCESS(response) or ADD_QUICK_JR_FAILURE(err)."}
{"text":"Q: What does getQuickJRSetting(params) wrap and dispatch? A: It dispatches GET_QUICK_JR_SETTING_REQUEST(params), calls RequestApi.requestWorkOrderSetting(params), then dispatches GET_QUICK_JR_SETTING_SUCCESS(response) or GET_QUICK_JR_SETTING_FAILURE(err)."}
{"text":"Q: What does getFeedbackStatus() wrap and dispatch? A: It dispatches GET_FEEDBACK_STATUS_REQUEST(), calls RequestApi.getFeedbackStatus(), then dispatches GET_FEEDBACK_STATUS_SUCCESS(response) or GET_FEEDBACK_STATUS_FAILURE(err)."}
{"text":"Q: What does getLocations(payload) wrap and dispatch? A: It dispatches GET_LOCATIONS_REQUEST(payload), calls RequestApi.getListLocation(payload), then dispatches GET_LOCATIONS_SUCCESS(response) or GET_LOCATIONS_FAILURE(err)."}
{"text":"Q: What do getFeedbackDivision() and getQrFeedbackSetting() wrap? A: Both are wrapped by withErrorHandling, calling RequestApi.getFeedbackDivision() and RequestApi.getQrFeedbackSetting(), then dispatching GET_FEEDBACK_DIVISION.SUCCESS or GET_QR_FEEDBACK_SETTING.SUCCESS accordingly."}
{"text":"Q: What does getQuickJRSetting(params) wrap and dispatch? A: It dispatches GET_QUICK_JR_SETTING_REQUEST(params), calls RequestApi.requestWorkOrderSetting(params), then dispatches GET_QUICK_JR_SETTING_SUCCESS(response) or GET_QUICK_JR_SETTING_FAILURE(err)."}
{"text":"Q: What does getFeedbackStatus() wrap and dispatch? A: It dispatches GET_FEEDBACK_STATUS_REQUEST(), calls RequestApi.getFeedbackStatus(), then dispatches GET_FEEDBACK_STATUS_SUCCESS(response) or GET_FEEDBACK_STATUS_FAILURE(err)."}
{"text":"Q: What does getLocations(payload) wrap and dispatch? A: It dispatches GET_LOCATIONS_REQUEST(payload), calls RequestApi.getListLocation(payload), then dispatches GET_LOCATIONS_SUCCESS(response) or GET_LOCATIONS_FAILURE(err)."}
{"text":"Q: What does getFeedbackDivision() wrap? A: It is wrapped by withErrorHandling(GET_FEEDBACK_DIVISION, getFeedbackDivision) to dispatch GET_FEEDBACK_DIVISION.REQUEST, call RequestApi.getFeedbackDivision(), then dispatch GET_FEEDBACK_DIVISION.SUCCESS(response.items) or GET_FEEDBACK_DIVISION.FAILURE(err)."}
{"text":"Q: What does getQrFeedbackSetting() wrap? A: It is wrapped by withErrorHandling(GET_QR_FEEDBACK_SETTING, getQrFeedbackSetting) to dispatch GET_QR_FEEDBACK_SETTING.REQUEST, call RequestApi.getQrFeedbackSetting(), then dispatch GET_QR_FEEDBACK_SETTING.SUCCESS(response) or GET_QR_FEEDBACK_SETTING.FAILURE(err)."}
{"text": "Action & Saga Integration"}
{"text":"Q: Which saga watcher handles GET_LIST_FB_REQUEST? A: A watcher saga uses takeEvery(GET_LIST_FB_REQUEST, handleGetListFB) to call the getListFB worker, then dispatch GET_LIST_FB_SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles ADD_FB.REQUEST? A: takeEvery(ADD_FB.REQUEST, handleAddFB) triggers the addFB flow, uploads files, and dispatches ADD_FB.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles DETAIL_FB_QR_REQUEST? A: takeEvery(DETAIL_FB_QR_REQUEST, handleDetailQRFeedback) invokes the detailQRFeedback worker and dispatches DETAIL_FB_QR_SUCCESS or FAILURE."}
{"text":"Q: What lifecycle actions are dispatched around editFB? A: EDIT_FB.REQUEST at start, then EDIT_FB.SUCCESS on successful update/upload, or EDIT_FB.FAILURE on errors."}
{"text":"Q: How do REQUEST, SUCCESS, and FAILURE actions support the Feedback form? A: They represent each phase of an async call, allowing sagas and reducers to manage loading state, data, and errors for lists, details, and edits."}
{"text":"Q: Why define string constants for GET_LIST_FB_QR_REQUEST/SUCCESS/FAILURE? A: To have explicit action types for saga watchers and reducer cases without generateAction wrappers."}
{"text":"Q: Which saga watches GET_QUICK_JR_SETTING_REQUEST? A: takeEvery(GET_QUICK_JR_SETTING_REQUEST, handleGetQuickJRSetting) calls the API and dispatches GET_QUICK_JR_SETTING_SUCCESS or FAILURE."}
{"text":"Q: Which saga watches GET_FEEDBACK_STATUS_REQUEST? A: takeEvery(GET_FEEDBACK_STATUS_REQUEST, handleGetFeedbackStatus) to fetch statuses and dispatch corresponding success/failure."}
{"text":"Q: Which saga watches GET_LOCATIONS_REQUEST? A: takeEvery(GET_LOCATIONS_REQUEST, handleGetLocations) to fetch paginated location data and dispatch GET_LOCATIONS_SUCCESS or FAILURE."}
{"text":"Q: How does withLoadingAndErrorHandling differ from manual dispatch in Feedback? A: withLoadingAndErrorHandling auto-dispatches REQUEST/SUCCESS/FAILURE and toggles loading, whereas getListFB manually dispatches actions inside a try/catch."}
{"text":"Q: Which saga watcher handles GET_SUB_CATEGORIES_REQUEST? A: It uses takeEvery(GET_SUB_CATEGORIES_REQUEST, handleGetSubCategories) to call the API and dispatch GET_SUB_CATEGORIES_SUCCESS or GET_SUB_CATEGORIES_FAILURE."}
{"text":"Q: Which saga watcher handles ADD_QUICK_JR_REQUEST? A: It uses takeEvery(ADD_QUICK_JR_REQUEST, handleAddQuickJR) to call requestQuickCreateWorkOrder and dispatch ADD_QUICK_JR_SUCCESS or ADD_QUICK_JR_FAILURE."}
{"text":"Q: Which saga watcher handles GET_FEEDBACK_DIVISION.REQUEST? A: It uses takeEvery(GET_FEEDBACK_DIVISION.REQUEST, handleGetFeedbackDivision) to fetch the division list and dispatch GET_FEEDBACK_DIVISION.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_QR_FEEDBACK_SETTING.REQUEST? A: It uses takeEvery(GET_QR_FEEDBACK_SETTING.REQUEST, handleGetQrFeedbackSetting) to load QR feedback config and dispatch GET_QR_FEEDBACK_SETTING.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles EDIT_FB.REQUEST? A: It uses takeEvery(EDIT_FB.REQUEST, handleEditFB) to wrap updateFeedback, handle file uploads, and dispatch EDIT_FB.SUCCESS or EDIT_FB.FAILURE."}
{"text":"Q: Which saga watcher handles GET_AREAS_REQUEST and what is its flow? A: It uses takeEvery(GET_AREAS_REQUEST, handleGetAreas) to call RequestApi.getAreas and then dispatch GET_AREAS_SUCCESS or GET_AREAS_FAILURE."}
{"text":"Q: Which saga watcher handles GET_CATEGORIES_REQUEST? A: It uses takeEvery(GET_CATEGORIES_REQUEST, handleGetCategories) to fetch feedback categories and dispatch GET_CATEGORIES_SUCCESS or GET_CATEGORIES_FAILURE."}
{"text":"Q: Which saga watcher handles GET_TYPES_REQUEST and what does it do? A: It uses takeEvery(GET_TYPES_REQUEST, handleGetTypes) to invoke RequestApi.getFeedbackTypes and dispatch GET_TYPES_SUCCESS or GET_TYPES_FAILURE."}
{"text": "Reducer & State Management"}
{"text":"Q: How does the Feedback reducer handle GET_LIST_FB_REQUEST? A: It calls state.list.setPage(page) on the ListModel and returns a deep clone to trigger updates."}
{"text":"Q: What happens on GET_LIST_FB_SUCCESS in the reducer? A: It maps each item to enrich fields (id, fullName, phoneNumber, emailAddress), calls list.setData(data), and deep-clones `list`."}
{"text":"Q: How does the reducer handle DETAIL_FB_REQUEST? A: It sets `fbDetail = undefined` and `isLoading = true` to clear previous detail and show a loading indicator."}
{"text":"Q: What does DETAIL_FB_SUCCESS do in state? A: It assigns `fbDetail = payload` and `isLoading = false`, reflecting the loaded feedback detail."}
{"text":"Q: How are sources stored on GET_SOURCES_SUCCESS? A: The reducer sets `state.sources = payload`, updating the dropdown options for feedback sources."}
{"text":"Q: How does GET_AREAS_REQUEST vs GET_AREAS_SUCCESS differ? A: REQUEST clears `state.areas = []`; SUCCESS populates `state.areas = payload`."}
{"text":"Q: How does GET_TYPES_REQUEST vs GET_TYPES_SUCCESS behave? A: REQUEST leaves `state.types` unchanged; SUCCESS sets `state.types = payload`."}
{"text":"Q: How does GET_LOCATIONS_SUCCESS update the ListModel? A: It calls `locations.setData(payload)` then deep-clones `locations` so pagination and items are updated immutably."}
{"text":"Q: What does GET_FEEDBACK_DIVISION.SUCCESS do? A: It sets `state.divisionList = payload`, storing divisions for quick-create work orders."}
{"text":"Q: How is EDIT_QR_FB_REQUEST handled in the reducer? A: It sets `isLoading = true` to indicate the edit operation is in progress."}
{"text":"Q: How is EDIT_QR_FB_SUCCESS handled? A: It sets `isLoading = false` once the QR feedback edit completes successfully."}
{"text":"Q: How does the reducer handle failures like GET_LIST_FB_FAILURE? A: It stores `error = payload`, allowing the UI to display an error message."}
{"text":"Q: What does RESET state on user switch (SWITCH_TO_USER_ACCOUNT_SUCCESS) do? A: It returns INITIAL_STATE, clearing all feedback data when switching accounts."}
{"text":"Q: Why deep-clone ListModel after mutation? A: Because ListModel methods mutate internal state; deep cloning ensures Redux notices the change by new references."}
{"text":"Q: How does DETAIL_FB_QR_FAILURE affect loading state? A: It sets `isLoading = false` without altering `qrFBDetail`, preserving previous data if any."}
{"text":"Q: What is the reducer’s default case behavior? A: It returns the unchanged state for any unknown action type, preventing unintended mutations."}
{"text":"Q: How does the reducer handle GET_SUB_CATEGORIES_REQUEST? A: It typically resets or clears `state.subCategories` before loading new sub-categories."}
{"text":"Q: What does GET_SUB_CATEGORIES_SUCCESS do in the reducer? A: It assigns `state.subCategories = payload`, updating the list based on selected area and category."}
{"text":"Q: How does GET_SUB_CATEGORIES_FAILURE affect state? A: It leaves `state.subCategories` unchanged and may set an error flag, preventing stale data replacement."}
{"text":"Q: What does ADD_QUICK_JR_SUCCESS do in the reducer? A: It may store the response in a `quickJR` slice or trigger a list refresh, indicating successful creation."}
{"text":"Q: How is GET_FEEDBACK_DIVISION.SUCCESS handled? A: The reducer sets `state.divisionList = payload`, making divisions available for quick work order creation."}
{"text":"Q: How is GET_QR_FEEDBACK_SETTING.SUCCESS handled? A: It sets `state.qrFeedbackSetting = payload`, storing QR feedback modal configuration."}
{"text":"Q: What does GET_FEEDBACK_STATUS_REQUEST do to `state.statusList`? A: It typically clears or marks it loading, preparing to fetch status options."}
{"text":"Q: How does GET_FEEDBACK_STATUS_SUCCESS update the store? A: It sets `state.statusList = payload`, populating feedback status dropdown values."}
{"text":"Q: How are feedback errors handled on GET_FEEDBACK_STATUS_FAILURE? A: The reducer retains the previous `statusList` and may store an error flag without clearing existing data."}
{"text":"Q: How does SWITCH_TO_USER_ACCOUNT_SUCCESS reset feedback state? A: It returns `INITIAL_STATE`, clearing all lists, details, loading flags, and configurations for the new user context."}
{"text": "Business Logic & Side Effects"}
{"text":"Q: Why upload files only after receiving a GUID in addFB? A: Because the backend assigns a document ID on creation, which is needed to associate uploaded files correctly."}
{"text":"Q: How does editFB decide which files to upload? A: It passes `isNewCommentBox: false` to uploadFileFeedback to indicate an edit context vs initial creation."}
{"text":"Q: Why return `true` on editQrFBSuccess? A: So calling components know the edit succeeded and can proceed (e.g., close modals or refresh data)."}
{"text":"Q: Why do manual dispatches in getListFB use try/catch instead of wrappers? A: To customize error handling or to perform additional logic before/after dispatch, independent of global loading state."}
{"text":"Q: How does withLoadingAndErrorHandling improve UX for addFB/editFB? A: It automatically toggles a global spinner during long operations, giving users immediate feedback."}
{"text":"Q: What side effect does SWITCH_TO_USER_ACCOUNT_SUCCESS in the Feedback reducer trigger? A: It resets all feedback state so new user sessions start with a clean slate."}
{"text":"Q: Why clear `fbDetail` on DETAIL_FB_REQUEST? A: To prevent stale detail data from flashing while the new detail is being fetched."}
{"text":"Q: How does the reducer ensure pagination resets on GET_LIST_FB_QR_REQUEST? A: It calls `state.listQRFeedback.setPage(page)` before fetching, aligning the ListModel with the requested page."}
{"text":"Q: Why not wrap getFeedbackDivision in withLoadingAndErrorHandling? A: Likely because division data is small/static and doesn’t require a loading spinner, only error handling."}
{"text":"Q: How does the hook decide whether to use manual dispatch vs handler wrappers? A: It uses manual dispatch when custom try/catch logic is needed; uses wrappers for standard CRUD operations to reduce boilerplate."}
{"text":"Booking"}
{"text":"API Handler Wrappers"}
{"text":"Q: What does getBookingStatus wrap and dispatch? A: It wraps RequestApi.getBookingStatus() to retrieve booking statuses and, when used with withErrorHandling(GET_BOOKING_STATUS), dispatches GET_BOOKING_STATUS.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does filterBookings wrap and dispatch? A: It wraps RequestApi.filterBookings(params, isSorting) to fetch filtered reservations and, with withErrorHandling(FILTER_BOOKINGS), dispatches FILTER_BOOKINGS.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does getAllTimeSlots wrap and dispatch? A: It wraps RequestApi.getAllTimeSlots(params) to load available timeslots and, with withLoadingAndErrorHandling(GET_ALL_TIMESLOTS), dispatches GET_ALL_TIMESLOTS.REQUEST then SUCCESS or FAILURE and manages loading state."}
{"text":"Q: What does getBookingDetail wrap and dispatch? A: It wraps RequestApi.getBookingDetail(reservationId) to fetch a single booking’s details and, with withLoadingAndErrorHandling(GET_BOOKING_DETAIL), dispatches GET_BOOKING_DETAIL.REQUEST then SUCCESS or FAILURE and manages loading state."}
{"text":"Q: What does getPaymentStatus wrap and dispatch? A: It wraps RequestApi.getPaymentStatus() to retrieve payment status options and, with withErrorHandling(GET_PAYMENT_STATUS), dispatches GET_PAYMENT_STATUS.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does addBooking wrap and dispatch? A: It wraps RequestApi.addBooking(payload), handles file uploads via RequestApi.uploadBookingFiles when files exist, and, with withLoadingAndErrorHandling(ADD_BOOKING), dispatches ADD_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does updateBooking wrap and dispatch? A: It wraps RequestApi.updateBooking(payload), handles file uploads when files exist, and, with withLoadingAndErrorHandling(UPDATE_BOOKING), dispatches UPDATE_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does validateRecurringBooking wrap and dispatch? A: It wraps RequestApi.validateRecurringBooking(payload) and, with withLoadingAndErrorHandling(VALIDATE_RECURRING_BOOKING), dispatches VALIDATE_RECURRING_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does recurringBooking wrap and dispatch? A: It wraps RequestApi.recurringBooking(payload) and, with withLoadingAndErrorHandling(RECURRING_BOOKING), dispatches RECURRING_BOOKING.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does getAmenityDetail wrap and dispatch? A: It wraps RequestApi.getAmenityDetail(amenityId) and, with withLoadingAndErrorHandling(GET_AMENITY_DETAIL), dispatches GET_AMENITY_DETAIL.REQUEST then SUCCESS or FAILURE and loading state."}
{"text":"Q: What does getAmenities wrap and dispatch? A: It wraps RequestApi.getAmenities(params) to fetch amenity lists and, with withErrorHandling(GET_AMENITIES), dispatches GET_AMENITIES.REQUEST then SUCCESS or FAILURE."}
{"text":"Q: What does getBookingPurpose wrap and dispatch? A: It wraps RequestApi.getBookingPurpose() to retrieve booking purposes and, with withErrorHandling(GET_ALL_BOOKING_PURPOSE), dispatches GET_ALL_BOOKING_PURPOSE.REQUEST then SUCCESS or FAILURE."}
{"text": "Action & Saga Integration"}
{"text":"Q: Which saga watcher handles GET_BOOKING_STATUS.REQUEST and what does it do? A: A saga uses takeEvery(GET_BOOKING_STATUS.REQUEST, handleGetBookingStatus) to call getBookingStatus and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles FILTER_BOOKINGS.REQUEST and what does it do? A: It uses takeEvery(FILTER_BOOKINGS.REQUEST, handleFilterBookings) to call filterBookings and dispatch FILTER_BOOKINGS.SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_ALL_TIMESLOTS.REQUEST and what does it do? A: It uses takeEvery(GET_ALL_TIMESLOTS.REQUEST, handleGetAllTimeSlots) to call getAllTimeSlots, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_BOOKING_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_BOOKING_DETAIL.REQUEST, handleGetBookingDetail) to call getBookingDetail, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_PAYMENT_STATUS.REQUEST and what does it do? A: It uses takeEvery(GET_PAYMENT_STATUS.REQUEST, handleGetPaymentStatus) to call getPaymentStatus and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles ADD_BOOKING.REQUEST and what does it do? A: It uses takeEvery(ADD_BOOKING.REQUEST, handleAddBooking) to call addBooking, upload files, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles UPDATE_BOOKING.REQUEST and what does it do? A: It uses takeEvery(UPDATE_BOOKING.REQUEST, handleUpdateBooking) to call updateBooking, upload files, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles VALIDATE_RECURRING_BOOKING.REQUEST and what does it do? A: It uses takeEvery(VALIDATE_RECURRING_BOOKING.REQUEST, handleValidateRecurringBooking) to call validateRecurringBooking and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles RECURRING_BOOKING.REQUEST and what does it do? A: It uses takeEvery(RECURRING_BOOKING.REQUEST, handleRecurringBooking) to call recurringBooking and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_AMENITY_DETAIL.REQUEST and what does it do? A: It uses takeEvery(GET_AMENITY_DETAIL.REQUEST, handleGetAmenityDetail) to call getAmenityDetail, manage loading, and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_AMENITIES.REQUEST and what does it do? A: It uses takeEvery(GET_AMENITIES.REQUEST, handleGetAmenities) to call getAmenities and dispatch SUCCESS or FAILURE."}
{"text":"Q: Which saga watcher handles GET_ALL_BOOKING_PURPOSE.REQUEST and what does it do? A: It uses takeEvery(GET_ALL_BOOKING_PURPOSE.REQUEST, handleGetBookingPurpose) to call getBookingPurpose and dispatch SUCCESS or FAILURE."}
{"text": "Reducer & State Management"}
{"text":"Q: What does GET_BOOKING_STATUS.SUCCESS do in the reducer? A: It sets state.statusList = payload, populating booking status options."}
{"text":"Q: How does FILTER_BOOKINGS.REQUEST update the ListModel? A: It calls state.list.setPage(action.payload.page) and deep-clones list to track pagination."}
{"text":"Q: What does FILTER_BOOKINGS.SUCCESS do in the reducer? A: It calls state.list.setData(payload) and deep-clones list to store filtered bookings."}
{"text":"Q: What does GET_ALL_TIMESLOTS.REQUEST do in the reducer? A: It clears state.bookingSlots = [] before new timeslot data arrives."}
{"text":"Q: What does GET_ALL_TIMESLOTS.SUCCESS do in the reducer? A: It sets state.bookingSlots = payload, storing available slots."}
{"text":"Q: What does GET_BOOKING_DETAIL.SUCCESS do in the reducer? A: It sets state.bookingDetail = payload, storing the fetched reservation details."}
{"text":"Q: What does GET_PAYMENT_STATUS.SUCCESS do in the reducer? A: It sets state.paymentStatusList = payload, populating payment status options."}
{"text":"Q: What does RESET_BOOKING_DETAIL do in the reducer? A: It sets state.bookingDetail = null, clearing any displayed reservation detail."}
{"text":"Q: What does GET_AMENITY_DETAIL.REQUEST do in the reducer? A: It sets state.amenityDetail = null to clear previous amenity data before loading."}
{"text":"Q: What does GET_AMENITY_DETAIL.SUCCESS do in the reducer? A: It sets state.amenityDetail = payload, storing the fetched amenity detail."}
{"text":"Q: What does GET_AMENITIES.SUCCESS do in the reducer? A: It filters payload for active items into state.amenityList and tags all items (active/inactive) into state.amenitiesFilter."}
{"text":"Q: What does GET_ALL_BOOKING_PURPOSE.SUCCESS do in the reducer? A: It sets state.bookingPurposes = payload, populating reservation-purpose options."}
{"text":"Q: What is the reducer’s default-case behavior? A: It returns the unchanged state for any unhandled action type, preserving existing data."}
{"text": "Business Logic & Side Effects"}
{"text":"Q: Why upload files after addBooking and updateBooking? A: Because the backend returns a GUID on create/update which is needed to associate uploaded files, so uploads occur only if payload.files exists."}
{"text":"Q: Why clear bookingSlots on GET_ALL_TIMESLOTS.REQUEST? A: To remove stale slot data before fetching fresh availability."}
{"text":"Q: Why reset amenityDetail on GET_AMENITY_DETAIL.REQUEST? A: To prevent previous amenity data from displaying while the new detail is loading."}
{"text":"Q: What transformation does GET_AMENITIES.SUCCESS perform for amenitiesFilter? A: It adds a `tagName: 'INACTIVE'` to inactive items, enabling UI to mark them accordingly."}
{"text":"Q: Why use withLoadingAndErrorHandling for long-running calls? A: To automatically toggle a loading spinner in the UI during operations like file uploads or recurring-booking validation."}
{"text":"Q: How does validateRecurringBooking improve UX before scheduling? A: It lets the backend verify date/rule validity and returns errors before committing a series of bookings."}
{"text":"Q: Why separate validateRecurringBooking and recurringBooking calls? A: To allow pre-flight validation of recurrence rules before actually creating multiple reservations."}
{"text":"Q: Why use withErrorHandling for simple lookups like getBookingStatus? A: Because they only need error dispatching without a global loading spinner, reducing unnecessary UI blocking."}
{"text":"Q: How does resetBookingDetailRequest improve navigation flows? A: Components dispatch it on unmount to clear detail state, preventing stale data when revisiting the booking screen."}
{"text":"Q: Why wrap filterBookings in withErrorHandling rather than manual dispatch? A: To reduce boilerplate by automatically dispatching REQUEST/SUCCESS/FAILURE while still reporting errors to the user."}