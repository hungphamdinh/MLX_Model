{"text":"Q: Why does the Reminder component initialize newReminderBefore and newReminderAfter to defaultCost? A: To provide a sensible starting value for the number inputs so users see a default before entering custom values."}
{"text":"Q: How does the sanitizeInput function in ConfigRecurrenceModal ensure numeric inputs remain valid? A: It strips trailing dots or commas from the text, preventing invalid characters in numeric fields."}
{"text":"Q: What is the purpose of the term(str, char) helper in ConfigRecurrenceModal? A: It replaces the last character of a string with another, used to sanitize text inputs by removing unwanted punctuation."}
{"text":"Q: Why does attemptSave in useApprovalHandling check config.some(f => f.isAllowApprove)? A: To determine if any changed field requires approval before submitting, showing the modal only when necessary."}
{"text":"Q: How does handlerMap.ids handle missing labels for IDs? A: It filters out undefined results after mapping, so only valid labels are joined in the output string."}
{"text":"Q: What does FormDisabledProvider do when isReadOnly=true? A: It disables all nested form fields by passing down a disabled flag, preventing any user edits."}
{"text":"Q: How does the useEffect in Reminder notify its parent of changes? A: It subscribes via watch and calls onChange(value) on every form update, so the parent receives the latest reminder state."}
{"text":"Q: Why use React.Children.map with clone in FormFieldConfigurable? A: To recursively traverse and inject new props into every nested child element based on config rules."}
{"text":"Q: What role does FieldPrefixProvider’s excludeKeys prop play? A: It lists fieldKeys that should not receive the prefix, allowing selective prefixing control."}
{"text":"Q: How does onChangeTenantId react to isPublic changes? A: It re-fetches team or assignee lists for the current tenant whenever the public/site toggle flips, keeping dropdowns in sync."}

{"text":"// ===== TaskManagement ====="}
{"text":"// ===== API Handler Wrappers ====="}
{"text":"Q: Why is generateAction used for GET_TASK_LIST? A: To produce consistent REQUEST, SUCCESS, and FAILURE action types automatically without manual string concatenation."}
{"text":"// ===== Action & Saga Integration ====="}
{"text":"Q: What saga effect handles GET_PRIORITY_LIST.REQUEST? A: takeEvery(GET_PRIORITY_LIST.REQUEST, handleGetPriorityList) triggers the priority fetch and dispatches corresponding SUCCESS or FAILURE actions."}
{"text":"// ===== Reducer & State Management ====="}
{"text":"Q: How does GET_TEAMS_BY_TENANT.SUCCESS impact state? A: It calls transformWithCOTags on the payload and assigns the result to state.teamList for UI consumption."}
{"text":"// ===== Business Logic & Side Effects ====="}
{"text":"Q: What side effect does addTask trigger after the API call? A: It uploads associated files and then navigates back via NavigationServices.goBack()."}
{"text":"// ===== Feedback ====="}
{"text":"// ===== API Handler Wrappers ====="}
{"text":"Q: How is getSources implemented in useFeedback? A: It dispatches GET_SOURCES_REQUEST, calls RequestApi.getFeedbackSources, then dispatches GET_SOURCES_SUCCESS or GET_SOURCES_FAILURE."}
{"text":"// ===== Action & Saga Integration ====="}
{"text":"Q: Which watcher handles GET_TYPES_REQUEST? A: takeEvery(GET_TYPES_REQUEST, handleGetTypes) listens for GET_TYPES_REQUEST to fetch types and dispatch GET_TYPES_SUCCESS or FAILURE."}
{"text":"// ===== Reducer & State Management ====="}
{"text":"Q: What does DETAIL_FB_QR_SUCCESS do in the reducer? A: It sets state.qrFBDetail = payload and isLoading = false, marking the QR feedback detail as loaded."}
{"text":"// ===== Business Logic & Side Effects ====="}
{"text":"Q: Why does editQrFB return true on success? A: To signal the calling component that the QR feedback edit operation completed successfully."}
{"text":"// ===== Booking ====="}
{"text":"// ===== API Handler Wrappers ====="}
{"text":"Q: What wrapper is used for getAmenities? A: withErrorHandling(GET_AMENITIES, getAmenities) ensures GET_AMENITIES.REQUEST, SUCCESS, and FAILURE actions are dispatched around the API call."}
{"text":"// ===== Action & Saga Integration ====="}
{"text":"Q: Which saga watches VALIDATE_RECURRING_BOOKING.REQUEST? A: takeEvery(VALIDATE_RECURRING_BOOKING.REQUEST, handleValidateRecurringBooking) triggers pre-validation of a recurring booking."}
{"text":"// ===== Reducer & State Management ====="}
{"text":"Q: How does FILTER_BOOKINGS.SUCCESS update state? A: It invokes state.list.setData(payload) and deep-clones the list to apply the new filtered booking items immutably."}
{"text":"// ===== Business Logic & Side Effects ====="}
{"text":"Q: Why upload booking files only after addBooking response? A: Because the response provides a GUID needed to correctly associate the uploaded files with the new booking."}
{"text":"Q: Which hooks provide external data and logic to TaskManagement, and what do they each supply? A: `useTaskManagement` supplies task lists and API methods; `useUser` supplies `tenant` and `isControlOffice`; `useTenant` supplies `tenantList` and `getTenantList`."}
{"text":"Q: What local state does TaskManagement manage with `useState`, and why? A: `selectedFilter` stores the current filter; `filterTenantId` tracks which tenant’s teams to fetch; `keyword` holds the live search term."}
{"text":"Q: What three `useEffect` blocks in TaskManagement handle data fetching and when do they run? A: (1) On `teamList` change – fetch users; (2) On mount (`[]`) – fetch statuses, priorities, teams, tenants and subscribe to `ReloadTM`; (3) On `[selectedFilter, keyword]` – re-run `getList` when filters or search change."}
{"text":"Q: How is `filterData` defined to drive the `Filter` component? A: As an object mapping filter keys to config objects containing `title`, `type`, `options`, async `getList`, `onChange`, and `resetPropsOnChange` fields."}
{"text":"Q: What parameters does `getList(page, filter)` construct for `getTaskList`? A: It includes `page`, `keyword`, `pageSize`, `statusIds`, `priorityId`, ISO dates (`fromDate`,`toDate`), `isOverdue`, `isPublic`, `tenantId`, `teamIds`, and `userIds`."}
{"text":"Q: How is each task item rendered and wired to navigation? A: `renderItem` returns `<ItemTask>` with `onPress` calling `NavigationService.navigate('editTask',{id,isSeries})`."}
{"text":"Q: What native event does TaskManagement listen for and why? A: It listens for `'ReloadTM'` via `DeviceEventEmitter` to trigger `getList()` whenever tasks are updated externally."}
{"text":"Q: How are dates normalized before sending to the API? A: By calling `convertDate.stringToISOString(fromDate)` (and similarly for `toDate`), ensuring ISO format."}
{"text":"Q: Which hooks provide data and methods to TaskManagementComment? A: `useTaskManagement` gives `comments`, `mentionUsersDic`, and actions `getCommentByTask`, `getMentionUsers`, `addComment`; `useUser` provides `user` and `tenant`; `useCompatibleForm` sets up form methods."}
{"text":"Q: How is React Hook Form integrated into TaskManagementComment? A: Wrapped in `<FormProvider>`, it uses `watch()` to track `message`, `handleSubmit(onSendMessage)` to submit, and `setValue('message','')` to reset after sending."}
{"text":"Q: How does AddOrEditBooking determine whether it’s adding a new booking or editing an existing one? A: It reads `useRoute().name`, setting `isAddNew = (name==='addBooking')` and `isEdit = (name==='editBooking')`, which drives data loading, form defaults, and conditional rendering."}
{"text":"Q: What form controls and warnings are only rendered in “add new” mode? A: When `isAddNew` is true it shows `<FormCalendarPicker>` for date selection, a `BookingWarningText` if outside booking periods, and `<FormSlotView>` to choose time slots—none of which appear in edit mode."}
{"text":"Q: How does the component populate form values when editing? A: In the effect for `[bookingDetail]`, it calls `reset(getInitialValuesForUpdate())`, where `getInitialValuesForUpdate()` maps fields from `bookingDetail`—including nested `status`, `paymentStatus`, `depositPrice`, `unit`/`company`/`email` based on `bookingType`—into the form’s default values."}
{"text":"Q: What differences exist in the payload built by `onSave` for add vs edit? A: For adds, it computes `slotStartTime` and `slotEndTime` from selected slots and includes them; for edits, it uses the original `bookingDetail.startDate`/`endDate`. Both include `amenityId`, `statusCode`, `bookingType`, and conditional `paymentStatus`, file, and contact/company fields before calling `addBooking` or `updateBooking`."}
{"text":"Q: How is validation schema adjusted for add vs edit modes? A: The Yup schema conditionally adds a `slots` test only if `isAddNew` is true, requiring at least one slot selected for new bookings; edit mode skips slot validation entirely."}
{"text":"Q: Which side effects run only when editing an existing booking? A: The effect on `[id]` invokes `getBookingDetail(id)` and returns `resetBookingDetail()` on cleanup; another effect watches `bookingDetail` to fetch files, amenity details and toggle `isDisabledForm` based on status codes."}
{"text":"Q: How does the form become disabled for canceled or declined bookings? A: In the `useEffect([bookingDetail])`, after resetting the form it checks `bookingDetail.status.statusCode`; if it equals `CANCELED` or `DECLINED`, it sets `isDisabledForm=true`, which disables all inputs via `<FormDisabledProvider>`."}
{"text":"Q: What is the purpose of `bookingWarningMessage` and when is it computed? A: It warns the user if the current time is outside the allowed booking period; it's computed in a useMemo based on `bookingPeriods` and `amenityDetail` using `getTimePeriod` and `getTime`."}
{"text":"Q: How does `getTimePeriod(period.from, period.fromTime)` work? A: It combines a date string and a time string into a JavaScript `Date` object representing the full timestamp for period boundaries."}
{"text":"Q: Why does the code guard `if (!bookingPeriods || !amenityDetail) return null;` in the bookingWarningMessage useMemo? A: To avoid errors when data isn't loaded, returning null until both periods and amenity details are available."}
{"text":"Q: What does the empty state look like when there are no slots? A: `SlotView` checks `_.size(slots) > 0`; if false, it renders `<EmptySlotMessage>` with text key `BK_NEW_SLOT_EMPTY`."}
{"text":"Q: How are unavailable slots rendered? A: If `item.isAvailable` is false, `SlotView` shows an `<UnavailableSlot>` styled with a grey background and no touch handler, displaying time text only."}
{"text":"Q: How does the component disable form inputs when editing a canceled or declined booking? A: After fetching `bookingDetail`, it checks if `statusCode` is CANCELED or DECLINED and sets `isDisabledForm=true`, which `<FormDisabledProvider>` uses to disable all fields."}
{"text":"Q: How are default form values provided for a new booking? A: Via `initialValues`, including defaults for status (REQUESTED), payment (NOT_YET_DEPOSIT), `bookingType` ([occupier]), empty slots, files, etc."}
{"text":"Q: How does `getInitialValuesForUpdate()` shape the form for editing? A: It maps fields from `bookingDetail` into the same shape as the form’s `defaultValues`, including nested `unit`/`company`/`email` objects based on `bookingType`."}
{"text":"Q: How does the effect on `[bookingSlots]` work? A: When `bookingSlots` updates from API, if `isAddNew`, it sets the form field `slots` to that new array so the slot picker shows available times."}
{"text":"Q: How is the `status` field represented in the payload? A: It takes `formValues.status.statusCode` and assigns it to the `status` key in `payload`."}
{"text":"Q: How are API errors handled during add/update operations? A: Errors in `recurringBooking` are caught and show `Alert.alert('ERROR', error.message)`; similar try/catch could wrap `addBooking`/`updateBooking` to alert the user."}
{"text":"Q: What happens after a successful add or update? A: It emits `DeviceEventEmitter.emit('UpdateListBooking')` to refresh other screens, then calls `navigation.goBack()` to return."}
{"text":"Q: How does the component avoid race conditions between slot fetch and amenity change? A: Effects include `amenityDetail` in their dependency arrays, so `getBookingTimeSlots` runs only when `amenityDetail` is loaded or updated, preventing invalid API calls."}
{"text":"File: AddOrEditBooking.js, Q: What does `useBooking()` provide to the AddOrEditBooking component? A: It exposes booking state (`bookingDetail`, `statusList`, `paymentStatusList`, `bookingPurposes`, `amenityDetail`, `bookingSlots`, `amenityList`) and actions (`getBookingDetail`, `addBooking`, `updateBooking`, `getAmenityDetail`, `validateRecurringBooking`, `getBookingStatus`, `getPaymentStatus`, `getBookingPurpose`, `getAmenities`, `getAllTimeSlots`) for managing booking CRUD, lookups, slot fetching, and recurring validation."}
{"text":"File: AddOrEditBooking.js, Q: How is `getBookingDetail` used in edit mode? A: In a `useEffect([id])` hook, when `!isAddNew` and `id` is defined, `getBookingDetail(id)` fetches the existing booking’s details to populate the form."}
{"text":"File: AddOrEditBooking.js, Q: When should `addBooking` be called? A: In the `onSave` handler, if `isAddNew` is true and no `recurrence` is defined, after constructing the payload with selected slots and form values, `addBooking(payload)` persists the new booking."}
{"text":"File: AddOrEditBooking.js, Q: What role does `getAmenityDetail` play? A: Called when an amenity is selected or when editing an existing booking, it fetches detailed `amenityDetail` (rules, remarks) which drives slot fetching, deposit logic, and policy display."}
{"text":"File: AddOrEditBooking.js, Q: Why call `getBookingStatus`, `getPaymentStatus`, and `getBookingPurpose` on mount? A: To load lookup lists for status codes, payment statuses, and booking purposes into dropdowns, ensuring the form has the correct options before user interaction."}
{"text":"File: AddOrEditBooking.js, Q: What does `getAllTimeSlots` do and when is it called? A: It fetches available time slots for a given amenity and date range; invoked in `getBookingTimeSlots()` inside a `useEffect([startDate,endDate,amenityDetail])` to refresh slots whenever the date or amenity changes."}
{"text":"File: AddOrEditBooking.js, Q: How are `bookingRuleFiles` fetched and used? A: When `isAddNew` and `amenityDetail` changes, `getByReferenceIdAndModuleNames(amenityDetail.guid,'','bookingRuleFiles')` loads policy docs, which are then displayed via `<BookingPolicyRules>`."}
{"text":"File: AddOrEditBooking.js, Q: How do `bookingSlots` from context and the form field `slots` stay in sync? A: A `useEffect([bookingSlots])` calls `formMethods.setValue('slots', bookingSlots)` when `bookingSlots` updates, ensuring the slot picker displays the latest availability."}
{"text":"File: AddOrEditBooking.js, Q: How do all these hooks orchestrate the add-mode data-fetch sequence? A: On mount load lookups; on amenity select fetch detail → fetch rule files → fetch slots → populate form; on slot or date changes refetch slots → recalc deposit."}
{"text":"File: AddOrEditBooking.js, Q: How do all these hooks orchestrate the edit-mode data-fetch sequence? A: On mount load lookups; effect on `id` fetches bookingDetail → effect on bookingDetail fetches amenityDetail & files → reset form → effect fetch rule files & slots → disable form if canceled."}
{"text":"File: AddOrEditBooking.js, Q: What error handling should wrap these hook calls? A: Each async action (getBookingDetail, getAmenityDetail, getAllTimeSlots, validateRecurringBooking, addBooking, updateBooking) should use try/catch to `Alert.alert(I18n.t('ERROR'), error.message)` and optionally retry or disable UI."}
{"text":"File: AddOrEditBooking.js, Q: How might you unit-test the component’s interactions with these hooks? A: Mock the `useBooking`, `useApp`, `useUser`, and `useFile` hooks to return fake data/functions, then assert that effects call the correct methods and form values update accordingly."}
{"text":"File: AddOrEditBooking.js, Q: How could you refactor hook-driven logic into custom hooks for clarity? A: Extract booking-detail logic into `useBookingDetail(id,isAddNew)`, amenity logic into `useAmenityData(amenityId)`, and slot/deposit logic into `useSlotAndDeposit(slots,amenityRules)` hooks to declutter the component."}
{"text":"File: AddOrEditBooking.js, Q: How is the `validationSchema` memoized and why? A: It’s wrapped in `useMemo` with `[isAddNew]` as a dependency, so the schema only recomputes when the add/edit mode changes, avoiding unnecessary re-validations on every render."}
{"text":"File: AddOrEditBooking.js, Q: How does the conditional `when('bookingType')` logic work for `unit`, `company`, and `email`? A: Yup’s `.when` checks the first element of `bookingType`; if it matches a target, it applies `.required(requiredMessage)`, otherwise marks the field as nullable."}
{"text":"File: AddOrEditBooking.js, Q: What does the custom `.test('at-least-one-selected', ...)` do for `slots`? A: It defines a custom validation named ‘at-least-one-selected’ that fails unless the array contains at least one element with `slot.isCheck === true`, enforcing slot selection for new bookings."}
{"text":"File: AddOrEditBooking.js, Q: What is the primary purpose of the `calculateDepositPrice` function? A: To compute and update the booking deposit based on the selected time slots and the amenity’s predefined time-rule pricing."}
{"text":"File: AddOrEditBooking.js, Q: What is the primary purpose of the `recurringBooking` function? A: To validate and prepare a recurring series of booking slots before actually saving them, by calling `validateRecurringBooking` and then showing a confirmation modal."}
{"text":"File: AddOrEditBooking.js, Q: How does `onSave` choose between `addBooking` and `updateBooking`? A: It checks `!isAddNew`: if true (edit mode), calls `updateBooking(payload)`; otherwise calls `addBooking(payload)` for new bookings."}
{"text":"File: AddOrEditBooking.js, Q: What does the `getTitle` function do? A: It returns the screen title based on mode: if `isAddNew` is true, it returns the localized string for 'ADD_BOOKING'; otherwise it returns 'EDIT_BOOKING', ensuring the header reflects whether the user is adding or editing a booking."}
