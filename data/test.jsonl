{"text":"// ===== TaskManagement ====="}
{"text":"// ===== API Handler Wrappers ====="}
{"text":"Q: Why use withErrorHandling(GET_TASK_LIST, getTaskList)? A: To automatically dispatch GET_TASK_LIST.REQUEST before the API call and GET_TASK_LIST.SUCCESS or GET_TASK_LIST.FAILURE after, centralizing error and lifecycle handling."}
{"text":"// ===== Action & Saga Integration ====="}
{"text":"Q: Which saga watcher handles ADD_TASK.REQUEST? A: A watcher using takeEvery(ADD_TASK.REQUEST, handleAddTask) invokes the addTask worker, uploads files, navigates back, and dispatches ADD_TASK.SUCCESS or ADD_TASK.FAILURE."}
{"text":"// ===== Reducer & State Management ====="}
{"text":"Q: How does the reducer respond to GET_TASK_DETAIL.SUCCESS? A: It sets state.taskDetail = payload, storing the fetched task details in the Redux store."}
{"text":"// ===== Business Logic & Side Effects ====="}
{"text":"Q: Why call NavigationServices.goBack() after updateTask? A: To navigate back automatically once the task update and any file uploads complete successfully, ensuring a smooth UX."}
{"text":"// ===== Feedback ====="}
{"text":"// ===== API Handler Wrappers ====="}
{"text":"Q: How does detailFB(id) wrap its API call? A: It dispatches DETAIL_FB.REQUEST(id), calls RequestApi.getDetailFB(id), then dispatches DETAIL_FB.SUCCESS(response) or DETAIL_FB.FAILURE(err) within a try/catch."}
{"text":"// ===== Action & Saga Integration ====="}
{"text":"Q: Which saga listens for GET_LIST_FB_REQUEST? A: A watcher saga with takeEvery(GET_LIST_FB_REQUEST, handleGetListFB) calls the getListFB worker and dispatches GET_LIST_FB.SUCCESS or GET_LIST_FB.FAILURE."}
{"text":"// ===== Reducer & State Management ====="}
{"text":"Q: What does GET_LIST_FB_SUCCESS do in the reducer? A: It calls state.list.setData(payload) on the ListModel and returns a deep clone, updating the feedback list in state."}
{"text":"// ===== Business Logic & Side Effects ====="}
{"text":"Q: Why upload files only after createFeedback returns a GUID? A: Because the new feedback GUID is required to associate uploaded files correctly, so uploads occur only on successful creation."}
{"text":"// ===== Booking ====="}
{"text":"// ===== API Handler Wrappers ====="}
{"text":"Q: What does validateRecurringBooking wrap and dispatch? A: It wraps RequestApi.validateRecurringBooking(payload) and, with withLoadingAndErrorHandling(VALIDATE_RECURRING_BOOKING), dispatches VALIDATE_RECURRING_BOOKING.REQUEST, SUCCESS, or FAILURE around the call."}
{"text":"// ===== Action & Saga Integration ====="}
{"text":"Q: Which saga watcher handles FILTER_BOOKINGS.REQUEST? A: takeEvery(FILTER_BOOKINGS.REQUEST, handleFilterBookings) is used to fetch filtered bookings and dispatch FILTER_BOOKINGS.SUCCESS or FILTER_BOOKINGS.FAILURE."}
{"text":"// ===== Reducer & State Management ====="}
{"text":"Q: How does GET_ALL_TIMESLOTS.SUCCESS update the reducer? A: It sets state.bookingSlots = payload, storing the fetched timeslot availability in Redux state."}
{"text":"// ===== Business Logic & Side Effects ====="}
{"text":"Q: Why dispatch resetBookingDetailRequest on unmount? A: To clear state.bookingDetail, preventing stale reservation details from appearing when revisiting the booking screen."}